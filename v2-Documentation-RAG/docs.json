[
  {
    "url": "https://kubernetes.io/docs/concepts/overview/#why-you-need-kubernetes-and-what-can-it-do",
    "content": "Overview | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationConceptsOverviewOverviewKubernetes is a portable, extensible, open source platform for managing containerized workloads and services, that facilitates both declarative configuration and automation. It has a large, rapidly growing ecosystem. Kubernetes services, support, and tools are widely available.This page is an overview of Kubernetes.The name Kubernetes originates from Greek, meaning helmsman or pilot. K8s as an abbreviation\nresults from counting the eight letters between the \"K\" and the \"s\". Google open-sourced the\nKubernetes project in 2014. Kubernetes combines\nover 15 years of Google's experience running\nproduction workloads at scale with best-of-breed ideas and practices from the community.Why you need Kubernetes and what it can doContainers are a good way to bundle and run your applications. In a production\nenvironment, you need to manage the containers that run the applications and\nensure that there is no downtime. For example, if a container goes down, another\ncontainer needs to start. Wouldn't it be easier if this behavior was handled by a system?That's how Kubernetes comes to the rescue! Kubernetes provides you with a framework\nto run distributed systems resiliently. It takes care of scaling and failover for\nyour application, provides deployment patterns, and more. For example: Kubernetes\ncan easily manage a canary deployment for your system.Kubernetes provides you with:Service discovery and load balancing\nKubernetes can expose a container using the DNS name or using their own IP address.\nIf traffic to a container is high, Kubernetes is able to load balance and distribute\nthe network traffic so that the deployment is stable.Storage orchestration\nKubernetes allows you to automatically mount a storage system of your choice, such as\nlocal storages, public cloud providers, and more.Automated rollouts and rollbacks\nYou can describe the desired state for your deployed containers using Kubernetes,\nand it can change the actual state to the desired state at a controlled rate.\nFor example, you can automate Kubernetes to create new containers for your\ndeployment, remove existing containers and adopt all their resources to the new container.Automatic bin packing\nYou provide Kubernetes with a cluster of nodes that it can use to run containerized tasks.\nYou tell Kubernetes how much CPU and memory (RAM) each container needs. Kubernetes can fit\ncontainers onto your nodes to make the best use of your resources.Self-healing\nKubernetes restarts containers that fail, replaces containers, kills containers that don't\nrespond to your user-defined health check, and doesn't advertise them to clients until they\nare ready to serve.Secret and configuration management\nKubernetes lets you store and manage sensitive information, such as passwords, OAuth tokens,\nand SSH keys. You can deploy and update secrets and application configuration without\nrebuilding your container images, and without exposing secrets in your stack configuration.Batch execution\nIn addition to services, Kubernetes can manage your batch and CI workloads, replacing containers that fail, if desired.Horizontal scaling\nScale your application up and down with a simple command, with a UI, or automatically based on CPU usage.IPv4/IPv6 dual-stack\nAllocation of IPv4 and IPv6 addresses to Pods and ServicesDesigned for extensibility\nAdd features to your Kubernetes cluster without changing upstream source code.What Kubernetes is notKubernetes is not a traditional, all-inclusive PaaS (Platform as a Service) system.\nSince Kubernetes operates at the container level rather than at the hardware level,\nit provides some generally applicable features common to PaaS offerings, such as\ndeployment, scaling, load balancing, and lets users integrate their logging, monitoring,\nand alerting solutions. However, Kubernetes is not monolithic, and these default solutions\nare optional and pluggable. Kubernetes provides the building blocks for building developer\nplatforms, but preserves user choice and flexibility where it is important.Kubernetes:Does not limit the types of applications supported. Kubernetes aims to support an\nextremely diverse variety of workloads, including stateless, stateful, and data-processing\nworkloads. If an application can run in a container, it should run great on Kubernetes.Does not deploy source code and does not build your application. Continuous Integration,\nDelivery, and Deployment (CI/CD) workflows are determined by organization cultures and\npreferences as well as technical requirements.Does not provide application-level services, such as middleware (for example, message buses),\ndata-processing frameworks (for example, Spark), databases (for example, MySQL), caches, nor\ncluster storage systems (for example, Ceph) as built-in services. Such components can run on\nKubernetes, and/or can be accessed by applications running on Kubernetes through portable\nmechanisms, such as the Open Service Broker.Does not dictate logging, monitoring, or alerting solutions. It provides some integrations\nas proof of concept, and mechanisms to collect and export metrics.Does not provide nor mandate a configuration language/system (for example, Jsonnet). It provides\na declarative API that may be targeted by arbitrary forms of declarative specifications.Does not provide nor adopt any comprehensive machine configuration, maintenance, management,\nor self-healing systems.Additionally, Kubernetes is not a mere orchestration system. In fact, it eliminates the need\nfor orchestration. The technical definition of orchestration is execution of a defined workflow:\nfirst do A, then B, then C. In contrast, Kubernetes comprises a set of independent, composable\ncontrol processes that continuously drive the current state towards the provided desired state.\nIt shouldn't matter how you get from A to C. Centralized control is also not required. This\nresults in a system that is easier to use and more powerful, robust, resilient, and extensible.Historical context for KubernetesLet's take a look at why Kubernetes is so useful by going back in time.Traditional deployment era:Early on, organizations ran applications on physical servers. There was no way to define\nresource boundaries for applications in a physical server, and this caused resource\nallocation issues. For example, if multiple applications run on a physical server, there\ncan be instances where one application would take up most of the resources, and as a result,\nthe other applications would underperform. A solution for this would be to run each application\non a different physical server. But this did not scale as resources were underutilized, and it\nwas expensive for organizations to maintain many physical servers.Virtualized deployment era:As a solution, virtualization was introduced. It allows you\nto run multiple Virtual Machines (VMs) on a single physical server's CPU. Virtualization\nallows applications to be isolated between VMs and provides a level of security as the\ninformation of one application cannot be freely accessed by another application.Virtualization allows better utilization of resources in a physical server and allows\nbetter scalability because an application can be added or updated easily, reduces\nhardware costs, and much more. With virtualization you can present a set of physical\nresources as a cluster of disposable virtual machines.Each VM is a full machine running all the components, including its own operating\nsystem, on top of the virtualized hardware.Container deployment era:Containers are similar to VMs, but they have relaxed\nisolation properties to share the Operating System (OS) among the applications.\nTherefore, containers are considered lightweight. Similar to a VM, a container\nhas its own filesystem, share of CPU, memory, process space, and more. As they\nare decoupled from the underlying infrastructure, they are portable across clouds\nand OS distributions.Containers have become popular because they provide extra benefits, such as:Agile application creation and deployment: increased ease and efficiency of\ncontainer image creation compared to VM image use.Continuous development, integration, and deployment: provides for reliable\nand frequent container image build and deployment with quick and efficient\nrollbacks (due to image immutability).Dev and Ops separation of concerns: create application container images at\nbuild/release time rather than deployment time, thereby decoupling\napplications from infrastructure.Observability: not only surfaces OS-level information and metrics, but also\napplication health and other signals.Environmental consistency across development, testing, and production: runs\nthe same on a laptop as it does in the cloud.Cloud and OS distribution portability: runs on Ubuntu, RHEL, CoreOS, on-premises,\non major public clouds, and anywhere else.Application-centric management: raises the level of abstraction from running an\nOS on virtual hardware to running an application on an OS using logical resources.Loosely coupled, distributed, elastic, liberated micro-services: applications are\nbroken into smaller, independent pieces and can be deployed and managed dynamically \u2013\nnot a monolithic stack running on one big single-purpose machine.Resource isolation: predictable application performance.Resource utilization: high efficiency and density.What's nextTake a look at the Kubernetes ComponentsTake a look at the The Kubernetes APITake a look at the Cluster ArchitectureReady to Get Started?FeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified September 11, 2024 at 3:17 PM PST: Removed duplicated paragraph (7e71096044) Edit this page\nCreate child page\nCreate an issue\nPrint entire sectionWhy you need Kubernetes and what it can doWhat Kubernetes is notHistorical context for KubernetesWhat's next\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "#why-you-need-kubernetes-and-what-can-it-do"
  },
  {
    "url": "https://kubernetes.io/docs/concepts/overview/components/",
    "content": "Kubernetes Components | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationConceptsOverviewKubernetes ComponentsKubernetes ComponentsAn overview of the key components that make up a Kubernetes cluster.This page provides a high-level overview of the essential components that make up a Kubernetes cluster.The components of a Kubernetes clusterCore ComponentsA Kubernetes cluster consists of a control plane and one or more worker nodes.\nHere's a brief overview of the main components:Control Plane ComponentsManage the overall state of the cluster:kube-apiserverThe core component server that exposes the Kubernetes HTTP API.etcdConsistent and highly-available key value store for all API server data.kube-schedulerLooks for Pods not yet bound to a node, and assigns each Pod to a suitable node.kube-controller-managerRuns controllers to implement Kubernetes API behavior.cloud-controller-manager (optional)Integrates with underlying cloud provider(s).Node ComponentsRun on every node, maintaining running pods and providing the Kubernetes runtime environment:kubeletEnsures that Pods are running, including their containers.kube-proxy (optional)Maintains network rules on nodes to implement Services.Container runtimeSoftware responsible for running containers. Read\nContainer Runtimes to learn more.\ud83d\udec7 This item links to a third party project or product that is not part of Kubernetes itself. More informationYour cluster may require additional software on each node; for example, you might also\nrun systemd on a Linux node to supervise local components.AddonsAddons extend the functionality of Kubernetes. A few important examples include:DNSFor cluster-wide DNS resolution.Web UI (Dashboard)For cluster management via a web interface.Container Resource MonitoringFor collecting and storing container metrics.Cluster-level LoggingFor saving container logs to a central log store.Flexibility in ArchitectureKubernetes allows for flexibility in how these components are deployed and managed.\nThe architecture can be adapted to various needs, from small development environments\nto large-scale production deployments.For more detailed information about each component and various ways to configure your\ncluster architecture, see the Cluster Architecture page.Items on this page refer to third party products or projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for those third-party products or projects. See the CNCF website guidelines for more details.You should read the content guide before proposing a change that adds an extra third-party link.FeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified May 31, 2025 at 8:36 AM PST: Fix missing periods at the end of sentences (f0b3dc1f07) Edit this page Third party content advice\nCreate child page\nCreate an issue\nPrint entire sectionCore ComponentsControl Plane ComponentsNode ComponentsAddonsFlexibility in Architecture\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "kubernetes-docs"
  },
  {
    "url": "https://kubernetes.io/docs/concepts/overview/kubernetes-api/",
    "content": "The Kubernetes API | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationConceptsOverviewThe Kubernetes APIThe Kubernetes APIThe Kubernetes API lets you query and manipulate the state of objects in Kubernetes. The core of Kubernetes' control plane is the API server and the HTTP API that it exposes. Users, the different parts of your cluster, and external components all communicate with one another through the API server.The core of Kubernetes' control plane\nis the API server. The API server\nexposes an HTTP API that lets end users, different parts of your cluster, and\nexternal components communicate with one another.The Kubernetes API lets you query and manipulate the state of API objects in Kubernetes\n(for example: Pods, Namespaces, ConfigMaps, and Events).Most operations can be performed through the kubectl\ncommand-line interface or other command-line tools, such as\nkubeadm, which in turn use the API.\nHowever, you can also access the API directly using REST calls. Kubernetes\nprovides a set of client libraries\nfor those looking to\nwrite applications using the Kubernetes API.Each Kubernetes cluster publishes the specification of the APIs that the cluster serves.\nThere are two mechanisms that Kubernetes uses to publish these API specifications; both are useful\nto enable automatic interoperability. For example, the kubectl tool fetches and caches the API\nspecification for enabling command-line completion and other features.\nThe two supported mechanisms are as follows:The Discovery API provides information about the Kubernetes APIs:\nAPI names, resources, versions, and supported operations. This is a Kubernetes\nspecific term as it is a separate API from the Kubernetes OpenAPI.\nIt is intended to be a brief summary of the available resources and it does not\ndetail specific schema for the resources. For reference about resource schemas,\nplease refer to the OpenAPI document.The Kubernetes OpenAPI Document provides (full)\nOpenAPI v2.0 and 3.0 schemas for all Kubernetes API\nendpoints.\nThe OpenAPI v3 is the preferred method for accessing OpenAPI as it\nprovides\na more comprehensive and accurate view of the API. It includes all the available\nAPI paths, as well as all resources consumed and produced for every operations\non every endpoints. It also includes any extensibility components that a cluster supports.\nThe data is a complete specification and is significantly larger than that from the\nDiscovery API.Discovery APIKubernetes publishes a list of all group versions and resources supported via\nthe Discovery API. This includes the following for each resource:NameCluster or namespaced scopeEndpoint URL and supported verbsAlternative namesGroup, version, kindThe API is available in both aggregated and unaggregated form. The aggregated\ndiscovery serves two endpoints, while the unaggregated discovery serves a\nseparate endpoint for each group version.Aggregated discoveryFEATURE STATE:\nKubernetes v1.30 [stable] (enabled by default: true)Kubernetes offers stable support for aggregated discovery, publishing\nall resources supported by a cluster through two endpoints (/api and\n/apis). Requesting this\nendpoint drastically reduces the number of requests sent to fetch the\ndiscovery data from the cluster. You can access the data by\nrequesting the respective endpoints with an Accept header indicating\nthe aggregated discovery resource:\nAccept: application/json;v=v2;g=apidiscovery.k8s.io;as=APIGroupDiscoveryList.Without indicating the resource type using the Accept header, the default\nresponse for the /api and /apis endpoint is an unaggregated discovery\ndocument.The discovery document\nfor the built-in resources can be found in the Kubernetes GitHub repository.\nThis Github document can be used as a reference of the base set of the available resources\nif a Kubernetes cluster is not available to query.The endpoint also supports ETag and protobuf encoding.Unaggregated discoveryWithout discovery aggregation, discovery is published in levels, with the root\nendpoints publishing discovery information for downstream documents.A list of all group versions supported by a cluster is published at\nthe /api and /apis endpoints. Example:{\n\"kind\": \"APIGroupList\",\n\"apiVersion\": \"v1\",\n\"groups\": [\n{\n\"name\": \"apiregistration.k8s.io\",\n\"versions\": [\n{\n\"groupVersion\": \"apiregistration.k8s.io/v1\",\n\"version\": \"v1\"\n}\n],\n\"preferredVersion\": {\n\"groupVersion\": \"apiregistration.k8s.io/v1\",\n\"version\": \"v1\"\n}\n},\n{\n\"name\": \"apps\",\n\"versions\": [\n{\n\"groupVersion\": \"apps/v1\",\n\"version\": \"v1\"\n}\n],\n\"preferredVersion\": {\n\"groupVersion\": \"apps/v1\",\n\"version\": \"v1\"\n}\n},\n...\n}\nAdditional requests are needed to obtain the discovery document for each group version at\n/apis/<group>/<version> (for example:\n/apis/rbac.authorization.k8s.io/v1alpha1), which advertises the list of\nresources served under a particular group version. These endpoints are used by\nkubectl to fetch the list of resources supported by a cluster.OpenAPI interface definitionFor details about the OpenAPI specifications, see the OpenAPI documentation.Kubernetes serves both OpenAPI v2.0 and OpenAPI v3.0. OpenAPI v3 is the\npreferred method of accessing the OpenAPI because it offers a more comprehensive\n(lossless) representation of Kubernetes resources. Due to limitations of OpenAPI\nversion 2, certain fields are dropped from the published OpenAPI including but not\nlimited to default, nullable, oneOf.OpenAPI V2The Kubernetes API server serves an aggregated OpenAPI v2 spec via the\n/openapi/v2 endpoint. You can request the response format using\nrequest headers as follows:Valid request header values for OpenAPI v2 queriesHeaderPossible valuesNotesAccept-Encodinggzipnot supplying this header is also acceptableAcceptapplication/com.github.proto-openapi.spec.v2@v1.0+protobufmainly for intra-cluster useapplication/jsondefault*serves application/jsonWarning:The validation rules published as part of OpenAPI schemas may not be complete, and usually aren't.\nAdditional validation occurs within the API server. If you want precise and complete verification,\na kubectl apply --dry-run=server runs all the applicable validation (and also activates admission-time\nchecks).OpenAPI V3FEATURE STATE:\nKubernetes v1.27 [stable] (enabled by default: true)Kubernetes supports publishing a description of its APIs as OpenAPI v3.A discovery endpoint /openapi/v3 is provided to see a list of all\ngroup/versions available. This endpoint only returns JSON. These\ngroup/versions are provided in the following format:{\n\"paths\": {\n...,\n\"api/v1\": {\n\"serverRelativeURL\": \"/openapi/v3/api/v1?hash=CC0E9BFD992D8C59AEC98A1E2336F899E8318D3CF4C68944C3DEC640AF5AB52D864AC50DAA8D145B3494F75FA3CFF939FCBDDA431DAD3CA79738B297795818CF\"\n},\n\"apis/admissionregistration.k8s.io/v1\": {\n\"serverRelativeURL\": \"/openapi/v3/apis/admissionregistration.k8s.io/v1?hash=E19CC93A116982CE5422FC42B590A8AFAD92CDE9AE4D59B5CAAD568F083AD07946E6CB5817531680BCE6E215C16973CD39003B0425F3477CFD854E89A9DB6597\"\n},\n....\n}\n}\nThe relative URLs are pointing to immutable OpenAPI descriptions, in\norder to improve client-side caching. The proper HTTP caching headers\nare also set by the API server for that purpose (Expires to 1 year in\nthe future, and Cache-Control to immutable). When an obsolete URL is\nused, the API server returns a redirect to the newest URL.The Kubernetes API server publishes an OpenAPI v3 spec per Kubernetes\ngroup version at the /openapi/v3/apis/<group>/<version>?hash=<hash>\nendpoint.Refer to the table below for accepted request headers.Valid request header values for OpenAPI v3 queriesHeaderPossible valuesNotesAccept-Encodinggzipnot supplying this header is also acceptableAcceptapplication/com.github.proto-openapi.spec.v3@v1.0+protobufmainly for intra-cluster useapplication/jsondefault*serves application/jsonA Golang implementation to fetch the OpenAPI V3 is provided in the package\nk8s.io/client-go/openapi3.Kubernetes 1.34 publishes\nOpenAPI v2.0 and v3.0; there are no plans to support 3.1 in the near future.Protobuf serializationKubernetes implements an alternative Protobuf based serialization format that\nis primarily intended for intra-cluster communication. For more information\nabout this format, see the Kubernetes Protobuf serialization\ndesign proposal and the\nInterface Definition Language (IDL) files for each schema located in the Go\npackages that define the API objects.PersistenceKubernetes stores the serialized state of objects by writing them into\netcd.API groups and versioningTo make it easier to eliminate fields or restructure resource representations,\nKubernetes supports multiple API versions, each at a different API path, such\nas /api/v1 or /apis/rbac.authorization.k8s.io/v1alpha1.Versioning is done at the API level rather than at the resource or field level\nto ensure that the API presents a clear, consistent view of system resources\nand behavior, and to enable controlling access to end-of-life and/or\nexperimental APIs.To make it easier to evolve and to extend its API, Kubernetes implements\nAPI groups that can be\nenabled or disabled.API resources are distinguished by their API group, resource type, namespace\n(for namespaced resources), and name. The API server handles the conversion between\nAPI versions transparently: all the different versions are actually representations\nof the same persisted data. The API server may serve the same underlying data\nthrough multiple API versions.For example, suppose there are two API versions, v1 and v1beta1, for the same\nresource. If you originally created an object using the v1beta1 version of its\nAPI, you can later read, update, or delete that object using either the v1beta1\nor the v1 API version, until the v1beta1 version is deprecated and removed.\nAt that point you can continue accessing and modifying the object using the v1 API.API changesAny system that is successful needs to grow and change as new use cases emerge or existing ones change.\nTherefore, Kubernetes has designed the Kubernetes API to continuously change and grow.\nThe Kubernetes project aims to not break compatibility with existing clients, and to maintain that\ncompatibility for a length of time so that other projects have an opportunity to adapt.In general, new API resources and new resource fields can be added often and frequently.\nElimination of resources or fields requires following the\nAPI deprecation policy.Kubernetes makes a strong commitment to maintain compatibility for official Kubernetes APIs\nonce they reach general availability (GA), typically at API version v1. Additionally,\nKubernetes maintains compatibility with data persisted via beta API versions of official Kubernetes APIs,\nand ensures that data can be converted and accessed via GA API versions when the feature goes stable.If you adopt a beta API version, you will need to transition to a subsequent beta or stable API version\nonce the API graduates. The best time to do this is while the beta API is in its deprecation period,\nsince objects are simultaneously accessible via both API versions. Once the beta API completes its\ndeprecation period and is no longer served, the replacement API version must be used.Note:Although Kubernetes also aims to maintain compatibility for alpha APIs versions, in some\ncircumstances this is not possible. If you use any alpha API versions, check the release notes\nfor Kubernetes when upgrading your cluster, in case the API did change in incompatible\nways that require deleting all existing alpha objects prior to upgrade.Refer to API versions reference\nfor more details on the API version level definitions.API ExtensionThe Kubernetes API can be extended in one of two ways:Custom resources\nlet you declaratively define how the API server should provide your chosen resource API.You can also extend the Kubernetes API by implementing an\naggregation layer.What's nextLearn how to extend the Kubernetes API by adding your own\nCustomResourceDefinition.Controlling Access To The Kubernetes API describes\nhow the cluster manages authentication and authorization for API access.Learn about API endpoints, resource types and samples by reading\nAPI Reference.Learn about what constitutes a compatible change, and how to change the API, from\nAPI changes.FeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified January 08, 2025 at 10:50 AM PST: Fix feature gate name conflicts (2/2) (3782732ce4) Edit this page\nCreate child page\nCreate an issue\nPrint entire sectionDiscovery APIAggregated discoveryUnaggregated discoveryOpenAPI interface definitionOpenAPI V2OpenAPI V3Protobuf serializationPersistenceAPI groups and versioningAPI changesAPI ExtensionWhat's next\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "kubernetes-docs"
  },
  {
    "url": "https://kubernetes.io/docs/concepts/overview/kubernetes-api/",
    "content": "The Kubernetes API | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationConceptsOverviewThe Kubernetes APIThe Kubernetes APIThe Kubernetes API lets you query and manipulate the state of objects in Kubernetes. The core of Kubernetes' control plane is the API server and the HTTP API that it exposes. Users, the different parts of your cluster, and external components all communicate with one another through the API server.The core of Kubernetes' control plane\nis the API server. The API server\nexposes an HTTP API that lets end users, different parts of your cluster, and\nexternal components communicate with one another.The Kubernetes API lets you query and manipulate the state of API objects in Kubernetes\n(for example: Pods, Namespaces, ConfigMaps, and Events).Most operations can be performed through the kubectl\ncommand-line interface or other command-line tools, such as\nkubeadm, which in turn use the API.\nHowever, you can also access the API directly using REST calls. Kubernetes\nprovides a set of client libraries\nfor those looking to\nwrite applications using the Kubernetes API.Each Kubernetes cluster publishes the specification of the APIs that the cluster serves.\nThere are two mechanisms that Kubernetes uses to publish these API specifications; both are useful\nto enable automatic interoperability. For example, the kubectl tool fetches and caches the API\nspecification for enabling command-line completion and other features.\nThe two supported mechanisms are as follows:The Discovery API provides information about the Kubernetes APIs:\nAPI names, resources, versions, and supported operations. This is a Kubernetes\nspecific term as it is a separate API from the Kubernetes OpenAPI.\nIt is intended to be a brief summary of the available resources and it does not\ndetail specific schema for the resources. For reference about resource schemas,\nplease refer to the OpenAPI document.The Kubernetes OpenAPI Document provides (full)\nOpenAPI v2.0 and 3.0 schemas for all Kubernetes API\nendpoints.\nThe OpenAPI v3 is the preferred method for accessing OpenAPI as it\nprovides\na more comprehensive and accurate view of the API. It includes all the available\nAPI paths, as well as all resources consumed and produced for every operations\non every endpoints. It also includes any extensibility components that a cluster supports.\nThe data is a complete specification and is significantly larger than that from the\nDiscovery API.Discovery APIKubernetes publishes a list of all group versions and resources supported via\nthe Discovery API. This includes the following for each resource:NameCluster or namespaced scopeEndpoint URL and supported verbsAlternative namesGroup, version, kindThe API is available in both aggregated and unaggregated form. The aggregated\ndiscovery serves two endpoints, while the unaggregated discovery serves a\nseparate endpoint for each group version.Aggregated discoveryFEATURE STATE:\nKubernetes v1.30 [stable] (enabled by default: true)Kubernetes offers stable support for aggregated discovery, publishing\nall resources supported by a cluster through two endpoints (/api and\n/apis). Requesting this\nendpoint drastically reduces the number of requests sent to fetch the\ndiscovery data from the cluster. You can access the data by\nrequesting the respective endpoints with an Accept header indicating\nthe aggregated discovery resource:\nAccept: application/json;v=v2;g=apidiscovery.k8s.io;as=APIGroupDiscoveryList.Without indicating the resource type using the Accept header, the default\nresponse for the /api and /apis endpoint is an unaggregated discovery\ndocument.The discovery document\nfor the built-in resources can be found in the Kubernetes GitHub repository.\nThis Github document can be used as a reference of the base set of the available resources\nif a Kubernetes cluster is not available to query.The endpoint also supports ETag and protobuf encoding.Unaggregated discoveryWithout discovery aggregation, discovery is published in levels, with the root\nendpoints publishing discovery information for downstream documents.A list of all group versions supported by a cluster is published at\nthe /api and /apis endpoints. Example:{\n\"kind\": \"APIGroupList\",\n\"apiVersion\": \"v1\",\n\"groups\": [\n{\n\"name\": \"apiregistration.k8s.io\",\n\"versions\": [\n{\n\"groupVersion\": \"apiregistration.k8s.io/v1\",\n\"version\": \"v1\"\n}\n],\n\"preferredVersion\": {\n\"groupVersion\": \"apiregistration.k8s.io/v1\",\n\"version\": \"v1\"\n}\n},\n{\n\"name\": \"apps\",\n\"versions\": [\n{\n\"groupVersion\": \"apps/v1\",\n\"version\": \"v1\"\n}\n],\n\"preferredVersion\": {\n\"groupVersion\": \"apps/v1\",\n\"version\": \"v1\"\n}\n},\n...\n}\nAdditional requests are needed to obtain the discovery document for each group version at\n/apis/<group>/<version> (for example:\n/apis/rbac.authorization.k8s.io/v1alpha1), which advertises the list of\nresources served under a particular group version. These endpoints are used by\nkubectl to fetch the list of resources supported by a cluster.OpenAPI interface definitionFor details about the OpenAPI specifications, see the OpenAPI documentation.Kubernetes serves both OpenAPI v2.0 and OpenAPI v3.0. OpenAPI v3 is the\npreferred method of accessing the OpenAPI because it offers a more comprehensive\n(lossless) representation of Kubernetes resources. Due to limitations of OpenAPI\nversion 2, certain fields are dropped from the published OpenAPI including but not\nlimited to default, nullable, oneOf.OpenAPI V2The Kubernetes API server serves an aggregated OpenAPI v2 spec via the\n/openapi/v2 endpoint. You can request the response format using\nrequest headers as follows:Valid request header values for OpenAPI v2 queriesHeaderPossible valuesNotesAccept-Encodinggzipnot supplying this header is also acceptableAcceptapplication/com.github.proto-openapi.spec.v2@v1.0+protobufmainly for intra-cluster useapplication/jsondefault*serves application/jsonWarning:The validation rules published as part of OpenAPI schemas may not be complete, and usually aren't.\nAdditional validation occurs within the API server. If you want precise and complete verification,\na kubectl apply --dry-run=server runs all the applicable validation (and also activates admission-time\nchecks).OpenAPI V3FEATURE STATE:\nKubernetes v1.27 [stable] (enabled by default: true)Kubernetes supports publishing a description of its APIs as OpenAPI v3.A discovery endpoint /openapi/v3 is provided to see a list of all\ngroup/versions available. This endpoint only returns JSON. These\ngroup/versions are provided in the following format:{\n\"paths\": {\n...,\n\"api/v1\": {\n\"serverRelativeURL\": \"/openapi/v3/api/v1?hash=CC0E9BFD992D8C59AEC98A1E2336F899E8318D3CF4C68944C3DEC640AF5AB52D864AC50DAA8D145B3494F75FA3CFF939FCBDDA431DAD3CA79738B297795818CF\"\n},\n\"apis/admissionregistration.k8s.io/v1\": {\n\"serverRelativeURL\": \"/openapi/v3/apis/admissionregistration.k8s.io/v1?hash=E19CC93A116982CE5422FC42B590A8AFAD92CDE9AE4D59B5CAAD568F083AD07946E6CB5817531680BCE6E215C16973CD39003B0425F3477CFD854E89A9DB6597\"\n},\n....\n}\n}\nThe relative URLs are pointing to immutable OpenAPI descriptions, in\norder to improve client-side caching. The proper HTTP caching headers\nare also set by the API server for that purpose (Expires to 1 year in\nthe future, and Cache-Control to immutable). When an obsolete URL is\nused, the API server returns a redirect to the newest URL.The Kubernetes API server publishes an OpenAPI v3 spec per Kubernetes\ngroup version at the /openapi/v3/apis/<group>/<version>?hash=<hash>\nendpoint.Refer to the table below for accepted request headers.Valid request header values for OpenAPI v3 queriesHeaderPossible valuesNotesAccept-Encodinggzipnot supplying this header is also acceptableAcceptapplication/com.github.proto-openapi.spec.v3@v1.0+protobufmainly for intra-cluster useapplication/jsondefault*serves application/jsonA Golang implementation to fetch the OpenAPI V3 is provided in the package\nk8s.io/client-go/openapi3.Kubernetes 1.34 publishes\nOpenAPI v2.0 and v3.0; there are no plans to support 3.1 in the near future.Protobuf serializationKubernetes implements an alternative Protobuf based serialization format that\nis primarily intended for intra-cluster communication. For more information\nabout this format, see the Kubernetes Protobuf serialization\ndesign proposal and the\nInterface Definition Language (IDL) files for each schema located in the Go\npackages that define the API objects.PersistenceKubernetes stores the serialized state of objects by writing them into\netcd.API groups and versioningTo make it easier to eliminate fields or restructure resource representations,\nKubernetes supports multiple API versions, each at a different API path, such\nas /api/v1 or /apis/rbac.authorization.k8s.io/v1alpha1.Versioning is done at the API level rather than at the resource or field level\nto ensure that the API presents a clear, consistent view of system resources\nand behavior, and to enable controlling access to end-of-life and/or\nexperimental APIs.To make it easier to evolve and to extend its API, Kubernetes implements\nAPI groups that can be\nenabled or disabled.API resources are distinguished by their API group, resource type, namespace\n(for namespaced resources), and name. The API server handles the conversion between\nAPI versions transparently: all the different versions are actually representations\nof the same persisted data. The API server may serve the same underlying data\nthrough multiple API versions.For example, suppose there are two API versions, v1 and v1beta1, for the same\nresource. If you originally created an object using the v1beta1 version of its\nAPI, you can later read, update, or delete that object using either the v1beta1\nor the v1 API version, until the v1beta1 version is deprecated and removed.\nAt that point you can continue accessing and modifying the object using the v1 API.API changesAny system that is successful needs to grow and change as new use cases emerge or existing ones change.\nTherefore, Kubernetes has designed the Kubernetes API to continuously change and grow.\nThe Kubernetes project aims to not break compatibility with existing clients, and to maintain that\ncompatibility for a length of time so that other projects have an opportunity to adapt.In general, new API resources and new resource fields can be added often and frequently.\nElimination of resources or fields requires following the\nAPI deprecation policy.Kubernetes makes a strong commitment to maintain compatibility for official Kubernetes APIs\nonce they reach general availability (GA), typically at API version v1. Additionally,\nKubernetes maintains compatibility with data persisted via beta API versions of official Kubernetes APIs,\nand ensures that data can be converted and accessed via GA API versions when the feature goes stable.If you adopt a beta API version, you will need to transition to a subsequent beta or stable API version\nonce the API graduates. The best time to do this is while the beta API is in its deprecation period,\nsince objects are simultaneously accessible via both API versions. Once the beta API completes its\ndeprecation period and is no longer served, the replacement API version must be used.Note:Although Kubernetes also aims to maintain compatibility for alpha APIs versions, in some\ncircumstances this is not possible. If you use any alpha API versions, check the release notes\nfor Kubernetes when upgrading your cluster, in case the API did change in incompatible\nways that require deleting all existing alpha objects prior to upgrade.Refer to API versions reference\nfor more details on the API version level definitions.API ExtensionThe Kubernetes API can be extended in one of two ways:Custom resources\nlet you declaratively define how the API server should provide your chosen resource API.You can also extend the Kubernetes API by implementing an\naggregation layer.What's nextLearn how to extend the Kubernetes API by adding your own\nCustomResourceDefinition.Controlling Access To The Kubernetes API describes\nhow the cluster manages authentication and authorization for API access.Learn about API endpoints, resource types and samples by reading\nAPI Reference.Learn about what constitutes a compatible change, and how to change the API, from\nAPI changes.FeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified January 08, 2025 at 10:50 AM PST: Fix feature gate name conflicts (2/2) (3782732ce4) Edit this page\nCreate child page\nCreate an issue\nPrint entire sectionDiscovery APIAggregated discoveryUnaggregated discoveryOpenAPI interface definitionOpenAPI V2OpenAPI V3Protobuf serializationPersistenceAPI groups and versioningAPI changesAPI ExtensionWhat's next\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "kubernetes-docs"
  },
  {
    "url": "https://kubernetes.io/docs/concepts/overview/working-with-objects/",
    "content": "Objects In Kubernetes | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nBahasa Indonesia (Indonesian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationConceptsOverviewObjects In KubernetesObjects In KubernetesKubernetes objects are persistent entities in the Kubernetes system. Kubernetes uses these entities to represent the state of your cluster. Learn about the Kubernetes object model and how to work with these objects.This page explains how Kubernetes objects are represented in the Kubernetes API, and how you can\nexpress them in .yaml format.Understanding Kubernetes objectsKubernetes objects are persistent entities in the Kubernetes system. Kubernetes uses these\nentities to represent the state of your cluster. Specifically, they can describe:What containerized applications are running (and on which nodes)The resources available to those applicationsThe policies around how those applications behave, such as restart policies, upgrades, and fault-toleranceA Kubernetes object is a \"record of intent\"--once you create the object, the Kubernetes system\nwill constantly work to ensure that the object exists. By creating an object, you're effectively\ntelling the Kubernetes system what you want your cluster's workload to look like; this is your\ncluster's desired state.To work with Kubernetes objects\u2014whether to create, modify, or delete them\u2014you'll need to use the\nKubernetes API. When you use the kubectl command-line\ninterface, for example, the CLI makes the necessary Kubernetes API calls for you. You can also use\nthe Kubernetes API directly in your own programs using one of the\nClient Libraries.Object spec and statusAlmost every Kubernetes object includes two nested object fields that govern\nthe object's configuration: the object spec and the object status.\nFor objects that have a spec, you have to set this when you create the object,\nproviding a description of the characteristics you want the resource to have:\nits desired state.The status describes the current state of the object, supplied and updated\nby the Kubernetes system and its components. The Kubernetes\ncontrol plane continually\nand actively manages every object's actual state to match the desired state you\nsupplied.For example: in Kubernetes, a Deployment is an object that can represent an\napplication running on your cluster. When you create the Deployment, you\nmight set the Deployment spec to specify that you want three replicas of\nthe application to be running. The Kubernetes system reads the Deployment\nspec and starts three instances of your desired application--updating\nthe status to match your spec. If any of those instances should fail\n(a status change), the Kubernetes system responds to the difference\nbetween spec and status by making a correction--in this case, starting\na replacement instance.For more information on the object spec, status, and metadata, see the\nKubernetes API Conventions.Describing a Kubernetes objectWhen you create an object in Kubernetes, you must provide the object spec that describes its\ndesired state, as well as some basic information about the object (such as a name). When you use\nthe Kubernetes API to create the object (either directly or via kubectl), that API request must\ninclude that information as JSON in the request body.\nMost often, you provide the information to kubectl in a file known as a manifest.\nBy convention, manifests are YAML (you could also use JSON format).\nTools such as kubectl convert the information from a manifest into JSON or another supported\nserialization format when making the API request over HTTP.Here's an example manifest that shows the required fields and object spec for a Kubernetes\nDeployment:application/deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: nginx-deployment\nspec:\nselector:\nmatchLabels:\napp: nginx\nreplicas: 2 # tells deployment to run 2 pods matching the template\ntemplate:\nmetadata:\nlabels:\napp: nginx\nspec:\ncontainers:\n- name: nginx\nimage: nginx:1.14.2\nports:\n- containerPort: 80\nOne way to create a Deployment using a manifest file like the one above is to use the\nkubectl apply command\nin the kubectl command-line interface, passing the .yaml file as an argument. Here's an example:kubectl apply -f https://k8s.io/examples/application/deployment.yaml\nThe output is similar to this:deployment.apps/nginx-deployment created\nRequired fieldsIn the manifest (YAML or JSON file) for the Kubernetes object you want to create, you'll need to set values for\nthe following fields:apiVersion - Which version of the Kubernetes API you're using to create this objectkind - What kind of object you want to createmetadata - Data that helps uniquely identify the object, including a name string, UID, and optional namespacespec - What state you desire for the objectThe precise format of the object spec is different for every Kubernetes object, and contains\nnested fields specific to that object. The Kubernetes API Reference\ncan help you find the spec format for all of the objects you can create using Kubernetes.For example, see the spec field\nfor the Pod API reference.\nFor each Pod, the .spec field specifies the pod and its desired state (such as the container image name for\neach container within that pod).\nAnother example of an object specification is the\nspec field\nfor the StatefulSet API. For StatefulSet, the .spec field specifies the StatefulSet and\nits desired state.\nWithin the .spec of a StatefulSet is a template\nfor Pod objects. That template describes Pods that the StatefulSet controller will create in order to\nsatisfy the StatefulSet specification.\nDifferent kinds of objects can also have different .status; again, the API reference pages\ndetail the structure of that .status field, and its content for each different type of object.Note:See Configuration Best Practices for additional\ninformation on writing YAML configuration files.Server side field validationStarting with Kubernetes v1.25, the API server offers server side\nfield validation\nthat detects unrecognized or duplicate fields in an object. It provides all the functionality\nof kubectl --validate on the server side.The kubectl tool uses the --validate flag to set the level of field validation. It accepts the\nvalues ignore, warn, and strict while also accepting the values true (equivalent to strict)\nand false (equivalent to ignore). The default validation setting for kubectl is --validate=true.StrictStrict field validation, errors on validation failureWarnField validation is performed, but errors are exposed as warnings rather than failing the requestIgnoreNo server side field validation is performedWhen kubectl cannot connect to an API server that supports field validation it will fall back\nto using client-side validation. Kubernetes 1.27 and later versions always offer field validation;\nolder Kubernetes releases might not. If your cluster is older than v1.27, check the documentation\nfor your version of Kubernetes.What's nextIf you're new to Kubernetes, read more about the following:Pods which are the most important basic Kubernetes objects.Deployment objects.Controllers in Kubernetes.kubectl and kubectl commands.Kubernetes Object Management\nexplains how to use kubectl to manage objects.\nYou might need to install kubectl if you don't already have it available.To learn about the Kubernetes API in general, visit:Kubernetes API overviewTo learn about objects in Kubernetes in more depth, read other pages in this section:Kubernetes Object ManagementObject Names and IDsLabels and SelectorsNamespacesAnnotationsField SelectorsFinalizersOwners and DependentsRecommended LabelsFeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified August 25, 2024 at 8:24 PM PST: Reorder overview pages (42da717f16) Edit this page\nCreate child page\nCreate an issue\nPrint entire sectionUnderstanding Kubernetes objectsObject spec and statusDescribing a Kubernetes objectRequired fieldsServer side field validationWhat's next\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "kubernetes-docs"
  },
  {
    "url": "https://kubernetes.io/docs/concepts/containers/",
    "content": "Containers | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationConceptsContainersContainersTechnology for packaging an application along with its runtime dependencies.This page will discuss containers and container images, as well as their use in operations and solution development.The word container is an overloaded term. Whenever you use the word, check whether your audience uses the same definition.Each container that you run is repeatable; the standardization from having\ndependencies included means that you get the same behavior wherever you\nrun it.Containers decouple applications from the underlying host infrastructure.\nThis makes deployment easier in different cloud or OS environments.Each node in a Kubernetes\ncluster runs the containers that form the\nPods assigned to that node.\nContainers in a Pod are co-located and co-scheduled to run on the same node.Container imagesA container image is a ready-to-run\nsoftware package containing everything needed to run an application:\nthe code and any runtime it requires, application and system libraries,\nand default values for any essential settings.Containers are intended to be stateless and\nimmutable:\nyou should not change\nthe code of a container that is already running. If you have a containerized\napplication and want to make changes, the correct process is to build a new\nimage that includes the change, then recreate the container to start from the\nupdated image.Container runtimesA fundamental component that empowers Kubernetes to run containers effectively.\nIt is responsible for managing the execution and lifecycle of containers within the Kubernetes environment.Kubernetes supports container runtimes such as\ncontainerd, CRI-O,\nand any other implementation of the Kubernetes CRI (Container Runtime\nInterface).Usually, you can allow your cluster to pick the default container runtime\nfor a Pod. If you need to use more than one container runtime in your cluster,\nyou can specify the RuntimeClass\nfor a Pod to make sure that Kubernetes runs those containers using a\nparticular container runtime.You can also use RuntimeClass to run different Pods with the same container\nruntime but with different settings.Container EnvironmentContainer Lifecycle HooksContainer Runtime Interface (CRI)FeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified October 12, 2024 at 8:17 PM PST: Update _index.md (91ad67cbfa) Edit this page\nCreate child page\nCreate an issue\nPrint entire sectionContainer imagesContainer runtimes\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "kubernetes-docs"
  },
  {
    "url": "https://kubernetes.io/docs/concepts/workloads/",
    "content": "Workloads | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\nBahasa Indonesia (Indonesian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationConceptsWorkloadsWorkloadsUnderstand Pods, the smallest deployable compute object in Kubernetes, and the higher-level abstractions that help you to run them.A workload is an application running on Kubernetes.\nWhether your workload is a single component or several that work together, on Kubernetes you run\nit inside a set of pods.\nIn Kubernetes, a Pod represents a set of running\ncontainers on your cluster.Kubernetes pods have a defined lifecycle.\nFor example, once a pod is running in your cluster then a critical fault on the\nnode where that pod is running means that\nall the pods on that node fail. Kubernetes treats that level of failure as final: you\nwould need to create a new Pod to recover, even if the node later becomes healthy.However, to make life considerably easier, you don't need to manage each Pod directly.\nInstead, you can use workload resources that manage a set of pods on your behalf.\nThese resources configure controllers\nthat make sure the right number of the right kind of pod are running, to match the state\nyou specified.Kubernetes provides several built-in workload resources:Deployment and ReplicaSet\n(replacing the legacy resource\nReplicationController).\nDeployment is a good fit for managing a stateless application workload on your cluster,\nwhere any Pod in the Deployment is interchangeable and can be replaced if needed.StatefulSet lets you\nrun one or more related Pods that do track state somehow. For example, if your workload\nrecords data persistently, you can run a StatefulSet that matches each Pod with a\nPersistentVolume. Your code, running in the\nPods for that StatefulSet, can replicate data to other Pods in the same StatefulSet\nto improve overall resilience.DaemonSet defines Pods that provide\nfacilities that are local to nodes.\nEvery time you add a node to your cluster that matches the specification in a DaemonSet,\nthe control plane schedules a Pod for that DaemonSet onto the new node.\nEach pod in a DaemonSet performs a job similar to a system daemon on a classic Unix / POSIX\nserver. A DaemonSet might be fundamental to the operation of your cluster, such as\na plugin to run cluster networking,\nit might help you to manage the node,\nor it could provide optional behavior that enhances the container platform you are running.Job and\nCronJob provide different ways to\ndefine tasks that run to completion and then stop.\nYou can use a Job to\ndefine a task that runs to completion, just once. You can use a\nCronJob to run\nthe same Job multiple times according a schedule.In the wider Kubernetes ecosystem, you can find third-party workload resources that provide\nadditional behaviors. Using a\ncustom resource definition,\nyou can add in a third-party workload resource if you want a specific behavior that's not part\nof Kubernetes' core. For example, if you wanted to run a group of Pods for your application but\nstop work unless all the Pods are available (perhaps for some high-throughput distributed task),\nthen you can implement or install an extension that does provide that feature.What's nextAs well as reading about each API kind for workload management, you can read how to\ndo specific tasks:Run a stateless application using a DeploymentRun a stateful application either as a single instance\nor as a replicated setRun automated tasks with a CronJobTo learn about Kubernetes' mechanisms for separating code from configuration,\nvisit Configuration.There are two supporting concepts that provide backgrounds about how Kubernetes manages pods\nfor applications:Garbage collection tidies up objects\nfrom your cluster after their owning resource has been removed.The time-to-live after finished controller\nremoves Jobs once a defined time has passed since they completed.Once your application is running, you might want to make it available on the internet as\na Service or, for web application only,\nusing an Ingress.FeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified July 12, 2023 at 1:25 AM PST: Revise docs home page (9520b96a61) Edit this page\nCreate child page\nCreate an issue\nPrint entire sectionWhat's next\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "kubernetes-docs"
  },
  {
    "url": "https://kubernetes.io/docs/setup/#production-environment",
    "content": "Getting started | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)\nGetting started\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationGetting startedThis section lists the different ways to set up and run Kubernetes.\nWhen you install Kubernetes, choose an installation type based on: ease of maintenance, security,\ncontrol, available resources, and expertise required to operate and manage a cluster.You can download Kubernetes to deploy a Kubernetes cluster\non a local machine, into the cloud, or for your own datacenter.Several Kubernetes components such as kube-apiserver or kube-proxy can also be\ndeployed as container images within the cluster.It is recommended to run Kubernetes components as container images wherever\nthat is possible, and to have Kubernetes manage those components.\nComponents that run containers - notably, the kubelet - can't be included in this category.If you don't want to manage a Kubernetes cluster yourself, you could pick a managed service, including\ncertified platforms.\nThere are also other standardized and custom solutions across a wide range of cloud and\nbare metal environments.Learning environmentIf you're learning Kubernetes, use the tools supported by the Kubernetes community,\nor tools in the ecosystem to set up a Kubernetes cluster on a local machine.\nSee Install tools.Production environmentWhen evaluating a solution for a\nproduction environment, consider which aspects of\noperating a Kubernetes cluster (or abstractions) you want to manage yourself and which you\nprefer to hand off to a provider.For a cluster you're managing yourself, the officially supported tool\nfor deploying Kubernetes is kubeadm.What's nextDownload KubernetesDownload and install tools including kubectlSelect a container runtime for your new clusterLearn about best practices for cluster setupKubernetes is designed for its control plane to\nrun on Linux. Within your cluster you can run applications on Linux or other operating systems, including\nWindows.Learn to set up clusters with Windows nodesFeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified November 23, 2022 at 3:06 PM PST: Added glossary tooltip to kube-apiserver and kube-prox (c430d9a72c) Edit this page\nCreate child page\nCreate an issue\nPrint entire sectionLearning environmentProduction environmentWhat's next\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "#production-environment"
  },
  {
    "url": "https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/",
    "content": "Installing kubeadm | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nBahasa Indonesia (Indonesian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPortugu\u00eas (Portuguese)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationGetting startedProduction environmentInstalling Kubernetes with deployment toolsBootstrapping clusters with kubeadmInstalling kubeadmInstalling kubeadm\nThis page shows how to install the kubeadm toolbox.\nFor information on how to create a cluster with kubeadm once you have performed this installation process,\nsee the Creating a cluster with kubeadm page.This installation guide is for Kubernetes v1.34. If you want to use a different Kubernetes version, please refer to the following pages instead:Installing kubeadm (Kubernetes v1.33)Installing kubeadm (Kubernetes v1.32)Installing kubeadm (Kubernetes v1.31)Installing kubeadm (Kubernetes v1.30)Before you beginA compatible Linux host. The Kubernetes project provides generic instructions for Linux distributions\nbased on Debian and Red Hat, and those distributions without a package manager.2 GB or more of RAM per machine (any less will leave little room for your apps).2 CPUs or more for control plane machines.Full network connectivity between all machines in the cluster (public or private network is fine).Unique hostname, MAC address, and product_uuid for every node. See here for more details.Certain ports are open on your machines. See here for more details.Note:The kubeadm installation is done via binaries that use dynamic linking and assumes that your target system provides glibc.\nThis is a reasonable assumption on many Linux distributions (including Debian, Ubuntu, Fedora, CentOS, etc.)\nbut it is not always the case with custom and lightweight distributions which don't include glibc by default, such as Alpine Linux.\nThe expectation is that the distribution either includes glibc or a\ncompatibility layer\nthat provides the expected symbols.Check your OS versionNote:\u2008This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the content guide before submitting a change. More information.LinuxWindowsThe kubeadm project supports LTS kernels. See List of LTS kernels.You can get the kernel version using the command uname -rFor more information, see Linux Kernel Requirements.The kubeadm project supports recent kernel versions. For a list of recent kernels, see Windows Server Release Information.You can get the kernel version (also called the OS version) using the command systeminfoFor more information, see Windows OS version compatibility.A Kubernetes cluster created by kubeadm depends on software that use kernel features.\nThis software includes, but is not limited to the\ncontainer runtime,\nthe kubelet, and a Container Network Interface plugin.To help you avoid unexpected errors as a result of an unsupported kernel version, kubeadm runs the SystemVerification\npre-flight check. This check fails if the kernel version is not supported.You may choose to skip the check, if you know that your kernel\nprovides the required features, even though kubeadm does not support its version.Verify the MAC address and product_uuid are unique for every nodeYou can get the MAC address of the network interfaces using the command ip link or ifconfig -aThe product_uuid can be checked by using the command sudo cat /sys/class/dmi/id/product_uuidIt is very likely that hardware devices will have unique addresses, although some virtual machines may have\nidentical values. Kubernetes uses these values to uniquely identify the nodes in the cluster.\nIf these values are not unique to each node, the installation process\nmay fail.Check network adaptersIf you have more than one network adapter, and your Kubernetes components are not reachable on the default\nroute, we recommend you add IP route(s) so Kubernetes cluster addresses go via the appropriate adapter.Check required portsThese required ports\nneed to be open in order for Kubernetes components to communicate with each other.\nYou can use tools like netcat to check if a port is open. For example:nc 127.0.0.1 6443 -zv -w 2\nThe pod network plugin you use may also require certain ports to be\nopen. Since this differs with each pod network plugin, please see the\ndocumentation for the plugins about what port(s) those need.Swap configurationThe default behavior of a kubelet is to fail to start if swap memory is detected on a node.\nThis means that swap should either be disabled or tolerated by kubelet.To tolerate swap, add failSwapOn: false to kubelet configuration or as a command line argument.\nNote: even if failSwapOn: false is provided, workloads wouldn't have swap access by default.\nThis can be changed by setting a swapBehavior, again in the kubelet configuration file. To use swap,\nset a swapBehavior other than the default NoSwap setting.\nSee Swap memory management for more details.To disable swap, sudo swapoff -a can be used to disable swapping temporarily.\nTo make this change persistent across reboots, make sure swap is disabled in\nconfig files like /etc/fstab, systemd.swap, depending how it was configured on your system.Installing a container runtimeTo run containers in Pods, Kubernetes uses a\ncontainer runtime.By default, Kubernetes uses the\nContainer Runtime Interface (CRI)\nto interface with your chosen container runtime.If you don't specify a runtime, kubeadm automatically tries to detect an installed\ncontainer runtime by scanning through a list of known endpoints.If multiple or no container runtimes are detected kubeadm will throw an error\nand will request that you specify which one you want to use.See container runtimes\nfor more information.Note:Docker Engine does not implement the CRI\nwhich is a requirement for a container runtime to work with Kubernetes.\nFor that reason, an additional service cri-dockerd\nhas to be installed. cri-dockerd is a project based on the legacy built-in\nDocker Engine support that was removed from the kubelet in version 1.24.The tables below include the known endpoints for supported operating systems:LinuxWindowsLinux container runtimesRuntimePath to Unix domain socketcontainerdunix:///var/run/containerd/containerd.sockCRI-Ounix:///var/run/crio/crio.sockDocker Engine (using cri-dockerd)unix:///var/run/cri-dockerd.sockWindows container runtimesRuntimePath to Windows named pipecontainerdnpipe:////./pipe/containerd-containerdDocker Engine (using cri-dockerd)npipe:////./pipe/cri-dockerdInstalling kubeadm, kubelet and kubectlYou will install these packages on all of your machines:kubeadm: the command to bootstrap the cluster.kubelet: the component that runs on all of the machines in your cluster\nand does things like starting pods and containers.kubectl: the command line util to talk to your cluster.kubeadm will not install or manage kubelet or kubectl for you, so you will\nneed to ensure they match the version of the Kubernetes control plane you want\nkubeadm to install for you. If you do not, there is a risk of a version skew occurring that\ncan lead to unexpected, buggy behaviour. However, one minor version skew between the\nkubelet and the control plane is supported, but the kubelet version may never exceed the API\nserver version. For example, the kubelet running 1.7.0 should be fully compatible with a 1.8.0 API server,\nbut not vice versa.For information about installing kubectl, see Install and set up kubectl.Warning:These instructions exclude all Kubernetes packages from any system upgrades.\nThis is because kubeadm and Kubernetes require\nspecial attention to upgrade.For more information on version skews, see:Kubernetes version and version-skew policyKubeadm-specific version skew policyNote: The legacy package repositories (apt.kubernetes.io and yum.kubernetes.io) have been\ndeprecated and frozen starting from September 13, 2023.\nUsing the new package repositories hosted at pkgs.k8s.io\nis strongly recommended and required in order to install Kubernetes versions released after September 13, 2023.\nThe deprecated legacy repositories, and their contents, might be removed at any time in the future and without\na further notice period. The new package repositories provide downloads for Kubernetes versions starting with v1.24.0.Note:There's a dedicated package repository for each Kubernetes minor version. If you want to install\na minor version other than v1.34, please see the installation guide for\nyour desired minor version.Debian-based distributionsRed Hat-based distributionsWithout a package managerThese instructions are for Kubernetes v1.34.Update the apt package index and install packages needed to use the Kubernetes apt repository:sudo apt-get update\n# apt-transport-https may be a dummy package; if so, you can skip that package\nsudo apt-get install -y apt-transport-https ca-certificates curl gpg\nDownload the public signing key for the Kubernetes package repositories.\nThe same signing key is used for all repositories so you can disregard the version in the URL:# If the directory `/etc/apt/keyrings` does not exist, it should be created before the curl command, read the note below.\n# sudo mkdir -p -m 755 /etc/apt/keyrings\ncurl -fsSL https://pkgs.k8s.io/core:/stable:/v1.34/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg\nNote:In releases older than Debian 12 and Ubuntu 22.04, directory /etc/apt/keyrings does not\nexist by default, and it should be created before the curl command.Add the appropriate Kubernetes apt repository. Please note that this repository have packages\nonly for Kubernetes 1.34; for other Kubernetes minor versions, you need to\nchange the Kubernetes minor version in the URL to match your desired minor version\n(you should also check that you are reading the documentation for the version of Kubernetes\nthat you plan to install).# This overwrites any existing configuration in /etc/apt/sources.list.d/kubernetes.list\necho 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.34/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list\nUpdate the apt package index, install kubelet, kubeadm and kubectl, and pin their version:sudo apt-get update\nsudo apt-get install -y kubelet kubeadm kubectl\nsudo apt-mark hold kubelet kubeadm kubectl\n(Optional) Enable the kubelet service before running kubeadm:sudo systemctl enable --now kubelet\nSet SELinux to permissive mode:These instructions are for Kubernetes 1.34.# Set SELinux in permissive mode (effectively disabling it)\nsudo setenforce 0\nsudo sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config\nCaution:Setting SELinux in permissive mode by running setenforce 0 and sed ...\neffectively disables it. This is required to allow containers to access the host\nfilesystem; for example, some cluster network plugins require that. You have to\ndo this until SELinux support is improved in the kubelet.You can leave SELinux enabled if you know how to configure it but it may require\nsettings that are not supported by kubeadm.Add the Kubernetes yum repository. The exclude parameter in the\nrepository definition ensures that the packages related to Kubernetes are\nnot upgraded upon running yum update as there's a special procedure that\nmust be followed for upgrading Kubernetes. Please note that this repository\nhave packages only for Kubernetes 1.34; for other\nKubernetes minor versions, you need to change the Kubernetes minor version\nin the URL to match your desired minor version (you should also check that\nyou are reading the documentation for the version of Kubernetes that you\nplan to install).# This overwrites any existing configuration in /etc/yum.repos.d/kubernetes.repo\ncat <<EOF | sudo tee /etc/yum.repos.d/kubernetes.repo\n[kubernetes]\nname=Kubernetes\nbaseurl=https://pkgs.k8s.io/core:/stable:/v1.34/rpm/\nenabled=1\ngpgcheck=1\ngpgkey=https://pkgs.k8s.io/core:/stable:/v1.34/rpm/repodata/repomd.xml.key\nexclude=kubelet kubeadm kubectl cri-tools kubernetes-cni\nEOF\nInstall kubelet, kubeadm and kubectl:For systems with DNF:sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes\nFor systems with DNF5:sudo yum install -y kubelet kubeadm kubectl --setopt=disable_excludes=kubernetes\n(Optional) Enable the kubelet service before running kubeadm:sudo systemctl enable --now kubelet\nInstall CNI plugins (required for most pod network):CNI_PLUGINS_VERSION=\"v1.3.0\"\nARCH=\"amd64\"\nDEST=\"/opt/cni/bin\"\nsudo mkdir -p \"$DEST\"\ncurl -L \"https://github.com/containernetworking/plugins/releases/download/${CNI_PLUGINS_VERSION}/cni-plugins-linux-${ARCH}-${CNI_PLUGINS_VERSION}.tgz\" | sudo tar -C \"$DEST\" -xz\nDefine the directory to download command files:Note:The DOWNLOAD_DIR variable must be set to a writable directory.\nIf you are running Flatcar Container Linux, set DOWNLOAD_DIR=\"/opt/bin\".DOWNLOAD_DIR=\"/usr/local/bin\"\nsudo mkdir -p \"$DOWNLOAD_DIR\"\nOptionally install crictl (required for interaction with the Container Runtime Interface (CRI), optional for kubeadm):CRICTL_VERSION=\"v1.31.0\"\nARCH=\"amd64\"\ncurl -L \"https://github.com/kubernetes-sigs/cri-tools/releases/download/${CRICTL_VERSION}/crictl-${CRICTL_VERSION}-linux-${ARCH}.tar.gz\" | sudo tar -C $DOWNLOAD_DIR -xz\nInstall kubeadm, kubelet and add a kubelet systemd service:RELEASE=\"$(curl -sSL https://dl.k8s.io/release/stable.txt)\"\nARCH=\"amd64\"\ncd $DOWNLOAD_DIR\nsudo curl -L --remote-name-all https://dl.k8s.io/release/${RELEASE}/bin/linux/${ARCH}/{kubeadm,kubelet}\nsudo chmod +x {kubeadm,kubelet}\nRELEASE_VERSION=\"v0.16.2\"\ncurl -sSL \"https://raw.githubusercontent.com/kubernetes/release/${RELEASE_VERSION}/cmd/krel/templates/latest/kubelet/kubelet.service\" | sed \"s:/usr/bin:${DOWNLOAD_DIR}:g\" | sudo tee /usr/lib/systemd/system/kubelet.service\nsudo mkdir -p /usr/lib/systemd/system/kubelet.service.d\ncurl -sSL \"https://raw.githubusercontent.com/kubernetes/release/${RELEASE_VERSION}/cmd/krel/templates/latest/kubeadm/10-kubeadm.conf\" | sed \"s:/usr/bin:${DOWNLOAD_DIR}:g\" | sudo tee /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf\nNote:Please refer to the note in the Before you begin section for Linux distributions\nthat do not include glibc by default.Install kubectl by following the instructions on Install Tools page.Optionally, enable the kubelet service before running kubeadm:sudo systemctl enable --now kubelet\nNote:The Flatcar Container Linux distribution mounts the /usr directory as a read-only filesystem.\nBefore bootstrapping your cluster, you need to take additional steps to configure a writable directory.\nSee the Kubeadm Troubleshooting guide\nto learn how to set up a writable directory.The kubelet is now restarting every few seconds, as it waits in a crashloop for\nkubeadm to tell it what to do.Configuring a cgroup driverBoth the container runtime and the kubelet have a property called\n\"cgroup driver\", which is important\nfor the management of cgroups on Linux machines.Warning:Matching the container runtime and kubelet cgroup drivers is required or otherwise the kubelet process will fail.See Configuring a cgroup driver for more details.TroubleshootingIf you are running into difficulties with kubeadm, please consult our\ntroubleshooting docs.What's nextUsing kubeadm to Create a ClusterItems on this page refer to third party products or projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for those third-party products or projects. See the CNCF website guidelines for more details.You should read the content guide before proposing a change that adds an extra third-party link.FeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified September 17, 2025 at 4:34 PM PST: Fix indentation of kubelet, kubeadm, kubectl install commands (6086553949) Edit this page Third party content advice\nCreate child page\nCreate an issue\nPrint entire sectionBefore you beginCheck your OS versionVerify the MAC address and product_uuid are unique for every nodeCheck network adaptersCheck required portsSwap configurationInstalling a container runtimeInstalling kubeadm, kubelet and kubectlConfiguring a cgroup driverTroubleshootingWhat's next\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "kubernetes-docs"
  },
  {
    "url": "https://kubernetes.io/docs/concepts/cluster-administration/observability/#metrics",
    "content": "Observability | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u4e2d\u6587 (Chinese)\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationConceptsCluster AdministrationObservabilityObservabilityUnderstand how to gain end-to-end visibility of a Kubernetes cluster through the collection of metrics, logs, and traces.In Kubernetes, observability is the process of collecting and analyzing metrics, logs, and traces\u2014often referred to as the three pillars of observability\u2014in order to obtain a better understanding of the internal state, performance, and health of the cluster.Kubernetes control plane components, as well as many add-ons, generate and emit these signals. By aggregating and correlating them, you can gain a unified picture of the control plane, add-ons, and applications across the cluster.Figure 1 outlines how cluster components emit the three primary signal types.flowchart LR\nA[Cluster components] --> M[Metrics pipeline]\nA --> L[Log pipeline]\nA --> T[Trace pipeline]\nM --> S[(Storage and analysis)]\nL --> S\nT --> S\nS --> O[Operators and automation]JavaScript must be enabled to view this contentFigure 1. High-level signals emitted by cluster components and their consumers.MetricsKubernetes components emit metrics in Prometheus format from their /metrics endpoints, including:kube-controller-managerkube-proxykube-apiserverkube-schedulerkubeletThe kubelet also exposes metrics at /metrics/cadvisor, /metrics/resource, and /metrics/probes, and add-ons such as kube-state-metrics enrich those control plane signals with Kubernetes object status.A typical Kubernetes metrics pipeline periodically scrapes these endpoints and stores the samples in a time series database (for example with Prometheus).See the system metrics guide for details and configuration options.Figure 2 outlines a common Kubernetes metrics pipeline.flowchart LR\nC[Cluster components] --> P[Prometheus scraper]\nP --> TS[(Time series storage)]\nTS --> D[Dashboards and alerts]\nTS --> A[Automated actions]JavaScript must be enabled to view this contentFigure 2. Components of a typical Kubernetes metrics pipeline.For multi-cluster or multi-cloud visibility, distributed time series databases (for example Thanos or Cortex) can complement Prometheus.See Common observability tools - metrics tools for metrics scrapers and time series databases.See AlsoSystem metrics for Kubernetes componentsResource usage monitoring with metrics-serverkube-state-metrics conceptResource metrics pipeline overviewLogsLogs provide a chronological record of events inside applications, Kubernetes system components, and security-related activities such as audit logging.Container runtimes capture a containerized application\u2019s output from standard output (stdout) and standard error (stderr) streams. While runtimes implement this differently, the integration with the kubelet is standardized through the CRI logging format, and the kubelet makes these logs available through kubectl logs.Figure 3a. Node-level logging architecture.System component logs capture events from the cluster and are often useful for debugging and troubleshooting. These components are classified in two different ways: those that run in a container and those that do not. For example, the kube-scheduler and kube-proxy usually run in containers, whereas the kubelet and the container runtime run directly on the host.On machines with systemd, the kubelet and container runtime write to journald. Otherwise, they write to .log files in the /var/log directory.System components that run inside containers always write to .log files in /var/log, bypassing the default container logging mechanism.System component and container logs stored under /var/log require log rotation to prevent uncontrolled growth. Some cluster provisioning scripts install log rotation by default; verify your environment and adjust as needed. See the system logs reference for details on locations, formats, and configuration options.Most clusters run a node-level logging agent (for example, Fluent Bit or Fluentd) that tails these files and forwards entries to a central log store. The logging architecture guidance explains how to design such pipelines, apply retention, and log flows to backends.Figure 3 outlines a common log aggregation pipeline.flowchart LR\nsubgraph Sources\nA[Application stdout / stderr]\nB[Control plane logs]\nC[Audit records]\nend\nA --> N[Node log agent]\nB --> N\nC --> N\nN --> L[Central log store]\nL --> Q[Dashboards, alerting, SIEM]JavaScript must be enabled to view this contentFigure 3. Components of a typical Kubernetes logs pipeline.See Common observability tools - logging tools for logging agents and central log stores.See AlsoLogging architectureSystem logsLogging tasks and tutorialsConfigure audit loggingTracesTraces capture how requests moves across Kubernetes components and applications, linking latency, timing and relationships between operations.By collecting traces, you can visualize end-to-end request flow, diagnose performance issues, and identify bottlenecks or unexpected interactions in the control plane, add-ons, or applications.Kubernetes 1.34 can export spans over the OpenTelemetry Protocol (OTLP), either directly via built-in gRPC exporters or by forwarding them through an OpenTelemetry Collector.The OpenTelemetry Collector receives spans from components and applications, processes them (for example by applying sampling or redaction), and forwards them to a tracing backend for storage and analysis.Figure 4 outlines a typical distributed tracing pipeline.flowchart LR\nsubgraph Sources\nA[Control plane spans]\nB[Application spans]\nend\nA --> X[OTLP exporter]\nB --> X\nX --> COL[OpenTelemetry Collector]\nCOL --> TS[(Tracing backend)]\nTS --> V[Visualization and analysis]JavaScript must be enabled to view this contentFigure 4. Components of a typical Kubernetes traces pipeline.See Common observability tools - tracing tools for tracing collectors and backends.See AlsoSystem traces for Kubernetes componentsOpenTelemetry Collector getting started guideMonitoring and tracing tasksCommon observability toolsNote:\u2008This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the content guide before submitting a change. More information.Note: This section links to third-party projects that provide observability capabilities required by Kubernetes.\nThe Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a\nproject to this list, read the content guide before submitting a change.Metrics toolsCortex offers horizontally scalable, long-term Prometheus storage.Grafana Mimir is a Grafana Labs project that provides multi-tenant, horizontally scalable Prometheus-compatible storage.Prometheus is the monitoring system that scrapes and stores metrics from Kubernetes components.Thanos extends Prometheus with global querying, downsampling, and object storage support.Logging toolsElasticsearch delivers distributed log indexing and search.Fluent Bit collects and forwards container and node logs with a low resource footprint.Fluentd routes and transforms logs to multiple destinations.Grafana Loki stores logs in a Prometheus-inspired, label-based format.OpenSearch provides open source log indexing and search compatible with Elasticsearch APIs.Tracing toolsGrafana Tempo offers scalable, low-cost distributed tracing storage.Jaeger captures and visualizes distributed traces for microservices.OpenTelemetry Collector receives, processes, and exports telemetry data including traces.Zipkin provides distributed tracing collection and visualization.What's nextLearn how to collect resource usage metrics with metrics-serverExplore logging tasks and tutorialsFollow the monitoring and tracing task guidesReview the system metrics guide for component endpoints and stabilityReview the common observability tools section for vetted third-party optionsItems on this page refer to third party products or projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for those third-party products or projects. See the CNCF website guidelines for more details.You should read the content guide before proposing a change that adds an extra third-party link.FeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified September 23, 2025 at 1:49 AM PST: docs: add observability overview page (d3ceb4dfd5) Edit this page Third party content advice\nCreate child page\nCreate an issue\nPrint entire sectionMetricsLogsTracesCommon observability toolsMetrics toolsLogging toolsTracing toolsWhat's next\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "#metrics"
  },
  {
    "url": "https://kubernetes.io/docs/concepts/cluster-administration/observability/#logs",
    "content": "Observability | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u4e2d\u6587 (Chinese)\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationConceptsCluster AdministrationObservabilityObservabilityUnderstand how to gain end-to-end visibility of a Kubernetes cluster through the collection of metrics, logs, and traces.In Kubernetes, observability is the process of collecting and analyzing metrics, logs, and traces\u2014often referred to as the three pillars of observability\u2014in order to obtain a better understanding of the internal state, performance, and health of the cluster.Kubernetes control plane components, as well as many add-ons, generate and emit these signals. By aggregating and correlating them, you can gain a unified picture of the control plane, add-ons, and applications across the cluster.Figure 1 outlines how cluster components emit the three primary signal types.flowchart LR\nA[Cluster components] --> M[Metrics pipeline]\nA --> L[Log pipeline]\nA --> T[Trace pipeline]\nM --> S[(Storage and analysis)]\nL --> S\nT --> S\nS --> O[Operators and automation]JavaScript must be enabled to view this contentFigure 1. High-level signals emitted by cluster components and their consumers.MetricsKubernetes components emit metrics in Prometheus format from their /metrics endpoints, including:kube-controller-managerkube-proxykube-apiserverkube-schedulerkubeletThe kubelet also exposes metrics at /metrics/cadvisor, /metrics/resource, and /metrics/probes, and add-ons such as kube-state-metrics enrich those control plane signals with Kubernetes object status.A typical Kubernetes metrics pipeline periodically scrapes these endpoints and stores the samples in a time series database (for example with Prometheus).See the system metrics guide for details and configuration options.Figure 2 outlines a common Kubernetes metrics pipeline.flowchart LR\nC[Cluster components] --> P[Prometheus scraper]\nP --> TS[(Time series storage)]\nTS --> D[Dashboards and alerts]\nTS --> A[Automated actions]JavaScript must be enabled to view this contentFigure 2. Components of a typical Kubernetes metrics pipeline.For multi-cluster or multi-cloud visibility, distributed time series databases (for example Thanos or Cortex) can complement Prometheus.See Common observability tools - metrics tools for metrics scrapers and time series databases.See AlsoSystem metrics for Kubernetes componentsResource usage monitoring with metrics-serverkube-state-metrics conceptResource metrics pipeline overviewLogsLogs provide a chronological record of events inside applications, Kubernetes system components, and security-related activities such as audit logging.Container runtimes capture a containerized application\u2019s output from standard output (stdout) and standard error (stderr) streams. While runtimes implement this differently, the integration with the kubelet is standardized through the CRI logging format, and the kubelet makes these logs available through kubectl logs.Figure 3a. Node-level logging architecture.System component logs capture events from the cluster and are often useful for debugging and troubleshooting. These components are classified in two different ways: those that run in a container and those that do not. For example, the kube-scheduler and kube-proxy usually run in containers, whereas the kubelet and the container runtime run directly on the host.On machines with systemd, the kubelet and container runtime write to journald. Otherwise, they write to .log files in the /var/log directory.System components that run inside containers always write to .log files in /var/log, bypassing the default container logging mechanism.System component and container logs stored under /var/log require log rotation to prevent uncontrolled growth. Some cluster provisioning scripts install log rotation by default; verify your environment and adjust as needed. See the system logs reference for details on locations, formats, and configuration options.Most clusters run a node-level logging agent (for example, Fluent Bit or Fluentd) that tails these files and forwards entries to a central log store. The logging architecture guidance explains how to design such pipelines, apply retention, and log flows to backends.Figure 3 outlines a common log aggregation pipeline.flowchart LR\nsubgraph Sources\nA[Application stdout / stderr]\nB[Control plane logs]\nC[Audit records]\nend\nA --> N[Node log agent]\nB --> N\nC --> N\nN --> L[Central log store]\nL --> Q[Dashboards, alerting, SIEM]JavaScript must be enabled to view this contentFigure 3. Components of a typical Kubernetes logs pipeline.See Common observability tools - logging tools for logging agents and central log stores.See AlsoLogging architectureSystem logsLogging tasks and tutorialsConfigure audit loggingTracesTraces capture how requests moves across Kubernetes components and applications, linking latency, timing and relationships between operations.By collecting traces, you can visualize end-to-end request flow, diagnose performance issues, and identify bottlenecks or unexpected interactions in the control plane, add-ons, or applications.Kubernetes 1.34 can export spans over the OpenTelemetry Protocol (OTLP), either directly via built-in gRPC exporters or by forwarding them through an OpenTelemetry Collector.The OpenTelemetry Collector receives spans from components and applications, processes them (for example by applying sampling or redaction), and forwards them to a tracing backend for storage and analysis.Figure 4 outlines a typical distributed tracing pipeline.flowchart LR\nsubgraph Sources\nA[Control plane spans]\nB[Application spans]\nend\nA --> X[OTLP exporter]\nB --> X\nX --> COL[OpenTelemetry Collector]\nCOL --> TS[(Tracing backend)]\nTS --> V[Visualization and analysis]JavaScript must be enabled to view this contentFigure 4. Components of a typical Kubernetes traces pipeline.See Common observability tools - tracing tools for tracing collectors and backends.See AlsoSystem traces for Kubernetes componentsOpenTelemetry Collector getting started guideMonitoring and tracing tasksCommon observability toolsNote:\u2008This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the content guide before submitting a change. More information.Note: This section links to third-party projects that provide observability capabilities required by Kubernetes.\nThe Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a\nproject to this list, read the content guide before submitting a change.Metrics toolsCortex offers horizontally scalable, long-term Prometheus storage.Grafana Mimir is a Grafana Labs project that provides multi-tenant, horizontally scalable Prometheus-compatible storage.Prometheus is the monitoring system that scrapes and stores metrics from Kubernetes components.Thanos extends Prometheus with global querying, downsampling, and object storage support.Logging toolsElasticsearch delivers distributed log indexing and search.Fluent Bit collects and forwards container and node logs with a low resource footprint.Fluentd routes and transforms logs to multiple destinations.Grafana Loki stores logs in a Prometheus-inspired, label-based format.OpenSearch provides open source log indexing and search compatible with Elasticsearch APIs.Tracing toolsGrafana Tempo offers scalable, low-cost distributed tracing storage.Jaeger captures and visualizes distributed traces for microservices.OpenTelemetry Collector receives, processes, and exports telemetry data including traces.Zipkin provides distributed tracing collection and visualization.What's nextLearn how to collect resource usage metrics with metrics-serverExplore logging tasks and tutorialsFollow the monitoring and tracing task guidesReview the system metrics guide for component endpoints and stabilityReview the common observability tools section for vetted third-party optionsItems on this page refer to third party products or projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for those third-party products or projects. See the CNCF website guidelines for more details.You should read the content guide before proposing a change that adds an extra third-party link.FeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified September 23, 2025 at 1:49 AM PST: docs: add observability overview page (d3ceb4dfd5) Edit this page Third party content advice\nCreate child page\nCreate an issue\nPrint entire sectionMetricsLogsTracesCommon observability toolsMetrics toolsLogging toolsTracing toolsWhat's next\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "#logs"
  },
  {
    "url": "https://kubernetes.io/docs/concepts/cluster-administration/observability/#traces",
    "content": "Observability | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u4e2d\u6587 (Chinese)\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationConceptsCluster AdministrationObservabilityObservabilityUnderstand how to gain end-to-end visibility of a Kubernetes cluster through the collection of metrics, logs, and traces.In Kubernetes, observability is the process of collecting and analyzing metrics, logs, and traces\u2014often referred to as the three pillars of observability\u2014in order to obtain a better understanding of the internal state, performance, and health of the cluster.Kubernetes control plane components, as well as many add-ons, generate and emit these signals. By aggregating and correlating them, you can gain a unified picture of the control plane, add-ons, and applications across the cluster.Figure 1 outlines how cluster components emit the three primary signal types.flowchart LR\nA[Cluster components] --> M[Metrics pipeline]\nA --> L[Log pipeline]\nA --> T[Trace pipeline]\nM --> S[(Storage and analysis)]\nL --> S\nT --> S\nS --> O[Operators and automation]JavaScript must be enabled to view this contentFigure 1. High-level signals emitted by cluster components and their consumers.MetricsKubernetes components emit metrics in Prometheus format from their /metrics endpoints, including:kube-controller-managerkube-proxykube-apiserverkube-schedulerkubeletThe kubelet also exposes metrics at /metrics/cadvisor, /metrics/resource, and /metrics/probes, and add-ons such as kube-state-metrics enrich those control plane signals with Kubernetes object status.A typical Kubernetes metrics pipeline periodically scrapes these endpoints and stores the samples in a time series database (for example with Prometheus).See the system metrics guide for details and configuration options.Figure 2 outlines a common Kubernetes metrics pipeline.flowchart LR\nC[Cluster components] --> P[Prometheus scraper]\nP --> TS[(Time series storage)]\nTS --> D[Dashboards and alerts]\nTS --> A[Automated actions]JavaScript must be enabled to view this contentFigure 2. Components of a typical Kubernetes metrics pipeline.For multi-cluster or multi-cloud visibility, distributed time series databases (for example Thanos or Cortex) can complement Prometheus.See Common observability tools - metrics tools for metrics scrapers and time series databases.See AlsoSystem metrics for Kubernetes componentsResource usage monitoring with metrics-serverkube-state-metrics conceptResource metrics pipeline overviewLogsLogs provide a chronological record of events inside applications, Kubernetes system components, and security-related activities such as audit logging.Container runtimes capture a containerized application\u2019s output from standard output (stdout) and standard error (stderr) streams. While runtimes implement this differently, the integration with the kubelet is standardized through the CRI logging format, and the kubelet makes these logs available through kubectl logs.Figure 3a. Node-level logging architecture.System component logs capture events from the cluster and are often useful for debugging and troubleshooting. These components are classified in two different ways: those that run in a container and those that do not. For example, the kube-scheduler and kube-proxy usually run in containers, whereas the kubelet and the container runtime run directly on the host.On machines with systemd, the kubelet and container runtime write to journald. Otherwise, they write to .log files in the /var/log directory.System components that run inside containers always write to .log files in /var/log, bypassing the default container logging mechanism.System component and container logs stored under /var/log require log rotation to prevent uncontrolled growth. Some cluster provisioning scripts install log rotation by default; verify your environment and adjust as needed. See the system logs reference for details on locations, formats, and configuration options.Most clusters run a node-level logging agent (for example, Fluent Bit or Fluentd) that tails these files and forwards entries to a central log store. The logging architecture guidance explains how to design such pipelines, apply retention, and log flows to backends.Figure 3 outlines a common log aggregation pipeline.flowchart LR\nsubgraph Sources\nA[Application stdout / stderr]\nB[Control plane logs]\nC[Audit records]\nend\nA --> N[Node log agent]\nB --> N\nC --> N\nN --> L[Central log store]\nL --> Q[Dashboards, alerting, SIEM]JavaScript must be enabled to view this contentFigure 3. Components of a typical Kubernetes logs pipeline.See Common observability tools - logging tools for logging agents and central log stores.See AlsoLogging architectureSystem logsLogging tasks and tutorialsConfigure audit loggingTracesTraces capture how requests moves across Kubernetes components and applications, linking latency, timing and relationships between operations.By collecting traces, you can visualize end-to-end request flow, diagnose performance issues, and identify bottlenecks or unexpected interactions in the control plane, add-ons, or applications.Kubernetes 1.34 can export spans over the OpenTelemetry Protocol (OTLP), either directly via built-in gRPC exporters or by forwarding them through an OpenTelemetry Collector.The OpenTelemetry Collector receives spans from components and applications, processes them (for example by applying sampling or redaction), and forwards them to a tracing backend for storage and analysis.Figure 4 outlines a typical distributed tracing pipeline.flowchart LR\nsubgraph Sources\nA[Control plane spans]\nB[Application spans]\nend\nA --> X[OTLP exporter]\nB --> X\nX --> COL[OpenTelemetry Collector]\nCOL --> TS[(Tracing backend)]\nTS --> V[Visualization and analysis]JavaScript must be enabled to view this contentFigure 4. Components of a typical Kubernetes traces pipeline.See Common observability tools - tracing tools for tracing collectors and backends.See AlsoSystem traces for Kubernetes componentsOpenTelemetry Collector getting started guideMonitoring and tracing tasksCommon observability toolsNote:\u2008This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the content guide before submitting a change. More information.Note: This section links to third-party projects that provide observability capabilities required by Kubernetes.\nThe Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a\nproject to this list, read the content guide before submitting a change.Metrics toolsCortex offers horizontally scalable, long-term Prometheus storage.Grafana Mimir is a Grafana Labs project that provides multi-tenant, horizontally scalable Prometheus-compatible storage.Prometheus is the monitoring system that scrapes and stores metrics from Kubernetes components.Thanos extends Prometheus with global querying, downsampling, and object storage support.Logging toolsElasticsearch delivers distributed log indexing and search.Fluent Bit collects and forwards container and node logs with a low resource footprint.Fluentd routes and transforms logs to multiple destinations.Grafana Loki stores logs in a Prometheus-inspired, label-based format.OpenSearch provides open source log indexing and search compatible with Elasticsearch APIs.Tracing toolsGrafana Tempo offers scalable, low-cost distributed tracing storage.Jaeger captures and visualizes distributed traces for microservices.OpenTelemetry Collector receives, processes, and exports telemetry data including traces.Zipkin provides distributed tracing collection and visualization.What's nextLearn how to collect resource usage metrics with metrics-serverExplore logging tasks and tutorialsFollow the monitoring and tracing task guidesReview the system metrics guide for component endpoints and stabilityReview the common observability tools section for vetted third-party optionsItems on this page refer to third party products or projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for those third-party products or projects. See the CNCF website guidelines for more details.You should read the content guide before proposing a change that adds an extra third-party link.FeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified September 23, 2025 at 1:49 AM PST: docs: add observability overview page (d3ceb4dfd5) Edit this page Third party content advice\nCreate child page\nCreate an issue\nPrint entire sectionMetricsLogsTracesCommon observability toolsMetrics toolsLogging toolsTracing toolsWhat's next\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "#traces"
  },
  {
    "url": "https://kubernetes.io/docs/concepts/cluster-administration/#securing-a-cluster",
    "content": "Cluster Administration | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationConceptsCluster AdministrationCluster AdministrationLower-level detail relevant to creating or administering a Kubernetes cluster.The cluster administration overview is for anyone creating or administering a Kubernetes cluster.\nIt assumes some familiarity with core Kubernetes concepts.Planning a clusterSee the guides in Setup for examples of how to plan, set up, and configure\nKubernetes clusters. The solutions listed in this article are called distros.Note:Not all distros are actively maintained. Choose distros which have been tested with a recent\nversion of Kubernetes.Before choosing a guide, here are some considerations:Do you want to try out Kubernetes on your computer, or do you want to build a high-availability,\nmulti-node cluster? Choose distros best suited for your needs.Will you be using a hosted Kubernetes cluster, such as\nGoogle Kubernetes Engine, or hosting your own cluster?Will your cluster be on-premises, or in the cloud (IaaS)? Kubernetes does not directly\nsupport hybrid clusters. Instead, you can set up multiple clusters.If you are configuring Kubernetes on-premises, consider which\nnetworking model fits best.Will you be running Kubernetes on \"bare metal\" hardware or on virtual machines (VMs)?Do you want to run a cluster, or do you expect to do active development of Kubernetes project code?\nIf the latter, choose an actively-developed distro. Some distros only use binary releases, but\noffer a greater variety of choices.Familiarize yourself with the components needed to run a cluster.Managing a clusterLearn how to manage nodes.Read about Node autoscaling.Learn how to set up and manage the resource quota for shared clusters.Securing a clusterGenerate Certificates describes the steps to\ngenerate certificates using different tool chains.Kubernetes Container Environment describes\nthe environment for Kubelet managed containers on a Kubernetes node.Controlling Access to the Kubernetes API describes\nhow Kubernetes implements access control for its own API.Authenticating explains authentication in\nKubernetes, including the various authentication options.Authorization is separate from\nauthentication, and controls how HTTP calls are handled.Using Admission Controllers\nexplains plug-ins which intercepts requests to the Kubernetes API server after authentication\nand authorization.Admission Webhook Good Practices\nprovides good practices and considerations when designing mutating admission\nwebhooks and validating admission webhooks.Using Sysctls in a Kubernetes Cluster\ndescribes to an administrator how to use the sysctl command-line tool to set kernel parameters\n.Auditing describes how to interact with Kubernetes'\naudit logs.Securing the kubeletControl Plane-Node communicationTLS bootstrappingKubelet authentication/authorizationOptional Cluster ServicesDNS Integration describes how to resolve\na DNS name directly to a Kubernetes service.Logging and Monitoring Cluster Activity\nexplains how logging in Kubernetes works and how to implement it.FeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified February 03, 2025 at 5:28 PM PST: Add a new page for mutating webhook good practices. (bf971d28d3) Edit this page\nCreate child page\nCreate an issue\nPrint entire sectionPlanning a clusterManaging a clusterSecuring a clusterSecuring the kubeletOptional Cluster Services\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "#securing-a-cluster"
  },
  {
    "url": "https://kubernetes.io/docs/reference/setup-tools/kubeadm/",
    "content": "Kubeadm | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nBahasa Indonesia (Indonesian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPortugu\u00eas (Portuguese)\nEspa\u00f1ol (Spanish)\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationReferenceSetup toolsKubeadmKubeadmKubeadm is a tool built to provide kubeadm init and kubeadm join as best-practice \"fast paths\" for creating Kubernetes clusters.kubeadm performs the actions necessary to get a minimum viable cluster up and running. By design, it cares only about bootstrapping, not about provisioning machines. Likewise, installing various nice-to-have addons, like the Kubernetes Dashboard, monitoring solutions, and cloud-specific addons, is not in scope.Instead, we expect higher-level and more tailored tooling to be built on top of kubeadm, and ideally, using kubeadm as the basis of all deployments will make it easier to create conformant clusters.How to installTo install kubeadm, see the installation guide.What's nextkubeadm init to bootstrap a Kubernetes control-plane nodekubeadm join to bootstrap a Kubernetes worker node and join it to the clusterkubeadm upgrade to upgrade a Kubernetes cluster to a newer versionkubeadm config if you initialized your cluster using kubeadm v1.7.x or lower, to configure your cluster for kubeadm upgradekubeadm token to manage tokens for kubeadm joinkubeadm reset to revert any changes made to this host by kubeadm init or kubeadm joinkubeadm certs to manage Kubernetes certificateskubeadm kubeconfig to manage kubeconfig fileskubeadm version to print the kubeadm versionkubeadm alpha to preview a set of features made available for gathering feedback from the communityFeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified July 12, 2023 at 1:25 AM PST: Revise docs home page (9520b96a61) Edit this page\nCreate child page\nCreate an issue\nPrint entire sectionHow to installWhat's next\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "kubernetes-docs"
  },
  {
    "url": "https://kubernetes.io/docs/reference/kubectl/quick-reference/",
    "content": "kubectl Quick Reference | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nPortugu\u00eas (Portuguese)\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationReferenceCommand line tool (kubectl)kubectl Quick Referencekubectl Quick ReferenceThis page contains a list of commonly used kubectl commands and flags.Note:These instructions are for Kubernetes v1.34. To check the version, use the kubectl version command.Kubectl autocompleteBASHsource <(kubectl completion bash) # set up autocomplete in bash into the current shell, bash-completion package should be installed first.\necho \"source <(kubectl completion bash)\" >> ~/.bashrc # add autocomplete permanently to your bash shell.\nYou can also use a shorthand alias for kubectl that also works with completion:alias k=kubectl\ncomplete -o default -F __start_kubectl k\nZSHsource <(kubectl completion zsh)\n# set up autocomplete in zsh into the current shell\necho '[[ $commands[kubectl] ]] && source <(kubectl completion zsh)' >> ~/.zshrc # add autocomplete permanently to your zsh shell\nFISHNote:Requires kubectl version 1.23 or above.echo 'kubectl completion fish | source' > ~/.config/fish/completions/kubectl.fish && source ~/.config/fish/completions/kubectl.fish\nA note on --all-namespacesAppending --all-namespaces happens frequently enough that you should be aware of the shorthand for --all-namespaces:kubectl -AKubectl context and configurationSet which Kubernetes cluster kubectl communicates with and modifies configuration\ninformation. See Authenticating Across Clusters with kubeconfig documentation for\ndetailed config file information.kubectl config view # Show Merged kubeconfig settings.\n# use multiple kubeconfig files at the same time and view merged config\nKUBECONFIG=~/.kube/config:~/.kube/kubconfig2\nkubectl config view\n# Show merged kubeconfig settings and raw certificate data and exposed secrets\nkubectl config view --raw\n# get the password for the e2e user\nkubectl config view -o jsonpath='{.users[?(@.name == \"e2e\")].user.password}'\n# get the certificate for the e2e user\nkubectl config view --raw -o jsonpath='{.users[?(.name == \"e2e\")].user.client-certificate-data}' | base64 -d\nkubectl config view -o jsonpath='{.users[].name}'\n# display the first user\nkubectl config view -o jsonpath='{.users[*].name}'\n# get a list of users\nkubectl config get-contexts\n# display list of contexts\nkubectl config get-contexts -o name\n# get all context names\nkubectl config current-context\n# display the current-context\nkubectl config use-context my-cluster-name\n# set the default context to my-cluster-name\nkubectl config set-cluster my-cluster-name\n# set a cluster entry in the kubeconfig\n# configure the URL to a proxy server to use for requests made by this client in the kubeconfig\nkubectl config set-cluster my-cluster-name --proxy-url=my-proxy-url\n# add a new user to your kubeconf that supports basic auth\nkubectl config set-credentials kubeuser/foo.kubernetes.com --username=kubeuser --password=kubepassword\n# permanently save the namespace for all subsequent kubectl commands in that context.\nkubectl config set-context --current --namespace=ggckad-s2\n# set a context utilizing a specific username and namespace.\nkubectl config set-context gce --user=cluster-admin --namespace=foo \\\n&& kubectl config use-context gce\nkubectl config unset users.foo\n# delete user foo\n# short alias to set/show context/namespace (only works for bash and bash-compatible shells, current context to be set before using kn to set namespace)\nalias kx='f() { [ \"$1\" ] && kubectl config use-context $1 || kubectl config current-context ; } ; f'\nalias kn='f() { [ \"$1\" ] && kubectl config set-context --current --namespace $1 || kubectl config view --minify | grep namespace | cut -d\" \" -f6 ; } ; f'\nKubectl applyapply manages applications through files defining Kubernetes resources. It creates and updates resources in a cluster through running kubectl apply. This is the recommended way of managing Kubernetes applications on production. See Kubectl Book.Creating objectsKubernetes manifests can be defined in YAML or JSON. The file extension .yaml,\n.yml, and .json can be used.kubectl apply -f ./my-manifest.yaml\n# create resource(s)\nkubectl apply -f ./my1.yaml -f ./my2.yaml\n# create from multiple files\nkubectl apply -f ./dir\n# create resource(s) in all manifest files in dir\nkubectl apply -f https://example.com/manifest.yaml\n# create resource(s) from url (Note: this is an example domain and does not contain a valid manifest)\nkubectl create deployment nginx --image=nginx\n# start a single instance of nginx\n# create a Job which prints \"Hello World\"\nkubectl create job hello --image=busybox:1.28 -- echo \"Hello World\"\n# create a CronJob that prints \"Hello World\" every minute\nkubectl create cronjob hello --image=busybox:1.28\n--schedule=\"*/1 * * * *\" -- echo \"Hello World\"\nkubectl explain pods\n# get the documentation for pod manifests\n# Create multiple YAML objects from stdin\nkubectl apply -f - <<EOF\napiVersion: v1\nkind: Pod\nmetadata:\nname: busybox-sleep\nspec:\ncontainers:\n- name: busybox\nimage: busybox:1.28\nargs:\n- sleep\n- \"1000000\"\n---\napiVersion: v1\nkind: Pod\nmetadata:\nname: busybox-sleep-less\nspec:\ncontainers:\n- name: busybox\nimage: busybox:1.28\nargs:\n- sleep\n- \"1000\"\nEOF\n# Create a secret with several keys\nkubectl apply -f - <<EOF\napiVersion: v1\nkind: Secret\nmetadata:\nname: mysecret\ntype: Opaque\ndata:\npassword: $(echo -n \"s33msi4\" | base64 -w0)\nusername: $(echo -n \"jane\" | base64 -w0)\nEOF\nViewing and finding resources# Get commands with basic output\nkubectl get services\n# List all services in the namespace\nkubectl get pods --all-namespaces\n# List all pods in all namespaces\nkubectl get pods -o wide\n# List all pods in the current namespace, with more details\nkubectl get deployment my-dep\n# List a particular deployment\nkubectl get pods\n# List all pods in the namespace\nkubectl get pod my-pod -o yaml\n# Get a pod's YAML\n# Describe commands with verbose output\nkubectl describe nodes my-node\nkubectl describe pods my-pod\n# List Services Sorted by Name\nkubectl get services --sort-by=.metadata.name\n# List pods Sorted by Restart Count\nkubectl get pods --sort-by='.status.containerStatuses[0].restartCount'\n# List PersistentVolumes sorted by capacity\nkubectl get pv --sort-by=.spec.capacity.storage\n# Get the version label of all pods with label app=cassandra\nkubectl get pods --selector=app=cassandra -o \\\njsonpath='{.items[*].metadata.labels.version}'\n# Retrieve the value of a key with dots, e.g. 'ca.crt'\nkubectl get configmap myconfig \\\n-o jsonpath='{.data.ca\\.crt}'\n# Retrieve a base64 encoded value with dashes instead of underscores.\nkubectl get secret my-secret --template='{{index .data \"key-name-with-dashes\"}}'\n# Get all worker nodes (use a selector to exclude results that have a label\n# named 'node-role.kubernetes.io/control-plane')\nkubectl get node --selector='!node-role.kubernetes.io/control-plane'\n# Get all running pods in the namespace\nkubectl get pods --field-selector=status.phase=Running\n# Get ExternalIPs of all nodes\nkubectl get nodes -o jsonpath='{.items[*].status.addresses[?(@.type==\"ExternalIP\")].address}'\n# List Names of Pods that belong to Particular RC\n# \"jq\" command useful for transformations that are too complex for jsonpath, it can be found at https://jqlang.github.io/jq/\nsel=${$(kubectl get rc my-rc --output=json | jq -j '.spec.selector | to_entries | .[] | \"\\(.key)=\\(.value),\"')%?}\necho $(kubectl get pods --selector=$sel --output=jsonpath={.items..metadata.name})\n# Show labels for all pods (or any other Kubernetes object that supports labelling)\nkubectl get pods --show-labels\n# Check which nodes are ready\nJSONPATH='{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}' \\\n&& kubectl get nodes -o jsonpath=\"$JSONPATH\" | grep \"Ready=True\"\n# Check which nodes are ready with custom-columns\nkubectl get node -o custom-columns='NODE_NAME:.metadata.name,STATUS:.status.conditions[?(@.type==\"Ready\")].status'\n# Output decoded secrets without external tools\nkubectl get secret my-secret -o go-template='{{range $k,$v := .data}}{{\"### \"}}{{$k}}{{\"\\n\"}}{{$v|base64decode}}{{\"\\n\\n\"}}{{end}}'\n# List all Secrets currently in use by a pod\nkubectl get pods -o json | jq '.items[].spec.containers[].env[]?.valueFrom.secretKeyRef.name' | grep -v null | sort | uniq\n# List all containerIDs of initContainer of all pods\n# Helpful when cleaning up stopped containers, while avoiding removal of initContainers.\nkubectl get pods --all-namespaces -o jsonpath='{range .items[*].status.initContainerStatuses[*]}{.containerID}{\"\\n\"}{end}' | cut -d/ -f3\n# List Events sorted by timestamp\nkubectl get events --sort-by=.metadata.creationTimestamp\n# List all warning events\nkubectl events --types=Warning\n# Compares the current state of the cluster against the state that the cluster would be in if the manifest was applied.\nkubectl diff -f ./my-manifest.yaml\n# Produce a period-delimited tree of all keys returned for nodes\n# Helpful when locating a key within a complex nested JSON structure\nkubectl get nodes -o json | jq -c 'paths|join(\".\")'\n# Produce a period-delimited tree of all keys returned for pods, etc\nkubectl get pods -o json | jq -c 'paths|join(\".\")'\n# Produce ENV for all pods, assuming you have a default container for the pods, default namespace and the `env` command is supported.\n# Helpful when running any supported command across all pods, not just `env`\nfor pod in $(kubectl get po --output=jsonpath={.items..metadata.name}); do echo $pod && kubectl exec -it $pod -- env; done\n# Get a deployment's status subresource\nkubectl get deployment nginx-deployment --subresource=status\nUpdating resourceskubectl set image deployment/frontend www=image:v2\n# Rolling update \"www\" containers of \"frontend\" deployment, updating the image\nkubectl rollout history deployment/frontend\n# Check the history of deployments including the revision\nkubectl rollout undo deployment/frontend\n# Rollback to the previous deployment\nkubectl rollout undo deployment/frontend --to-revision=2\n# Rollback to a specific revision\nkubectl rollout status -w deployment/frontend\n# Watch rolling update status of \"frontend\" deployment until completion\nkubectl rollout restart deployment/frontend\n# Rolling restart of the \"frontend\" deployment\ncat pod.json | kubectl replace -f -\n# Replace a pod based on the JSON passed into stdin\n# Force replace, delete and then re-create the resource. Will cause a service outage.\nkubectl replace --force -f ./pod.json\n# Create a service for a replicated nginx, which serves on port 80 and connects to the containers on port 8000\nkubectl expose rc nginx --port=80 --target-port=8000\n# Update a single-container pod's image version (tag) to v4\nkubectl get pod mypod -o yaml | sed 's/\\(image: myimage\\):.*$/\\1:v4/' | kubectl replace -f -\nkubectl label pods my-pod new-label=awesome\n# Add a Label\nkubectl label pods my-pod new-label-\n# Remove a label\nkubectl label pods my-pod new-label=new-value --overwrite\n# Overwrite an existing value\nkubectl annotate pods my-pod icon-url=http://goo.gl/XXBTWq\n# Add an annotation\nkubectl annotate pods my-pod icon-url-\n# Remove annotation\nkubectl autoscale deployment foo --min=2 --max=10\n# Auto scale a deployment \"foo\"\nPatching resources# Partially update a node\nkubectl patch node k8s-node-1 -p '{\"spec\":{\"unschedulable\":true}}'\n# Update a container's image; spec.containers[*].name is required because it's a merge key\nkubectl patch pod valid-pod -p '{\"spec\":{\"containers\":[{\"name\":\"kubernetes-serve-hostname\",\"image\":\"new image\"}]}}'\n# Update a container's image using a json patch with positional arrays\nkubectl patch pod valid-pod --type='json' -p='[{\"op\": \"replace\", \"path\": \"/spec/containers/0/image\", \"value\":\"new image\"}]'\n# Disable a deployment livenessProbe using a json patch with positional arrays\nkubectl patch deployment valid-deployment\n--type json\n-p='[{\"op\": \"remove\", \"path\": \"/spec/template/spec/containers/0/livenessProbe\"}]'\n# Add a new element to a positional array\nkubectl patch sa default --type='json' -p='[{\"op\": \"add\", \"path\": \"/secrets/1\", \"value\": {\"name\": \"whatever\" } }]'\n# Update a deployment's replica count by patching its scale subresource\nkubectl patch deployment nginx-deployment --subresource='scale' --type='merge' -p '{\"spec\":{\"replicas\":2}}'\nEditing resourcesEdit any API resource in your preferred editor.kubectl edit svc/docker-registry\n# Edit the service named docker-registry\nKUBE_EDITOR=\"nano\" kubectl edit svc/docker-registry\n# Use an alternative editor\nScaling resourceskubectl scale --replicas=3 rs/foo\n# Scale a replicaset named 'foo' to 3\nkubectl scale --replicas=3 -f foo.yaml\n# Scale a resource specified in \"foo.yaml\" to 3\nkubectl scale --current-replicas=2 --replicas=3 deployment/mysql\n# If the deployment named mysql's current size is 2, scale mysql to 3\nkubectl scale --replicas=5 rc/foo rc/bar rc/baz\n# Scale multiple replication controllers\nDeleting resourceskubectl delete -f ./pod.json\n# Delete a pod using the type and name specified in pod.json\nkubectl delete pod unwanted --now\n# Delete a pod with no grace period\nkubectl delete pod,service baz foo\n# Delete pods and services with same names \"baz\" and \"foo\"\nkubectl delete pods,services -l name=myLabel\n# Delete pods and services with label name=myLabel\nkubectl -n my-ns delete pod,svc --all\n# Delete all pods and services in namespace my-ns,\n# Delete all pods matching the awk pattern1 or pattern2\nkubectl get pods\n-n mynamespace --no-headers=true | awk '/pattern1|pattern2/{print $1}' | xargs\nkubectl delete -n mynamespace pod\nInteracting with running Podskubectl logs my-pod\n# dump pod logs (stdout)\nkubectl logs -l name=myLabel\n# dump pod logs, with label name=myLabel (stdout)\nkubectl logs my-pod --previous\n# dump pod logs (stdout) for a previous instantiation of a container\nkubectl logs my-pod -c my-container\n# dump pod container logs (stdout, multi-container case)\nkubectl logs -l name=myLabel -c my-container\n# dump pod container logs, with label name=myLabel (stdout)\nkubectl logs my-pod -c my-container --previous\n# dump pod container logs (stdout, multi-container case) for a previous instantiation of a container\nkubectl logs -f my-pod\n# stream pod logs (stdout)\nkubectl logs -f my-pod -c my-container\n# stream pod container logs (stdout, multi-container case)\nkubectl logs -f -l name=myLabel --all-containers\n# stream all pods logs with label name=myLabel (stdout)\nkubectl run -i --tty busybox --image=busybox:1.28 -- sh\n# Run pod as interactive shell\nkubectl run nginx --image=nginx -n mynamespace\n# Start a single instance of nginx pod in the namespace of mynamespace\nkubectl run nginx --image=nginx --dry-run=client -o yaml > pod.yaml\n# Generate spec for running pod nginx and write it into a file called pod.yaml\nkubectl attach my-pod -i\n# Attach to Running Container\nkubectl port-forward my-pod 5000:6000\n# Listen on port 5000 on the local machine and forward to port 6000 on my-pod\nkubectl exec my-pod -- ls /\n# Run command in existing pod (1 container case)\nkubectl exec --stdin --tty my-pod -- /bin/sh\n# Interactive shell access to a running pod (1 container case)\nkubectl exec my-pod -c my-container -- ls /\n# Run command in existing pod (multi-container case)\nkubectl debug my-pod -it --image=busybox:1.28\n# Create an interactive debugging session within existing pod and immediately attach to it\nkubectl debug node/my-node -it --image=busybox:1.28 # Create an interactive debugging session on a node and immediately attach to it\nkubectl top pod\n# Show metrics for all pods in the default namespace\nkubectl top pod POD_NAME --containers\n# Show metrics for a given pod and its containers\nkubectl top pod POD_NAME --sort-by=cpu\n# Show metrics for a given pod and sort it by 'cpu' or 'memory'\nCopying files and directories to and from containerskubectl cp /tmp/foo_dir my-pod:/tmp/bar_dir\n# Copy /tmp/foo_dir local directory to /tmp/bar_dir in a remote pod in the current namespace\nkubectl cp /tmp/foo my-pod:/tmp/bar -c my-container\n# Copy /tmp/foo local file to /tmp/bar in a remote pod in a specific container\nkubectl cp /tmp/foo my-namespace/my-pod:/tmp/bar\n# Copy /tmp/foo local file to /tmp/bar in a remote pod in namespace my-namespace\nkubectl cp my-namespace/my-pod:/tmp/foo /tmp/bar\n# Copy /tmp/foo from a remote pod to /tmp/bar locally\nNote:kubectl cp requires that the 'tar' binary is present in your container image. If 'tar' is not present, kubectl cp will fail.\nFor advanced use cases, such as symlinks, wildcard expansion or file mode preservation consider using kubectl exec.tar cf - /tmp/foo | kubectl exec -i -n my-namespace my-pod -- tar xf - -C /tmp/bar\n# Copy /tmp/foo local file to /tmp/bar in a remote pod in namespace my-namespace\nkubectl exec -n my-namespace my-pod -- tar cf - /tmp/foo | tar xf - -C /tmp/bar\n# Copy /tmp/foo from a remote pod to /tmp/bar locally\nInteracting with Deployments and Serviceskubectl logs deploy/my-deployment\n# dump Pod logs for a Deployment (single-container case)\nkubectl logs deploy/my-deployment -c my-container\n# dump Pod logs for a Deployment (multi-container case)\nkubectl port-forward svc/my-service 5000\n# listen on local port 5000 and forward to port 5000 on Service backend\nkubectl port-forward svc/my-service 5000:my-service-port\n# listen on local port 5000 and forward to Service target port with name <my-service-port>\nkubectl port-forward deploy/my-deployment 5000:6000\n# listen on local port 5000 and forward to port 6000 on a Pod created by <my-deployment>\nkubectl exec deploy/my-deployment -- ls\n# run command in first Pod and first container in Deployment (single- or multi-container cases)\nInteracting with Nodes and clusterkubectl cordon my-node\n# Mark my-node as unschedulable\nkubectl drain my-node\n# Drain my-node in preparation for maintenance\nkubectl uncordon my-node\n# Mark my-node as schedulable\nkubectl top node\n# Show metrics for all nodes\nkubectl top node my-node\n# Show metrics for a given node\nkubectl cluster-info\n# Display addresses of the master and services\nkubectl cluster-info dump\n# Dump current cluster state to stdout\nkubectl cluster-info dump --output-directory=/path/to/cluster-state\n# Dump current cluster state to /path/to/cluster-state\n# View existing taints on which exist on current nodes.\nkubectl get nodes -o='custom-columns=NodeName:.metadata.name,TaintKey:.spec.taints[*].key,TaintValue:.spec.taints[*].value,TaintEffect:.spec.taints[*].effect'\n# If a taint with that key and effect already exists, its value is replaced as specified.\nkubectl taint nodes foo dedicated=special-user:NoSchedule\nResource typesList all supported resource types along with their shortnames, API group, whether they are namespaced, and kind:kubectl api-resources\nOther operations for exploring API resources:kubectl api-resources --namespaced=true\n# All namespaced resources\nkubectl api-resources --namespaced=false\n# All non-namespaced resources\nkubectl api-resources -o name\n# All resources with simple output (only the resource name)\nkubectl api-resources -o wide\n# All resources with expanded (aka \"wide\") output\nkubectl api-resources --verbs=list,get\n# All resources that support the \"list\" and \"get\" request verbs\nkubectl api-resources --api-group=extensions # All resources in the \"extensions\" API group\nFormatting outputTo output details to your terminal window in a specific format, add the -o (or --output) flag to a supported kubectl command.Output formatDescription-o=custom-columns=<spec>Print a table using a comma separated list of custom columns-o=custom-columns-file=<filename>Print a table using the custom columns template in the <filename> file-o=go-template=<template>Print the fields defined in a golang template-o=go-template-file=<filename>Print the fields defined by the golang template in the <filename> file-o=jsonOutput a JSON formatted API object-o=jsonpath=<template>Print the fields defined in a jsonpath expression-o=jsonpath-file=<filename>Print the fields defined by the jsonpath expression in the <filename> file-o=kyamlOutput a KYAML formatted API object (alpha, requires environment variable KUBECTL_KYAML=\"true\"). KYAML is an experimental Kubernetes-specific dialect of YAML, and can be parsed as YAML.-o=namePrint only the resource name and nothing else-o=wideOutput in the plain-text format with any additional information, and for pods, the node name is included-o=yamlOutput a YAML formatted API objectExamples using -o=custom-columns:# All images running in a cluster\nkubectl get pods -A -o=custom-columns='DATA:spec.containers[*].image'\n# All images running in namespace: default, grouped by Pod\nkubectl get pods --namespace default --output=custom-columns=\"NAME:.metadata.name,IMAGE:.spec.containers[*].image\"\n# All images excluding \"registry.k8s.io/coredns:1.6.2\"\nkubectl get pods -A -o=custom-columns='DATA:spec.containers[?(@.image!=\"registry.k8s.io/coredns:1.6.2\")].image'\n# All fields under metadata regardless of name\nkubectl get pods -A -o=custom-columns='DATA:metadata.*'\nMore examples in the kubectl reference documentation.Kubectl output verbosity and debuggingKubectl verbosity is controlled with the -v or --v flags followed by an integer representing the log level. General Kubernetes logging conventions and the associated log levels are described here.VerbosityDescription--v=0Generally useful for this to always be visible to a cluster operator.--v=1A reasonable default log level if you don't want verbosity.--v=2Useful steady state information about the service and important log messages that may correlate to significant changes in the system. This is the recommended default log level for most systems.--v=3Extended information about changes.--v=4Debug level verbosity.--v=5Trace level verbosity.--v=6Display requested resources.--v=7Display HTTP request headers.--v=8Display HTTP request contents.--v=9Display HTTP request contents without truncation of contents.What's nextRead the kubectl overview and learn about JsonPath.See kubectl options.See kuberc options.Also read kubectl Usage Conventions to understand how to use kubectl in reusable scripts.See more community kubectl cheatsheets.FeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified July 01, 2025 at 8:58 AM PST: Document KYAML (9f26f83533) Edit this page\nCreate child page\nCreate an issue\nPrint entire sectionKubectl autocompleteBASHZSHFISHA note on --all-namespacesKubectl context and configurationKubectl applyCreating objectsViewing and finding resourcesUpdating resourcesPatching resourcesEditing resourcesScaling resourcesDeleting resourcesInteracting with running PodsCopying files and directories to and from containersInteracting with Deployments and ServicesInteracting with Nodes and clusterResource typesFormatting outputKubectl output verbosity and debuggingWhat's next\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "kubernetes-docs"
  },
  {
    "url": "https://kubernetes.io/docs/tasks/tools/#kubectl",
    "content": "Install Tools | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationTasksInstall ToolsInstall ToolsSet up Kubernetes tools on your computer.kubectlThe Kubernetes command-line tool, kubectl, allows\nyou to run commands against Kubernetes clusters.\nYou can use kubectl to deploy applications, inspect and manage cluster resources,\nand view logs. For more information including a complete list of kubectl operations, see the\nkubectl reference documentation.kubectl is installable on a variety of Linux platforms, macOS and Windows.\nFind your preferred operating system below.Install kubectl on LinuxInstall kubectl on macOSInstall kubectl on Windowskindkind lets you run Kubernetes on\nyour local computer. This tool requires that you have either\nDocker or Podman installed.The kind Quick Start page\nshows you what you need to do to get up and running with kind.View kind Quick Start GuideminikubeLike kind, minikube is a tool that lets you run Kubernetes\nlocally. minikube runs an all-in-one or a multi-node local Kubernetes cluster on your personal\ncomputer (including Windows, macOS and Linux PCs) so that you can try out\nKubernetes, or for daily development work.You can follow the official\nGet Started! guide if your focus is\non getting the tool installed.View minikube Get Started! GuideOnce you have minikube working, you can use it to\nrun a sample application.kubeadmYou can use the kubeadm tool to create and manage Kubernetes clusters.\nIt performs the actions necessary to get a minimum viable, secure cluster up and running in a user friendly way.Installing kubeadm shows you how to install kubeadm.\nOnce installed, you can use it to create a cluster.View kubeadm Install GuideFeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified July 12, 2023 at 1:25 AM PST: Revise docs home page (9520b96a61) Edit this page\nCreate child page\nCreate an issue\nPrint entire sectionkubectlkindminikubekubeadm\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "#kubectl"
  },
  {
    "url": "https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/",
    "content": "Configure Access to Multiple Clusters | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nBahasa Indonesia (Indonesian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPortugu\u00eas (Portuguese)\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationTasksAccess Applications in a ClusterConfigure Access to Multiple ClustersConfigure Access to Multiple ClustersThis page shows how to configure access to multiple clusters by using\nconfiguration files. After your clusters, users, and contexts are defined in\none or more configuration files, you can quickly switch between clusters by using the\nkubectl config use-context command.Note:A file that is used to configure access to a cluster is sometimes called\na kubeconfig file. This is a generic way of referring to configuration files.\nIt does not mean that there is a file named kubeconfig.Warning:Only use kubeconfig files from trusted sources. Using a specially-crafted kubeconfig\nfile could result in malicious code execution or file exposure.\nIf you must use an untrusted kubeconfig file, inspect it carefully first, much as you would a shell script.Before you beginYou need to have a Kubernetes cluster, and the kubectl command-line tool must\nbe configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a\ncluster, you can create one by using\nminikube\nor you can use one of these Kubernetes playgrounds:iximiuz LabsKillercodaKodeKloudPlay with KubernetesTo check that kubectl is installed,\nrun kubectl version --client. The kubectl version should be\nwithin one minor version of your\ncluster's API server.Define clusters, users, and contextsSuppose you have two clusters, one for development work and one for test work.\nIn the development cluster, your frontend developers work in a namespace called frontend,\nand your storage developers work in a namespace called storage. In your test cluster,\ndevelopers work in the default namespace, or they create auxiliary namespaces as they\nsee fit. Access to the development cluster requires authentication by certificate. Access\nto the test cluster requires authentication by username and password.Create a directory named config-exercise. In your\nconfig-exercise directory, create a file named config-demo with this content:apiVersion: v1\nkind: Config\npreferences: {}\nclusters:\n- cluster:\nname: development\n- cluster:\nname: test\nusers:\n- name: developer\n- name: experimenter\ncontexts:\n- context:\nname: dev-frontend\n- context:\nname: dev-storage\n- context:\nname: exp-test\nA configuration file describes clusters, users, and contexts. Your config-demo file\nhas the framework to describe two clusters, two users, and three contexts.Go to your config-exercise directory. Enter these commands to add cluster details to\nyour configuration file:kubectl config --kubeconfig=config-demo set-cluster development --server=https://1.2.3.4 --certificate-authority=fake-ca-file\nkubectl config --kubeconfig=config-demo set-cluster test --server=https://5.6.7.8 --insecure-skip-tls-verify\nAdd user details to your configuration file:Caution:Storing passwords in Kubernetes client config is risky. A better alternative would be to use a credential plugin and store them separately. See: client-go credential pluginskubectl config --kubeconfig=config-demo set-credentials developer --client-certificate=fake-cert-file --client-key=fake-key-seefile\nkubectl config --kubeconfig=config-demo set-credentials experimenter --username=exp --password=some-password\nNote:To delete a user you can run kubectl --kubeconfig=config-demo config unset users.<name>To remove a cluster, you can run kubectl --kubeconfig=config-demo config unset clusters.<name>To remove a context, you can run kubectl --kubeconfig=config-demo config unset contexts.<name>Add context details to your configuration file:kubectl config --kubeconfig=config-demo set-context dev-frontend --cluster=development --namespace=frontend --user=developer\nkubectl config --kubeconfig=config-demo set-context dev-storage --cluster=development --namespace=storage --user=developer\nkubectl config --kubeconfig=config-demo set-context exp-test --cluster=test --namespace=default --user=experimenter\nOpen your config-demo file to see the added details. As an alternative to opening the\nconfig-demo file, you can use the config view command.kubectl config --kubeconfig=config-demo view\nThe output shows the two clusters, two users, and three contexts:apiVersion: v1\nclusters:\n- cluster:\ncertificate-authority: fake-ca-file\nserver: https://1.2.3.4\nname: development\n- cluster:\ninsecure-skip-tls-verify: true\nserver: https://5.6.7.8\nname: test\ncontexts:\n- context:\ncluster: development\nnamespace: frontend\nuser: developer\nname: dev-frontend\n- context:\ncluster: development\nnamespace: storage\nuser: developer\nname: dev-storage\n- context:\ncluster: test\nnamespace: default\nuser: experimenter\nname: exp-test\ncurrent-context: \"\"\nkind: Config\npreferences: {}\nusers:\n- name: developer\nuser:\nclient-certificate: fake-cert-file\nclient-key: fake-key-file\n- name: experimenter\nuser:\n# Documentation note (this comment is NOT part of the command output).\n# Storing passwords in Kubernetes client config is risky.\n# A better alternative would be to use a credential plugin\n# and store the credentials separately.\n# See https://kubernetes.io/docs/reference/access-authn-authz/authentication/#client-go-credential-plugins\npassword: some-password\nusername: exp\nThe fake-ca-file, fake-cert-file and fake-key-file above are the placeholders\nfor the pathnames of the certificate files. You need to change these to the actual pathnames\nof certificate files in your environment.Sometimes you may want to use Base64-encoded data embedded here instead of separate\ncertificate files; in that case you need to add the suffix -data to the keys, for example,\ncertificate-authority-data, client-certificate-data, client-key-data.Each context is a triple (cluster, user, namespace). For example, the\ndev-frontend context says, \"Use the credentials of the developer\nuser to access the frontend namespace of the development cluster\".Set the current context:kubectl config --kubeconfig=config-demo use-context dev-frontend\nNow whenever you enter a kubectl command, the action will apply to the cluster,\nand namespace listed in the dev-frontend context. And the command will use\nthe credentials of the user listed in the dev-frontend context.To see only the configuration information associated with\nthe current context, use the --minify flag.kubectl config --kubeconfig=config-demo view --minify\nThe output shows configuration information associated with the dev-frontend context:apiVersion: v1\nclusters:\n- cluster:\ncertificate-authority: fake-ca-file\nserver: https://1.2.3.4\nname: development\ncontexts:\n- context:\ncluster: development\nnamespace: frontend\nuser: developer\nname: dev-frontend\ncurrent-context: dev-frontend\nkind: Config\npreferences: {}\nusers:\n- name: developer\nuser:\nclient-certificate: fake-cert-file\nclient-key: fake-key-file\nNow suppose you want to work for a while in the test cluster.Change the current context to exp-test:kubectl config --kubeconfig=config-demo use-context exp-test\nNow any kubectl command you give will apply to the default namespace of\nthe test cluster. And the command will use the credentials of the user\nlisted in the exp-test context.View configuration associated with the new current context, exp-test.kubectl config --kubeconfig=config-demo view --minify\nFinally, suppose you want to work for a while in the storage namespace of the\ndevelopment cluster.Change the current context to dev-storage:kubectl config --kubeconfig=config-demo use-context dev-storage\nView configuration associated with the new current context, dev-storage.kubectl config --kubeconfig=config-demo view --minify\nCreate a second configuration fileIn your config-exercise directory, create a file named config-demo-2 with this content:apiVersion: v1\nkind: Config\npreferences: {}\ncontexts:\n- context:\ncluster: development\nnamespace: ramp\nuser: developer\nname: dev-ramp-up\nThe preceding configuration file defines a new context named dev-ramp-up.Set the KUBECONFIG environment variableSee whether you have an environment variable named KUBECONFIG. If so, save the\ncurrent value of your KUBECONFIG environment variable, so you can restore it later.\nFor example:Linuxexport KUBECONFIG_SAVED=\"$KUBECONFIG\"\nWindows PowerShell$Env:KUBECONFIG_SAVED=$ENV:KUBECONFIG\nThe KUBECONFIG environment variable is a list of paths to configuration files. The list is\ncolon-delimited for Linux and Mac, and semicolon-delimited for Windows. If you have\na KUBECONFIG environment variable, familiarize yourself with the configuration files\nin the list.Temporarily append two paths to your KUBECONFIG environment variable. For example:Linuxexport KUBECONFIG=\"${KUBECONFIG}:config-demo:config-demo-2\"\nWindows PowerShell$Env:KUBECONFIG=(\"config-demo;config-demo-2\")\nIn your config-exercise directory, enter this command:kubectl config view\nThe output shows merged information from all the files listed in your KUBECONFIG\nenvironment variable. In particular, notice that the merged information has the\ndev-ramp-up context from the config-demo-2 file and the three contexts from\nthe config-demo file:contexts:\n- context:\ncluster: development\nnamespace: frontend\nuser: developer\nname: dev-frontend\n- context:\ncluster: development\nnamespace: ramp\nuser: developer\nname: dev-ramp-up\n- context:\ncluster: development\nnamespace: storage\nuser: developer\nname: dev-storage\n- context:\ncluster: test\nnamespace: default\nuser: experimenter\nname: exp-test\nFor more information about how kubeconfig files are merged, see\nOrganizing Cluster Access Using kubeconfig FilesExplore the $HOME/.kube directoryIf you already have a cluster, and you can use kubectl to interact with\nthe cluster, then you probably have a file named config in the $HOME/.kube\ndirectory.Go to $HOME/.kube, and see what files are there. Typically, there is a file named\nconfig. There might also be other configuration files in this directory. Briefly\nfamiliarize yourself with the contents of these files.Append $HOME/.kube/config to your KUBECONFIG environment variableIf you have a $HOME/.kube/config file, and it's not already listed in your\nKUBECONFIG environment variable, append it to your KUBECONFIG environment variable now.\nFor example:Linuxexport KUBECONFIG=\"${KUBECONFIG}:${HOME}/.kube/config\"\nWindows Powershell$Env:KUBECONFIG=\"$Env:KUBECONFIG;$HOME\\.kube\\config\"\nView configuration information merged from all the files that are now listed\nin your KUBECONFIG environment variable. In your config-exercise directory, enter:kubectl config view\nClean upReturn your KUBECONFIG environment variable to its original value. For example:Linuxexport KUBECONFIG=\"$KUBECONFIG_SAVED\"\nWindows PowerShell$Env:KUBECONFIG=$ENV:KUBECONFIG_SAVED\nCheck the subject represented by the kubeconfigIt is not always obvious what attributes (username, groups) you will get after authenticating to the cluster.\nIt can be even more challenging if you are managing more than one cluster at the same time.There is a kubectl subcommand to check subject attributes, such as username, for your selected Kubernetes\nclient context: kubectl auth whoami.Read API access to authentication information for a client\nto learn about this in more detail.What's nextOrganizing Cluster Access Using kubeconfig Fileskubectl configFeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified July 12, 2023 at 1:25 AM PST: Revise docs home page (9520b96a61) Edit this page\nCreate child page\nCreate an issue\nPrint entire sectionBefore you beginDefine clusters, users, and contextsCreate a second configuration fileSet the KUBECONFIG environment variableLinuxWindows PowerShellLinuxWindows PowerShellExplore the $HOME/.kube directoryAppend $HOME/.kube/config to your KUBECONFIG environment variableLinuxWindows PowershellClean upLinuxWindows PowerShellCheck the subject represented by the kubeconfigWhat's next\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "kubernetes-docs"
  },
  {
    "url": "https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/",
    "content": "Deploy and Access the Kubernetes Dashboard | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nBahasa Indonesia (Indonesian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPortugu\u00eas (Portuguese)\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationTasksAccess Applications in a ClusterDeploy and Access the Kubernetes DashboardDeploy and Access the Kubernetes DashboardDeploy the web UI (Kubernetes Dashboard) and access it.Dashboard is a web-based Kubernetes user interface.\nYou can use Dashboard to deploy containerized applications to a Kubernetes cluster,\ntroubleshoot your containerized application, and manage the cluster resources.\nYou can use Dashboard to get an overview of applications running on your cluster,\nas well as for creating or modifying individual Kubernetes resources\n(such as Deployments, Jobs, DaemonSets, etc).\nFor example, you can scale a Deployment, initiate a rolling update, restart a pod\nor deploy new applications using a deploy wizard.Dashboard also provides information on the state of Kubernetes resources in your cluster and on any errors that may have occurred.Deploying the Dashboard UINote:Kubernetes Dashboard supports only Helm-based installation currently as it is faster\nand gives us better control over all dependencies required by Dashboard to run.The Dashboard UI is not deployed by default. To deploy it, run the following command:# Add kubernetes-dashboard repository\nhelm repo add kubernetes-dashboard https://kubernetes.github.io/dashboard/\n# Deploy a Helm Release named \"kubernetes-dashboard\" using the kubernetes-dashboard chart\nhelm upgrade --install kubernetes-dashboard kubernetes-dashboard/kubernetes-dashboard --create-namespace --namespace kubernetes-dashboard\nAccessing the Dashboard UITo protect your cluster data, Dashboard deploys with a minimal RBAC configuration by default.\nCurrently, Dashboard only supports logging in with a Bearer Token.\nTo create a token for this demo, you can follow our guide on\ncreating a sample user.Warning:The sample user created in the tutorial will have administrative privileges and is for educational purposes only.Command line proxyYou can enable access to the Dashboard using the kubectl command-line tool,\nby running the following command:kubectl -n kubernetes-dashboard port-forward svc/kubernetes-dashboard-kong-proxy 8443:443\nKubectl will make Dashboard available at https://localhost:8443.The UI can only be accessed from the machine where the command is executed. See kubectl port-forward --help for more options.Note:The kubeconfig authentication method does not support external identity providers\nor X.509 certificate-based authentication.Welcome viewWhen you access Dashboard on an empty cluster, you'll see the welcome page.\nThis page contains a link to this document as well as a button to deploy your first application.\nIn addition, you can view which system applications are running by default in the kube-system\nnamespace of your cluster, for example the Dashboard itself.Deploying containerized applicationsDashboard lets you create and deploy a containerized application as a Deployment and optional Service with a simple wizard.\nYou can either manually specify application details, or upload a YAML or JSON manifest file containing application configuration.Click the CREATE button in the upper right corner of any page to begin.Specifying application detailsThe deploy wizard expects that you provide the following information:App name (mandatory): Name for your application.\nA label with the name will be\nadded to the Deployment and Service, if any, that will be deployed.The application name must be unique within the selected Kubernetes namespace.\nIt must start with a lowercase character, and end with a lowercase character or a number,\nand contain only lowercase letters, numbers and dashes (-). It is limited to 24 characters.\nLeading and trailing spaces are ignored.Container image (mandatory):\nThe URL of a public Docker container image on any registry,\nor a private image (commonly hosted on the Google Container Registry or Docker Hub).\nThe container image specification must end with a colon.Number of pods (mandatory): The target number of Pods you want your application to be deployed in.\nThe value must be a positive integer.A Deployment will be created to\nmaintain the desired number of Pods across your cluster.Service (optional): For some parts of your application (e.g. frontends) you may want to expose a\nService onto an external,\nmaybe public IP address outside of your cluster (external Service).Note:For external Services, you may need to open up one or more ports to do so.Other Services that are only visible from inside the cluster are called internal Services.Irrespective of the Service type, if you choose to create a Service and your container listens\non a port (incoming), you need to specify two ports.\nThe Service will be created mapping the port (incoming) to the target port seen by the container.\nThis Service will route to your deployed Pods. Supported protocols are TCP and UDP.\nThe internal DNS name for this Service will be the value you specified as application name above.If needed, you can expand the Advanced options section where you can specify more settings:Description: The text you enter here will be added as an\nannotation\nto the Deployment and displayed in the application's details.Labels: Default labels to be used\nfor your application are application name and version.\nYou can specify additional labels to be applied to the Deployment, Service (if any), and Pods,\nsuch as release, environment, tier, partition, and release track.Example:release=1.0\ntier=frontend\nenvironment=pod\ntrack=stable\nNamespace: Kubernetes supports multiple virtual clusters backed by the same physical cluster.\nThese virtual clusters are called namespaces.\nThey let you partition resources into logically named groups.Dashboard offers all available namespaces in a dropdown list, and allows you to create a new namespace.\nThe namespace name may contain a maximum of 63 alphanumeric characters and dashes (-) but can not contain capital letters.\nNamespace names should not consist of only numbers.\nIf the name is set as a number, such as 10, the pod will be put in the default namespace.In case the creation of the namespace is successful, it is selected by default.\nIf the creation fails, the first namespace is selected.Image Pull Secret:\nIn case the specified Docker container image is private, it may require\npull secret credentials.Dashboard offers all available secrets in a dropdown list, and allows you to create a new secret.\nThe secret name must follow the DNS domain name syntax, for example new.image-pull.secret.\nThe content of a secret must be base64-encoded and specified in a\n.dockercfg file.\nThe secret name may consist of a maximum of 253 characters.In case the creation of the image pull secret is successful, it is selected by default. If the creation fails, no secret is applied.CPU requirement (cores) and Memory requirement (MiB):\nYou can specify the minimum resource limits\nfor the container. By default, Pods run with unbounded CPU and memory limits.Run command and Run command arguments:\nBy default, your containers run the specified Docker image's default\nentrypoint command.\nYou can use the command options and arguments to override the default.Run as privileged: This setting determines whether processes in\nprivileged containers\nare equivalent to processes running as root on the host.\nPrivileged containers can make use of capabilities like manipulating the network stack and accessing devices.Environment variables: Kubernetes exposes Services through\nenvironment variables.\nYou can compose environment variable or pass arguments to your commands using the values of environment variables.\nThey can be used in applications to find a Service.\nValues can reference other variables using the $(VAR_NAME) syntax.Uploading a YAML or JSON fileKubernetes supports declarative configuration.\nIn this style, all configuration is stored in manifests (YAML or JSON configuration files).\nThe manifests use Kubernetes API resource schemas.As an alternative to specifying application details in the deploy wizard,\nyou can define your application in one or more manifests, and upload the files using Dashboard.Using DashboardFollowing sections describe views of the Kubernetes Dashboard UI; what they provide and how can they be used.NavigationWhen there are Kubernetes objects defined in the cluster, Dashboard shows them in the initial view.\nBy default only objects from the default namespace are shown and\nthis can be changed using the namespace selector located in the navigation menu.Dashboard shows most Kubernetes object kinds and groups them in a few menu categories.Admin overviewFor cluster and namespace administrators, Dashboard lists Nodes, Namespaces and PersistentVolumes and has detail views for them.\nNode list view contains CPU and memory usage metrics aggregated across all Nodes.\nThe details view shows the metrics for a Node, its specification, status,\nallocated resources, events and pods running on the node.WorkloadsShows all applications running in the selected namespace.\nThe view lists applications by workload kind (for example: Deployments, ReplicaSets, StatefulSets).\nEach workload kind can be viewed separately.\nThe lists summarize actionable information about the workloads,\nsuch as the number of ready pods for a ReplicaSet or current memory usage for a Pod.Detail views for workloads show status and specification information and\nsurface relationships between objects.\nFor example, Pods that ReplicaSet is controlling or new ReplicaSets and HorizontalPodAutoscalers for Deployments.ServicesShows Kubernetes resources that allow for exposing services to external world and\ndiscovering them within a cluster.\nFor that reason, Service and Ingress views show Pods targeted by them,\ninternal endpoints for cluster connections and external endpoints for external users.StorageStorage view shows PersistentVolumeClaim resources which are used by applications for storing data.ConfigMaps and SecretsShows all Kubernetes resources that are used for live configuration of applications running in clusters.\nThe view allows for editing and managing config objects and displays secrets hidden by default.Logs viewerPod lists and detail pages link to a logs viewer that is built into Dashboard.\nThe viewer allows for drilling down logs from containers belonging to a single Pod.What's nextFor more information, see the\nKubernetes Dashboard project page.FeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified September 03, 2024 at 1:40 PM PST: Update web-ui-dashboard.md: Adopted new proxy command (21644e1c6f) Edit this page\nCreate child page\nCreate an issue\nPrint entire sectionDeploying the Dashboard UIAccessing the Dashboard UICommand line proxyWelcome viewDeploying containerized applicationsSpecifying application detailsUploading a YAML or JSON fileUsing DashboardNavigationWhat's next\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "kubernetes-docs"
  },
  {
    "url": "https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/",
    "content": "Configure a Pod to Use a ConfigMap | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nBahasa Indonesia (Indonesian)\n\u65e5\u672c\u8a9e (Japanese)\nPortugu\u00eas (Portuguese)\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationTasksConfigure Pods and ContainersConfigure a Pod to Use a ConfigMapConfigure a Pod to Use a ConfigMapMany applications rely on configuration which is used during either application initialization or runtime.\nMost times, there is a requirement to adjust values assigned to configuration parameters.\nConfigMaps are a Kubernetes mechanism that let you inject configuration data into application\npods.The ConfigMap concept allow you to decouple configuration artifacts from image content to\nkeep containerized applications portable. For example, you can download and run the same\ncontainer image to spin up containers for\nthe purposes of local development, system test, or running a live end-user workload.This page provides a series of usage examples demonstrating how to create ConfigMaps and\nconfigure Pods using data stored in ConfigMaps.Before you beginYou need to have a Kubernetes cluster, and the kubectl command-line tool must\nbe configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a\ncluster, you can create one by using\nminikube\nor you can use one of these Kubernetes playgrounds:iximiuz LabsKillercodaKodeKloudPlay with KubernetesYou need to have the wget tool installed. If you have a different tool\nsuch as curl, and you do not have wget, you will need to adapt the\nstep that downloads example data.Create a ConfigMapYou can use either kubectl create configmap or a ConfigMap generator in kustomization.yaml\nto create a ConfigMap.Create a ConfigMap using kubectl create configmapUse the kubectl create configmap command to create ConfigMaps from\ndirectories, files,\nor literal values:kubectl create configmap <map-name> <data-source>\nwhere <map-name> is the name you want to assign to the ConfigMap and <data-source> is the\ndirectory, file, or literal value to draw the data from.\nThe name of a ConfigMap object must be a valid\nDNS subdomain name.When you are creating a ConfigMap based on a file, the key in the <data-source> defaults to\nthe basename of the file, and the value defaults to the file content.You can use kubectl describe or\nkubectl get to retrieve information\nabout a ConfigMap.Create a ConfigMap from a directoryYou can use kubectl create configmap to create a ConfigMap from multiple files in the same\ndirectory. When you are creating a ConfigMap based on a directory, kubectl identifies files\nwhose filename is a valid key in the directory and packages each of those files into the new\nConfigMap. Any directory entries except regular files are ignored (for example: subdirectories,\nsymlinks, devices, pipes, and more).Note:Each filename being used for ConfigMap creation must consist of only acceptable characters,\nwhich are: letters (A to Z and a to z), digits (0 to 9), '-', '_', or '.'.\nIf you use kubectl create configmap with a directory where any of the file names contains\nan unacceptable character, the kubectl command may fail.The kubectl command does not print an error when it encounters an invalid filename.Create the local directory:mkdir -p configure-pod-container/configmap/\nNow, download the sample configuration and create the ConfigMap:# Download the sample files into `configure-pod-container/configmap/` directory\nwget https://kubernetes.io/examples/configmap/game.properties -O configure-pod-container/configmap/game.properties\nwget https://kubernetes.io/examples/configmap/ui.properties -O configure-pod-container/configmap/ui.properties\n# Create the ConfigMap\nkubectl create configmap game-config --from-file=configure-pod-container/configmap/\nThe above command packages each file, in this case, game.properties and ui.properties\nin the configure-pod-container/configmap/ directory into the game-config ConfigMap. You can\ndisplay details of the ConfigMap using the following command:kubectl describe configmaps game-config\nThe output is similar to this:Name:\ngame-config\nNamespace:\ndefault\nLabels:\n<none>\nAnnotations:\n<none>\nData\n====\ngame.properties:\n----\nenemies=aliens\nlives=3\nenemies.cheat=true\nenemies.cheat.level=noGoodRotten\nsecret.code.passphrase=UUDDLRLRBABAS\nsecret.code.allowed=true\nsecret.code.lives=30\nui.properties:\n----\ncolor.good=purple\ncolor.bad=yellow\nallow.textmode=true\nhow.nice.to.look=fairlyNice\nThe game.properties and ui.properties files in the configure-pod-container/configmap/\ndirectory are represented in the data section of the ConfigMap.kubectl get configmaps game-config -o yaml\nThe output is similar to this:apiVersion: v1\nkind: ConfigMap\nmetadata:\ncreationTimestamp: 2022-02-18T18:52:05Z\nname: game-config\nnamespace: default\nresourceVersion: \"516\"\nuid: b4952dc3-d670-11e5-8cd0-68f728db1985\ndata:\ngame.properties: |\nenemies=aliens\nlives=3\nenemies.cheat=true\nenemies.cheat.level=noGoodRotten\nsecret.code.passphrase=UUDDLRLRBABAS\nsecret.code.allowed=true\nsecret.code.lives=30\nui.properties: |\ncolor.good=purple\ncolor.bad=yellow\nallow.textmode=true\nhow.nice.to.look=fairlyNice\nCreate ConfigMaps from filesYou can use kubectl create configmap to create a ConfigMap from an individual file, or from\nmultiple files.For example,kubectl create configmap game-config-2 --from-file=configure-pod-container/configmap/game.properties\nwould produce the following ConfigMap:kubectl describe configmaps game-config-2\nwhere the output is similar to this:Name:\ngame-config-2\nNamespace:\ndefault\nLabels:\n<none>\nAnnotations:\n<none>\nData\n====\ngame.properties:\n----\nenemies=aliens\nlives=3\nenemies.cheat=true\nenemies.cheat.level=noGoodRotten\nsecret.code.passphrase=UUDDLRLRBABAS\nsecret.code.allowed=true\nsecret.code.lives=30\nYou can pass in the --from-file argument multiple times to create a ConfigMap from multiple\ndata sources.kubectl create configmap game-config-2 --from-file=configure-pod-container/configmap/game.properties --from-file=configure-pod-container/configmap/ui.properties\nYou can display details of the game-config-2 ConfigMap using the following command:kubectl describe configmaps game-config-2\nThe output is similar to this:Name:\ngame-config-2\nNamespace:\ndefault\nLabels:\n<none>\nAnnotations:\n<none>\nData\n====\ngame.properties:\n----\nenemies=aliens\nlives=3\nenemies.cheat=true\nenemies.cheat.level=noGoodRotten\nsecret.code.passphrase=UUDDLRLRBABAS\nsecret.code.allowed=true\nsecret.code.lives=30\nui.properties:\n----\ncolor.good=purple\ncolor.bad=yellow\nallow.textmode=true\nhow.nice.to.look=fairlyNice\nUse the option --from-env-file to create a ConfigMap from an env-file, for example:# Env-files contain a list of environment variables.\n# These syntax rules apply:\n#\nEach line in an env file has to be in VAR=VAL format.\n#\nLines beginning with # (i.e. comments) are ignored.\n#\nBlank lines are ignored.\n#\nThere is no special handling of quotation marks (i.e. they will be part of the ConfigMap value)).\n# Download the sample files into `configure-pod-container/configmap/` directory\nwget https://kubernetes.io/examples/configmap/game-env-file.properties -O configure-pod-container/configmap/game-env-file.properties\nwget https://kubernetes.io/examples/configmap/ui-env-file.properties -O configure-pod-container/configmap/ui-env-file.properties\n# The env-file `game-env-file.properties` looks like below\ncat configure-pod-container/configmap/game-env-file.properties\nenemies=aliens\nlives=3\nallowed=\"true\"\n# This comment and the empty line above it are ignored\nkubectl create configmap game-config-env-file \\\n--from-env-file=configure-pod-container/configmap/game-env-file.properties\nwould produce a ConfigMap. View the ConfigMap:kubectl get configmap game-config-env-file -o yaml\nthe output is similar to:apiVersion: v1\nkind: ConfigMap\nmetadata:\ncreationTimestamp: 2019-12-27T18:36:28Z\nname: game-config-env-file\nnamespace: default\nresourceVersion: \"809965\"\nuid: d9d1ca5b-eb34-11e7-887b-42010a8002b8\ndata:\nallowed: '\"true\"'\nenemies: aliens\nlives: \"3\"\nStarting with Kubernetes v1.23, kubectl supports the --from-env-file argument to be\nspecified multiple times to create a ConfigMap from multiple data sources.kubectl create configmap config-multi-env-files \\\n--from-env-file=configure-pod-container/configmap/game-env-file.properties \\\n--from-env-file=configure-pod-container/configmap/ui-env-file.properties\nwould produce the following ConfigMap:kubectl get configmap config-multi-env-files -o yaml\nwhere the output is similar to this:apiVersion: v1\nkind: ConfigMap\nmetadata:\ncreationTimestamp: 2019-12-27T18:38:34Z\nname: config-multi-env-files\nnamespace: default\nresourceVersion: \"810136\"\nuid: 252c4572-eb35-11e7-887b-42010a8002b8\ndata:\nallowed: '\"true\"'\ncolor: purple\nenemies: aliens\nhow: fairlyNice\nlives: \"3\"\ntextmode: \"true\"\nDefine the key to use when creating a ConfigMap from a fileYou can define a key other than the file name to use in the data section of your ConfigMap\nwhen using the --from-file argument:kubectl create configmap game-config-3 --from-file=<my-key-name>=<path-to-file>\nwhere <my-key-name> is the key you want to use in the ConfigMap and <path-to-file> is the\nlocation of the data source file you want the key to represent.For example:kubectl create configmap game-config-3 --from-file=game-special-key=configure-pod-container/configmap/game.properties\nwould produce the following ConfigMap:kubectl get configmaps game-config-3 -o yaml\nwhere the output is similar to this:apiVersion: v1\nkind: ConfigMap\nmetadata:\ncreationTimestamp: 2022-02-18T18:54:22Z\nname: game-config-3\nnamespace: default\nresourceVersion: \"530\"\nuid: 05f8da22-d671-11e5-8cd0-68f728db1985\ndata:\ngame-special-key: |\nenemies=aliens\nlives=3\nenemies.cheat=true\nenemies.cheat.level=noGoodRotten\nsecret.code.passphrase=UUDDLRLRBABAS\nsecret.code.allowed=true\nsecret.code.lives=30\nCreate ConfigMaps from literal valuesYou can use kubectl create configmap with the --from-literal argument to define a literal\nvalue from the command line:kubectl create configmap special-config --from-literal=special.how=very --from-literal=special.type=charm\nYou can pass in multiple key-value pairs. Each pair provided on the command line is represented\nas a separate entry in the data section of the ConfigMap.kubectl get configmaps special-config -o yaml\nThe output is similar to this:apiVersion: v1\nkind: ConfigMap\nmetadata:\ncreationTimestamp: 2022-02-18T19:14:38Z\nname: special-config\nnamespace: default\nresourceVersion: \"651\"\nuid: dadce046-d673-11e5-8cd0-68f728db1985\ndata:\nspecial.how: very\nspecial.type: charm\nCreate a ConfigMap from generatorYou can also create a ConfigMap from generators and then apply it to create the object\nin the cluster's API server.\nYou should specify the generators in a kustomization.yaml file within a directory.Generate ConfigMaps from filesFor example, to generate a ConfigMap from files configure-pod-container/configmap/game.properties# Create a kustomization.yaml file with ConfigMapGenerator\ncat <<EOF >./kustomization.yaml\nconfigMapGenerator:\n- name: game-config-4\noptions:\nlabels:\ngame-config: config-4\nfiles:\n- configure-pod-container/configmap/game.properties\nEOF\nApply the kustomization directory to create the ConfigMap object:kubectl apply -k .\nconfigmap/game-config-4-m9dm2f92bt created\nYou can check that the ConfigMap was created like this:kubectl get configmap\nNAME\nDATA\nAGE\ngame-config-4-m9dm2f92bt\n1\n37s\nand also:kubectl describe configmaps/game-config-4-m9dm2f92bt\nName:\ngame-config-4-m9dm2f92bt\nNamespace:\ndefault\nLabels:\ngame-config=config-4\nAnnotations:\nkubectl.kubernetes.io/last-applied-configuration:\n{\"apiVersion\":\"v1\",\"data\":{\"game.properties\":\"enemies=aliens\\nlives=3\\nenemies.cheat=true\\nenemies.cheat.level=noGoodRotten\\nsecret.code.p...\nData\n====\ngame.properties:\n----\nenemies=aliens\nlives=3\nenemies.cheat=true\nenemies.cheat.level=noGoodRotten\nsecret.code.passphrase=UUDDLRLRBABAS\nsecret.code.allowed=true\nsecret.code.lives=30\nEvents:\n<none>\nNotice that the generated ConfigMap name has a suffix appended by hashing the contents. This\nensures that a new ConfigMap is generated each time the content is modified.Define the key to use when generating a ConfigMap from a fileYou can define a key other than the file name to use in the ConfigMap generator.\nFor example, to generate a ConfigMap from files configure-pod-container/configmap/game.properties\nwith the key game-special-key# Create a kustomization.yaml file with ConfigMapGenerator\ncat <<EOF >./kustomization.yaml\nconfigMapGenerator:\n- name: game-config-5\noptions:\nlabels:\ngame-config: config-5\nfiles:\n- game-special-key=configure-pod-container/configmap/game.properties\nEOF\nApply the kustomization directory to create the ConfigMap object.kubectl apply -k .\nconfigmap/game-config-5-m67dt67794 created\nGenerate ConfigMaps from literalsThis example shows you how to create a ConfigMap from two literal key/value pairs:\nspecial.type=charm and special.how=very, using Kustomize and kubectl. To achieve\nthis, you can specify the ConfigMap generator. Create (or replace)\nkustomization.yaml so that it has the following contents:---\n# kustomization.yaml contents for creating a ConfigMap from literals\nconfigMapGenerator:\n- name: special-config-2\nliterals:\n- special.how=very\n- special.type=charm\nApply the kustomization directory to create the ConfigMap object:kubectl apply -k .\nconfigmap/special-config-2-c92b5mmcf2 created\nInterim cleanupBefore proceeding, clean up some of the ConfigMaps you made:kubectl delete configmap special-config\nkubectl delete configmap env-config\nkubectl delete configmap -l 'game-config in (config-4,config-5)'\nNow that you have learned to define ConfigMaps, you can move on to the next\nsection, and learn how to use these objects with Pods.Define container environment variables using ConfigMap dataDefine a container environment variable with data from a single ConfigMapDefine an environment variable as a key-value pair in a ConfigMap:kubectl create configmap special-config --from-literal=special.how=very\nAssign the special.how value defined in the ConfigMap to the SPECIAL_LEVEL_KEY\nenvironment variable in the Pod specification.pods/pod-single-configmap-env-variable.yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: dapi-test-pod\nspec:\ncontainers:\n- name: test-container\nimage: registry.k8s.io/busybox:1.27.2\ncommand: [ \"/bin/sh\", \"-c\", \"env\" ]\nenv:\n# Define the environment variable\n- name: SPECIAL_LEVEL_KEY\nvalueFrom:\nconfigMapKeyRef:\n# The ConfigMap containing the value you want to assign to SPECIAL_LEVEL_KEY\nname: special-config\n# Specify the key associated with the value\nkey: special.how\nrestartPolicy: Never\nCreate the Pod:kubectl create -f https://kubernetes.io/examples/pods/pod-single-configmap-env-variable.yaml\nNow, the Pod's output includes environment variable SPECIAL_LEVEL_KEY=very.Define container environment variables with data from multiple ConfigMapsAs with the previous example, create the ConfigMaps first.\nHere is the manifest you will use:configmap/configmaps.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: special-config\nnamespace: default\ndata:\nspecial.how: very\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: env-config\nnamespace: default\ndata:\nlog_level: INFO\nCreate the ConfigMap:kubectl create -f https://kubernetes.io/examples/configmap/configmaps.yaml\nDefine the environment variables in the Pod specification.pods/pod-multiple-configmap-env-variable.yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: dapi-test-pod\nspec:\ncontainers:\n- name: test-container\nimage: registry.k8s.io/busybox:1.27.2\ncommand: [ \"/bin/sh\", \"-c\", \"env\" ]\nenv:\n- name: SPECIAL_LEVEL_KEY\nvalueFrom:\nconfigMapKeyRef:\nname: special-config\nkey: special.how\n- name: LOG_LEVEL\nvalueFrom:\nconfigMapKeyRef:\nname: env-config\nkey: log_level\nrestartPolicy: Never\nCreate the Pod:kubectl create -f https://kubernetes.io/examples/pods/pod-multiple-configmap-env-variable.yaml\nNow, the Pod's output includes environment variables SPECIAL_LEVEL_KEY=very and LOG_LEVEL=INFO.Once you're happy to move on, delete that Pod and ConfigMap:kubectl delete pod dapi-test-pod --now\nkubectl delete configmap special-config\nkubectl delete configmap env-config\nConfigure all key-value pairs in a ConfigMap as container environment variablesCreate a ConfigMap containing multiple key-value pairs.configmap/configmap-multikeys.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: special-config\nnamespace: default\ndata:\nSPECIAL_LEVEL: very\nSPECIAL_TYPE: charm\nCreate the ConfigMap:kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml\nUse envFrom to define all of the ConfigMap's data as container environment variables. The\nkey from the ConfigMap becomes the environment variable name in the Pod.pods/pod-configmap-envFrom.yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: dapi-test-pod\nspec:\ncontainers:\n- name: test-container\nimage: registry.k8s.io/busybox:1.27.2\ncommand: [ \"/bin/sh\", \"-c\", \"env\" ]\nenvFrom:\n- configMapRef:\nname: special-config\nrestartPolicy: Never\nCreate the Pod:kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-envFrom.yaml\nNow, the Pod's output includes environment variables SPECIAL_LEVEL=very and\nSPECIAL_TYPE=charm.Once you're happy to move on, delete that Pod:kubectl delete pod dapi-test-pod --now\nUse ConfigMap-defined environment variables in Pod commandsYou can use ConfigMap-defined environment variables in the command and args of a container\nusing the $(VAR_NAME) Kubernetes substitution syntax.For example, the following Pod manifest:pods/pod-configmap-env-var-valueFrom.yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: dapi-test-pod\nspec:\ncontainers:\n- name: test-container\nimage: registry.k8s.io/busybox:1.27.2\ncommand: [ \"/bin/echo\", \"$(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)\" ]\nenv:\n- name: SPECIAL_LEVEL_KEY\nvalueFrom:\nconfigMapKeyRef:\nname: special-config\nkey: SPECIAL_LEVEL\n- name: SPECIAL_TYPE_KEY\nvalueFrom:\nconfigMapKeyRef:\nname: special-config\nkey: SPECIAL_TYPE\nrestartPolicy: Never\nCreate that Pod, by running:kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-env-var-valueFrom.yaml\nThat pod produces the following output from the test-container container:kubectl logs dapi-test-pod\nvery charm\nOnce you're happy to move on, delete that Pod:kubectl delete pod dapi-test-pod --now\nAdd ConfigMap data to a VolumeAs explained in Create ConfigMaps from files, when you create\na ConfigMap using --from-file, the filename becomes a key stored in the data section of\nthe ConfigMap. The file contents become the key's value.The examples in this section refer to a ConfigMap named special-config:configmap/configmap-multikeys.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: special-config\nnamespace: default\ndata:\nSPECIAL_LEVEL: very\nSPECIAL_TYPE: charm\nCreate the ConfigMap:kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml\nPopulate a Volume with data stored in a ConfigMapAdd the ConfigMap name under the volumes section of the Pod specification.\nThis adds the ConfigMap data to the directory specified as volumeMounts.mountPath (in this\ncase, /etc/config). The command section lists directory files with names that match the\nkeys in ConfigMap.pods/pod-configmap-volume.yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: dapi-test-pod\nspec:\ncontainers:\n- name: test-container\nimage: registry.k8s.io/busybox:1.27.2\ncommand: [ \"/bin/sh\", \"-c\", \"ls /etc/config/\" ]\nvolumeMounts:\n- name: config-volume\nmountPath: /etc/config\nvolumes:\n- name: config-volume\nconfigMap:\n# Provide the name of the ConfigMap containing the files you want\n# to add to the container\nname: special-config\nrestartPolicy: Never\nCreate the Pod:kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-volume.yaml\nWhen the pod runs, the command ls /etc/config/ produces the output below:SPECIAL_LEVEL\nSPECIAL_TYPE\nText data is exposed as files using the UTF-8 character encoding. To use some other\ncharacter encoding, use binaryData\n(see ConfigMap object for more details).Note:If there are any files in the /etc/config directory of that container image, the volume\nmount will make those files from the image inaccessible.Once you're happy to move on, delete that Pod:kubectl delete pod dapi-test-pod --now\nAdd ConfigMap data to a specific path in the VolumeUse the path field to specify the desired file path for specific ConfigMap items.\nIn this case, the SPECIAL_LEVEL item will be mounted in the config-volume volume at /etc/config/keys.pods/pod-configmap-volume-specific-key.yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: dapi-test-pod\nspec:\ncontainers:\n- name: test-container\nimage: registry.k8s.io/busybox:1.27.2\ncommand: [ \"/bin/sh\",\"-c\",\"cat /etc/config/keys\" ]\nvolumeMounts:\n- name: config-volume\nmountPath: /etc/config\nvolumes:\n- name: config-volume\nconfigMap:\nname: special-config\nitems:\n- key: SPECIAL_LEVEL\npath: keys\nrestartPolicy: Never\nCreate the Pod:kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-volume-specific-key.yaml\nWhen the pod runs, the command cat /etc/config/keys produces the output below:very\nCaution:Like before, all previous files in the /etc/config/ directory will be deleted.Delete that Pod:kubectl delete pod dapi-test-pod --now\nProject keys to specific paths and file permissionsYou can project keys to specific paths. Refer to the corresponding section in the Secrets guide for the syntax.You can set POSIX permissions for keys. Refer to the corresponding section in the Secrets guide for the syntax.Optional referencesA ConfigMap reference may be marked optional. If the ConfigMap is non-existent, the mounted\nvolume will be empty. If the ConfigMap exists, but the referenced key is non-existent, the path\nwill be absent beneath the mount point. See Optional ConfigMaps for more\ndetails.Mounted ConfigMaps are updated automaticallyWhen a mounted ConfigMap is updated, the projected content is eventually updated too.\nThis applies in the case where an optionally referenced ConfigMap comes into\nexistence after a pod has started.Kubelet checks whether the mounted ConfigMap is fresh on every periodic sync. However,\nit uses its local TTL-based cache for getting the current value of the ConfigMap. As a\nresult, the total delay from the moment when the ConfigMap is updated to the moment\nwhen new keys are projected to the pod can be as long as kubelet sync period (1\nminute by default) + TTL of ConfigMaps cache (1 minute by default) in kubelet. You\ncan trigger an immediate refresh by updating one of the pod's annotations.Note:A container using a ConfigMap as a subPath\nvolume will not receive ConfigMap updates.Understanding ConfigMaps and PodsThe ConfigMap API resource stores configuration data as key-value pairs. The data can be consumed\nin pods or provide the configurations for system components such as controllers. ConfigMap is\nsimilar to Secrets, but provides a means of working\nwith strings that don't contain sensitive information. Users and system components alike can\nstore configuration data in ConfigMap.Note:ConfigMaps should reference properties files, not replace them. Think of the ConfigMap as\nrepresenting something similar to the Linux /etc directory and its contents. For example,\nif you create a Kubernetes Volume from a ConfigMap, each\ndata item in the ConfigMap is represented by an individual file in the volume.The ConfigMap's data field contains the configuration data. As shown in the example below,\nthis can be simple (like individual properties defined using --from-literal) or complex\n(like configuration files or JSON blobs defined using --from-file).apiVersion: v1\nkind: ConfigMap\nmetadata:\ncreationTimestamp: 2016-02-18T19:14:38Z\nname: example-config\nnamespace: default\ndata:\n# example of a simple property defined using --from-literal\nexample.property.1: hello\nexample.property.2: world\n# example of a complex property defined using --from-file\nexample.property.file: |-\nproperty.1=value-1\nproperty.2=value-2\nproperty.3=value-3\nWhen kubectl creates a ConfigMap from inputs that are not ASCII or UTF-8, the tool puts\nthese into the binaryData field of the ConfigMap, and not in data. Both text and binary\ndata sources can be combined in one ConfigMap.If you want to view the binaryData keys (and their values) in a ConfigMap, you can run\nkubectl get configmap -o jsonpath='{.binaryData}' <name>.Pods can load data from a ConfigMap that uses either data or binaryData.Optional ConfigMapsYou can mark a reference to a ConfigMap as optional in a Pod specification.\nIf the ConfigMap doesn't exist, the configuration for which it provides data in the Pod\n(for example: environment variable, mounted volume) will be empty.\nIf the ConfigMap exists, but the referenced key is non-existent the data is also empty.For example, the following Pod specification marks an environment variable from a ConfigMap\nas optional:apiVersion: v1\nkind: Pod\nmetadata:\nname: dapi-test-pod\nspec:\ncontainers:\n- name: test-container\nimage: gcr.io/google_containers/busybox\ncommand: [\"/bin/sh\", \"-c\", \"env\"]\nenv:\n- name: SPECIAL_LEVEL_KEY\nvalueFrom:\nconfigMapKeyRef:\nname: a-config\nkey: akey\noptional: true # mark the variable as optional\nrestartPolicy: Never\nIf you run this pod, and there is no ConfigMap named a-config, the output is empty.\nIf you run this pod, and there is a ConfigMap named a-config but that ConfigMap doesn't have\na key named akey, the output is also empty. If you do set a value for akey in the a-config\nConfigMap, this pod prints that value and then terminates.You can also mark the volumes and files provided by a ConfigMap as optional. Kubernetes always\ncreates the mount paths for the volume, even if the referenced ConfigMap or key doesn't exist. For\nexample, the following Pod specification marks a volume that references a ConfigMap as optional:apiVersion: v1\nkind: Pod\nmetadata:\nname: dapi-test-pod\nspec:\ncontainers:\n- name: test-container\nimage: gcr.io/google_containers/busybox\ncommand: [\"/bin/sh\", \"-c\", \"ls /etc/config\"]\nvolumeMounts:\n- name: config-volume\nmountPath: /etc/config\nvolumes:\n- name: config-volume\nconfigMap:\nname: no-config\noptional: true # mark the source ConfigMap as optional\nrestartPolicy: Never\nRestrictionsYou must create the ConfigMap object before you reference it in a Pod\nspecification. Alternatively, mark the ConfigMap reference as optional in the Pod spec (see\nOptional ConfigMaps). If you reference a ConfigMap that doesn't exist\nand you don't mark the reference as optional, the Pod won't start. Similarly, references\nto keys that don't exist in the ConfigMap will also prevent the Pod from starting, unless\nyou mark the key references as optional.If you use envFrom to define environment variables from ConfigMaps, keys that are considered\ninvalid will be skipped. The pod will be allowed to start, but the invalid names will be\nrecorded in the event log (InvalidVariableNames). The log message lists each skipped\nkey. For example:kubectl get events\nThe output is similar to this:LASTSEEN FIRSTSEEN COUNT NAME\nKIND\nSUBOBJECT\nTYPE\nREASON\nSOURCE\nMESSAGE\n0s\n0s\n1\ndapi-test-pod Pod\nWarning\nInvalidEnvironmentVariableNames\n{kubelet, 127.0.0.1}\nKeys [1badkey, 2alsobad] from the EnvFrom configMap default/myconfig were skipped since they are considered invalid environment variable names.\nConfigMaps reside in a specific Namespace.\nPods can only refer to ConfigMaps that are in the same namespace as the Pod.You can't use ConfigMaps for\nstatic pods, because the\nkubelet does not support this.Cleaning upDelete the ConfigMaps and Pods that you made:kubectl delete configmaps/game-config configmaps/game-config-2 configmaps/game-config-3 \\\nconfigmaps/game-config-env-file\nkubectl delete pod dapi-test-pod --now\n# You might already have removed the next set\nkubectl delete configmaps/special-config configmaps/env-config\nkubectl delete configmap -l 'game-config in (config-4,config-5)'\nRemove the kustomization.yaml file that you used to generate the ConfigMap:rm kustomization.yaml\nIf you created a directory configure-pod-container and no longer need it, you should remove that too,\nor move it into the trash can / deleted files location.rm -r configure-pod-container\nWhat's nextFollow a real world example of\nConfiguring Redis using a ConfigMap.Follow an example of Updating configuration via a ConfigMap.FeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified November 27, 2023 at 1:38 AM PST: [en] config-pod-configmap add cleanup step. (2d13865044) Edit this page\nCreate child page\nCreate an issue\nPrint entire sectionBefore you beginCreate a ConfigMapCreate a ConfigMap using kubectl create configmapCreate a ConfigMap from generatorInterim cleanupDefine container environment variables using ConfigMap dataDefine a container environment variable with data from a single ConfigMapDefine container environment variables with data from multiple ConfigMapsConfigure all key-value pairs in a ConfigMap as container environment variablesUse ConfigMap-defined environment variables in Pod commandsAdd ConfigMap data to a VolumePopulate a Volume with data stored in a ConfigMapAdd ConfigMap data to a specific path in the VolumeProject keys to specific paths and file permissionsOptional referencesMounted ConfigMaps are updated automaticallyUnderstanding ConfigMaps and PodsOptional ConfigMapsRestrictionsCleaning upWhat's next\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "kubernetes-docs"
  },
  {
    "url": "https://kubernetes.io/docs/tasks/debug/",
    "content": "Monitoring, Logging, and Debugging | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u4e2d\u6587 (Chinese)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPortugu\u00eas (Portuguese)\nEspa\u00f1ol (Spanish)\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationTasksMonitoring, Logging, and DebuggingMonitoring, Logging, and DebuggingSet up monitoring and logging to troubleshoot a cluster, or debug a containerized application.Sometimes things go wrong. This guide helps you gather the relevant information and resolve issues. It has four sections:Debugging your application - Useful\nfor users who are deploying code into Kubernetes and wondering why it is not working.Debugging your cluster - Useful\nfor cluster administrators and operators troubleshooting issues with the Kubernetes cluster itself.Logging in Kubernetes - Useful\nfor cluster administrators who want to set up and manage logging in Kubernetes.Monitoring in Kubernetes - Useful\nfor cluster administrators who want to enable monitoring in a Kubernetes cluster.You should also check the known issues for the release\nyou're using.Getting helpIf your problem isn't answered by any of the guides above, there are variety of\nways for you to get help from the Kubernetes community.QuestionsThe documentation on this site has been structured to provide answers to a wide\nrange of questions. Concepts explain the Kubernetes\narchitecture and how each component works, while Setup provides\npractical instructions for getting started. Tasks show how to\naccomplish commonly used tasks, and Tutorials are more\ncomprehensive walkthroughs of real-world, industry-specific, or end-to-end\ndevelopment scenarios. The Reference section provides\ndetailed documentation on the Kubernetes API\nand command-line interfaces (CLIs), such as kubectl.Help! My question isn't covered! I need help now!Stack Exchange, Stack Overflow, or Server FaultIf you have questions related to software development for your containerized app,\nyou can ask those on Stack Overflow.If you have Kubernetes questions related to cluster management or configuration,\nyou can ask those on\nServer Fault.There are also several more specific Stack Exchange network sites which might\nbe the right place to ask Kubernetes questions in areas such as\nDevOps,\nSoftware Engineering,\nor InfoSec.Someone else from the community may have already asked a similar question or\nmay be able to help with your problem.The Kubernetes team will also monitor\nposts tagged Kubernetes.\nIf there aren't any existing questions that help, please ensure that your question\nis on-topic on Stack Overflow,\nServer Fault, or the Stack Exchange\nNetwork site you're asking on, and read through the guidance on\nhow to ask a new question,\nbefore asking a new one!SlackMany people from the Kubernetes community hang out on Kubernetes Slack in the #kubernetes-users channel.\nSlack requires registration; you can request an invitation,\nand registration is open to everyone). Feel free to come and ask any and all questions.\nOnce registered, access the Kubernetes organisation in Slack\nvia your web browser or via Slack's own dedicated app.Once you are registered, browse the growing list of channels for various subjects of\ninterest. For example, people new to Kubernetes may also want to join the\n#kubernetes-novice channel. As another example, developers should join the\n#kubernetes-contributors channel.There are also many country specific / local language channels. Feel free to join\nthese channels for localized support and info:Country / language specific Slack channelsCountryChannelsChina#cn-users, #cn-eventsFinland#fi-usersFrance#fr-users, #fr-eventsGermany#de-users, #de-eventsIndia#in-users, #in-eventsItaly#it-users, #it-eventsJapan#jp-users, #jp-eventsKorea#kr-usersNetherlands#nl-usersNorway#norw-usersPoland#pl-usersRussia#ru-usersSpain#es-usersSweden#se-usersTurkey#tr-users, #tr-eventsForumYou're welcome to join the official Kubernetes Forum: discuss.kubernetes.io.Bugs and feature requestsIf you have what looks like a bug, or you would like to make a feature request,\nplease use the GitHub issue tracking system.Before you file an issue, please search existing issues to see if your issue is\nalready covered.If filing a bug, please include detailed information about how to reproduce the\nproblem, such as:Kubernetes version: kubectl versionCloud provider, OS distro, network configuration, and container runtime versionSteps to reproduce the problemFeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified August 09, 2025 at 2:51 PM PST: Updating doc with Logging and Monitoring information (f5d051a432) Edit this page\nCreate child page\nCreate an issue\nPrint entire sectionGetting helpQuestionsHelp! My question isn't covered! I need help now!Stack Exchange, Stack Overflow, or Server FaultSlackForumBugs and feature requests\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "kubernetes-docs"
  },
  {
    "url": "https://kubernetes.io/docs/reference/glossary/?fundamental=true",
    "content": "Glossary | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationReferenceGlossaryGlossaryThis glossary is intended to be a comprehensive, standardized list of Kubernetes terminology. It includes technical terms that are specific to Kubernetes, as well as more general terms that provide useful context.Filter terms according to their tags.The inner components of Kubernetes.Related to Kubernetes open-source development.A resource type that Kubernetes supports by default.Supported customizations of Kubernetes.Relevant for a first-time user of Kubernetes.How Kubernetes components talk to each other (and to programs outside the cluster).Starting and maintaining Kubernetes.Keeping Kubernetes applications safe and secure.How Kubernetes applications handle persistent data.Software that makes Kubernetes easier or better to use.Represents a common type of Kubernetes user.Applications running on Kubernetes.Architecture\nCommunity\nCore Object\nExtension\nFundamental\nNetworking\nOperation\nSecurity\nStorage\nTool\nUser Type\nWorkload\nSelect all\nDeselect allClick on the [+] indicators below to get a longer explanation for any particular term.Add-onsResources that extend the functionality of Kubernetes.[+]Installing addons explains more about using add-ons with your cluster, and lists some popular add-ons.Admission ControllerA piece of code that intercepts requests to the Kubernetes API server prior to persistence of the object.[+]Admission controllers are configurable for the Kubernetes API server and may be \"validating\", \"mutating\", or\nboth. Any admission controller may reject the request. Mutating controllers may modify the objects they admit;\nvalidating controllers may not.Admission controllers in the Kubernetes documentationAffinityIn Kubernetes, affinity is a set of rules that give hints to the scheduler about where to place pods.[+]There are two kinds of affinity:node affinitypod-to-pod affinityThe rules are defined using the Kubernetes labels,\nand selectors specified in pods,\nand they can be either required or preferred, depending on how strictly you want the scheduler to enforce them.Aggregation LayerThe aggregation layer lets you install additional Kubernetes-style APIs in your cluster.[+]When you've configured the Kubernetes API Server to support additional APIs, you can add APIService objects to \"claim\" a URL path in the Kubernetes API.AnnotationA key-value pair that is used to attach arbitrary non-identifying metadata to objects.[+]The metadata in an annotation can be small or large, structured or unstructured, and can include characters not permitted by labels. Clients such as tools and libraries can retrieve this metadata.API GroupA set of related paths in Kubernetes API.[+]You can enable or disable each API group by changing the configuration of your API server. You can also disable or enable paths to specific\nresources. An API group makes it easier to extend the Kubernetes API.\nThe API group is specified in a REST path and in the apiVersion field of a serialized object.Read API Group for more information.API resourceAlso known as: ResourceAn entity in the Kubernetes type system, corresponding to an endpoint on the Kubernetes API.\nA resource typically represents an object.\nSome resources represent an operation on other objects, such as a permission check.[+]Each resource represents an HTTP endpoint (URI) on the Kubernetes API server, defining the schema for the objects or operations on that resource.API serverAlso known as: kube-apiserverThe API server is a component of the Kubernetes\ncontrol plane that exposes the Kubernetes API.\nThe API server is the front end for the Kubernetes control plane.[+]The main implementation of a Kubernetes API server is kube-apiserver.\nkube-apiserver is designed to scale horizontally\u2014that is, it scales by deploying more instances.\nYou can run several instances of kube-apiserver and balance traffic between those instances.API-initiated evictionAPI-initiated eviction is the process by which you use the Eviction API\nto create an Eviction object that triggers graceful pod termination.[+]You can request eviction either by directly calling the Eviction API\nusing a client of the kube-apiserver, like the kubectl drain command.\nWhen an Eviction object is created, the API server terminates the Pod.API-initiated evictions respect your configured PodDisruptionBudgets\nand terminationGracePeriodSeconds.API-initiated eviction is not the same as node-pressure eviction.See API-initiated eviction for more information.App ContainerApplication containers (or app containers) are the containers in a pod that are started after any init containers have completed.[+]An init container lets you separate initialization details that are important for the overall\nworkload, and that don't need to keep running\nonce the application container has started.\nIf a pod doesn't have any init containers configured, all the containers in that pod are app containers.Application ArchitectA person responsible for the high-level design of an application.[+]An architect ensures that an app's implementation allows it to interact with its surrounding components in a scalable, maintainable way. Surrounding components include databases, logging infrastructure, and other microservices.Application DeveloperA person who writes an application that runs in a Kubernetes cluster.[+]An application developer focuses on one part of an application. The scale of their focus may vary significantly in size.ApplicationsThe layer where various containerized applications run. [+]The layer where various containerized applications run.ApproverA person who can review and approve Kubernetes code contributions.[+]While code review is focused on code quality and correctness, approval is focused on the holistic acceptance of a contribution. Holistic acceptance includes backwards/forwards compatibility, adhering to API and flag conventions, subtle performance and correctness issues, interactions with other parts of the system, and others. Approver status is scoped to a part of the codebase. Approvers were previously referred to as maintainers.cAdvisorcAdvisor (Container Advisor) provides container users an understanding of the resource\nusage and performance characteristics of their running containers.[+]It is a running daemon that collects, aggregates, processes, and exports information about running containers. Specifically, for each container it keeps resource isolation parameters, historical resource usage, histograms of complete historical resource usage and network statistics. This data is exported by container and machine-wide.CertificateA cryptographically secure file used to validate access to the Kubernetes cluster.[+]Certificates enable applications within a Kubernetes cluster to access the Kubernetes API securely. Certificates validate that clients are allowed to access the API.cgroup (control group)A group of Linux processes with optional resource isolation, accounting and limits.[+]cgroup is a Linux kernel feature that limits, accounts for, and isolates the resource usage (CPU, memory, disk I/O, network) for a collection of processes.CIDRCIDR (Classless Inter-Domain Routing) is a notation for describing blocks of IP addresses and is used heavily in various networking configurations.[+]In the context of Kubernetes, each Node is assigned a range of IP addresses through the start address and a subnet mask using CIDR. This allows Nodes to assign each Pod a unique IP address. Although originally a concept for IPv4, CIDR has also been expanded to include IPv6.CLA (Contributor License Agreement)Terms under which a contributor grants a license to an open source project for their contributions.[+]CLAs help resolve legal disputes involving contributed material and intellectual property (IP).Cloud Controller ManagerA Kubernetes control plane component\nthat embeds cloud-specific control logic. The cloud controller manager lets you link your\ncluster into your cloud provider's API, and separates out the components that interact\nwith that cloud platform from components that only interact with your cluster.[+]By decoupling the interoperability logic between Kubernetes and the underlying cloud\ninfrastructure, the cloud-controller-manager component enables cloud providers to release\nfeatures at a different pace compared to the main Kubernetes project.Cloud Native Computing Foundation (CNCF)The Cloud Native Computing Foundation (CNCF) builds sustainable ecosystems and\nfosters a community around projects that\norchestrate containers as part of a microservices architecture.Kubernetes is a CNCF project.[+]The CNCF is a sub-foundation of the Linux Foundation.\nIts mission is to make cloud native computing ubiquitous.Cloud ProviderAlso known as: Cloud Service ProviderA business or other organization that offers a cloud computing platform.[+]Cloud providers, sometimes called Cloud Service Providers (CSPs), offer\ncloud computing platforms or services.Many cloud providers offer managed infrastructure (also called\nInfrastructure as a Service or IaaS).\nWith managed infrastructure the cloud provider is responsible for\nservers, storage, and networking while you manage layers on top of that\nsuch as running a Kubernetes cluster.You can also find Kubernetes as a managed service; sometimes called\nPlatform as a Service, or PaaS. With managed Kubernetes, your\ncloud provider is responsible for the Kubernetes control plane as well\nas the nodes and the\ninfrastructure they rely on: networking, storage, and possibly other\nelements such as load balancers.ClusterA set of worker machines, called nodes,\nthat run containerized applications. Every cluster has at least one worker node.[+]The worker node(s) host the Pods that are\nthe components of the application workload. The\ncontrol plane manages the worker\nnodes and the Pods in the cluster. In production environments, the control plane usually\nruns across multiple computers and a cluster usually runs multiple nodes, providing\nfault-tolerance and high availability.Cluster ArchitectA person who designs infrastructure that involves one or more Kubernetes clusters.[+]Cluster architects are concerned with best practices for distributed systems, for example: high availability and security.Cluster InfrastructureThe infrastructure layer provides and maintains VMs, networking, security groups and others. [+]The infrastructure layer provides and maintains VMs, networking, security groups and others.Cluster OperationsThe work involved in managing a Kubernetes cluster: managing\nday-to-day operations, and co-ordinating upgrades.[+]Examples of cluster operations work include: deploying new Nodes to\nscale the cluster; performing software upgrades; implementing security\ncontrols; adding or removing storage; configuring cluster networking;\nmanaging cluster-wide observability; and responding to events.Cluster OperatorA person who configures, controls, and monitors clusters.[+]Their primary responsibility is keeping a cluster up and running, which may involve periodic maintenance activities or upgrades.Note:Cluster operators are different from the Operator pattern that extends the Kubernetes API.Code ContributorA person who develops and contributes code to the Kubernetes open source codebase.[+]They are also an active community member who participates in one or more Special Interest Groups (SIGs).Common Expression LanguageAlso known as: CELA general-purpose expression language that's designed to be fast, portable, and\nsafe to execute.[+]In Kubernetes, CEL can be used to run queries and perform fine-grained\nfiltering. For example, you can use CEL expressions with\ndynamic admission control\nto filter for specific fields in requests, and with\ndynamic resource allocation (DRA)\nto select resources based on specific attributes.ConfigMapAn API object used to store non-confidential data in key-value pairs.\nPods can consume ConfigMaps as\nenvironment variables, command-line arguments, or as configuration files in a\nvolume.[+]A ConfigMap allows you to decouple environment-specific configuration from your container images, so that your applications are easily portable.ContainerA lightweight and portable executable image that contains software and all of its dependencies.[+]Containers decouple applications from underlying host infrastructure to make deployment easier in different cloud or OS environments, and for easier scaling.\nThe applications that run inside containers are called containerized applications. The process of bundling these applications and their dependencies into a container image is called containerization.Container Environment VariablesContainer environment variables are name=value pairs that provide useful information into containers running in a pod[+]Container environment variables provide information that is required by the running containerized applications along with information about important related details to the containers. For example, file system details, information about the container itself, and other cluster resources such as service endpoints.Container Lifecycle HooksThe lifecycle hooks expose events in the Container management lifecycle and let the user run code when the events occur.[+]Two hooks are exposed to Containers: PostStart which executes immediately after a container is created and PreStop which is blocking and is called immediately before a container is terminated.Container network interface (CNI)Container network interface (CNI) plugins are a type of Network plugin that adheres to the appc/CNI specification.[+]For information on Kubernetes and CNI, see Network Plugins.Container RuntimeA fundamental component that empowers Kubernetes to run containers effectively.\nIt is responsible for managing the execution and lifecycle of containers within the Kubernetes environment.[+]Kubernetes supports container runtimes such as\ncontainerd, CRI-O,\nand any other implementation of the Kubernetes CRI (Container Runtime\nInterface).Container Runtime Interface (CRI)The main protocol for the communication between the kubelet and Container Runtime.[+]The Kubernetes Container Runtime Interface (CRI) defines the main\ngRPC protocol for the communication between the\nnode components\nkubelet and\ncontainer runtime.Container Storage Interface (CSI)The Container Storage Interface (CSI) defines a standard interface to expose storage systems to containers.[+]CSI allows vendors to create custom storage plugins for Kubernetes without adding them to the Kubernetes repository (out-of-tree plugins). To use a CSI driver from a storage provider, you must first deploy it to your cluster. You will then be able to create a Storage Class that uses that CSI driver.CSI in the Kubernetes documentationList of available CSI driverscontainerdA container runtime with an emphasis on simplicity, robustness and portability[+]containerd is a container runtime\nthat runs as a daemon on Linux or Windows. containerd takes care of fetching and\nstoring container images, executing containers, providing network access, and more.ContributorSomeone who donates code, documentation, or their time to help the Kubernetes project or community.[+]Contributions include pull requests (PRs), issues, feedback, special interest groups (SIG) participation, or organizing community events.Control PlaneThe container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.[+]This layer is composed by many different components, such as (but not restricted to):etcdAPI ServerSchedulerController ManagerCloud Controller ManagerThese components can be run as traditional operating system services (daemons) or as containers. The hosts running these components were historically called masters.ControllerIn Kubernetes, controllers are control loops that watch the state of your\ncluster, then make or request\nchanges where needed.\nEach controller tries to move the current cluster state closer to the desired\nstate.[+]Controllers watch the shared state of your cluster through the\napiserver (part of the\nControl Plane).Some controllers also run inside the control plane, providing control loops that\nare core to Kubernetes' operations. For example: the deployment controller, the\ndaemonset controller, the namespace controller, and the persistent volume\ncontroller (and others) all run within the\nkube-controller-manager.CRI-OA tool that lets you use OCI container runtimes with Kubernetes CRI.[+]CRI-O is an implementation of the Container Runtime Interface (CRI)\nto enable using container\nruntimes that are compatible with the Open Container Initiative (OCI)\nruntime spec.Deploying CRI-O allows Kubernetes to use any OCI-compliant runtime as the container\nruntime for running Pods, and to fetch\nOCI container images from remote registries.CronJobManages a Job that runs on a periodic schedule.[+]Similar to a line in a crontab file, a CronJob object specifies a schedule using the cron format.CustomResourceDefinitionA kind of API object that defines a new custom API to add\nto your Kubernetes API server, without building a complete custom server.[+]CustomResourceDefinitions let you extend the Kubernetes API for your environment if the built-in\nAPI resources can't meet your needs.DaemonSetEnsures a copy of a Pod is running across a set of nodes in a cluster.[+]Used to deploy system daemons such as log collectors and monitoring agents that typically must run on every Node.Data PlaneThe layer that provides capacity such as CPU, memory, network, and storage so that the containers can run and connect to a network. [+]The layer that provides capacity such as CPU, memory, network, and storage so that the containers can run and connect to a network.DeploymentAn API object that manages a replicated application, typically by running Pods with no local state.[+]Each replica is represented by a Pod, and the Pods are distributed among the\nnodes of a cluster.\nFor workloads that do require local state, consider using a StatefulSet.Developer (disambiguation)May refer to: Application Developer, Code Contributor, or Platform Developer.[+]This overloaded term may have different meanings depending on the contextDeviceOne or more\ninfrastructure resources\nthat are directly or indirectly attached to your\nnodes.[+]Devices might be commercial products like GPUs, or custom hardware like\nASIC boards.\nAttached devices usually require device drivers that let Kubernetes\nPods access the devices.Device PluginDevice plugins run on worker\nNodes and provide\nPods with access to\ninfrastructure resources,\nsuch as local hardware, that require vendor-specific initialization or setup\nsteps.[+]Device plugins advertise resources to the\nkubelet, so that workload\nPods can access hardware features that relate to the Node where that Pod is running.\nYou can deploy a device plugin as a DaemonSet,\nor install the device plugin software directly on each target Node.See\nDevice Plugins\nfor more information.DeviceClassA category of devices in the\ncluster that can be used with dynamic resource allocation (DRA).[+]Administrators or device owners use DeviceClasses to define a set of devices\nthat can be claimed and used in workloads. Devices are claimed by creating\nResourceClaims\nthat filter for specific device parameters in a DeviceClass.For more information, see\nDynamic Resource AllocationDisruptionDisruptions are events that lead to one or more\nPods going out of service.\nA disruption has consequences for workload management resources,\nsuch as Deployment, that rely on the affected\nPods.[+]If you, as cluster operator, destroy a Pod that belongs to an application,\nKubernetes terms that a voluntary disruption. If a Pod goes offline\nbecause of a Node failure, or an outage affecting a wider failure zone,\nKubernetes terms that an involuntary disruption.See Disruptions for more information.DockerDocker (specifically, Docker Engine) is a software technology providing operating-system-level virtualization also known as containers.[+]Docker uses the resource isolation features of the Linux kernel such as cgroups and kernel namespaces, and a union-capable file system such as OverlayFS and others to allow independent containers to run within a single Linux instance, avoiding the overhead of starting and maintaining virtual machines (VMs).DockershimThe dockershim is a component of Kubernetes version 1.23 and earlier. It allows the kubelet\nto communicate with Docker Engine.[+]Starting with version 1.24, dockershim has been removed from Kubernetes. For more information, see Dockershim FAQ.Downstream (disambiguation)May refer to: code in the Kubernetes ecosystem that depends upon the core Kubernetes codebase or a forked repo.[+]In the Kubernetes Community: Conversations often use downstream to mean the ecosystem, code, or third-party tools that rely on the core Kubernetes codebase. For example, a new feature in Kubernetes may be adopted by applications downstream to improve their functionality.In GitHub or git: The convention is to refer to a forked repo as downstream, whereas the source repo is considered upstream.Downward APIKubernetes' mechanism to expose Pod and container field values to code running in a container.[+]It is sometimes useful for a container to have information about itself, without\nneeding to make changes to the container code that directly couple it to Kubernetes.The Kubernetes downward API allows containers to consume information about themselves\nor their context in a Kubernetes cluster. Applications in containers can have\naccess to that information, without the application needing to act as a client of\nthe Kubernetes API.There are two ways to expose Pod and container fields to a running container:using environment variablesusing a downwardAPI volumeTogether, these two ways of exposing Pod and container fields are called the downward API.DrainThe process of safely evicting Pods from a Node to prepare it for maintenance or removal from a cluster.[+]The kubectl drain command is used to mark a Node as going out of service.\nWhen executed, it evicts all Pods from the Node.\nIf an eviction request is temporarily rejected, kubectl drain retries until all Pods are terminated or a configurable timeout is reached.DurationA string value representing an amount of time.[+]The format of a (Kubernetes) duration is based on the\ntime.Duration type from the Go programming language.In Kubernetes APIs that use durations, the value is expressed as series of a non-negative\nintegers combined with a time unit suffix. You can have more than one time quantity and\nthe duration is the sum of those time quantities.\nThe valid time units are \"ns\", \"\u00b5s\" (or \"us\"), \"ms\", \"s\", \"m\", and \"h\".For example: 5s represents a duration of five seconds, and 1m30s represents a duration\nof one minute and thirty seconds.Dynamic Resource AllocationAlso known as: DRAA Kubernetes feature that lets you request and share resources among Pods.\nThese resources are often attached\ndevices like hardware\naccelerators.[+]With DRA, device drivers and cluster admins define device classes that are\navailable to claim in workloads. Kubernetes allocates matching devices to\nspecific claims and places the corresponding Pods on nodes that can access the\nallocated devices.Dynamic Volume ProvisioningAllows users to request automatic creation of storage Volumes.[+]Dynamic provisioning eliminates the need for cluster administrators to pre-provision storage. Instead, it automatically provisions storage by user request. Dynamic volume provisioning is based on an API object, StorageClass, referring to a Volume Plugin that provisions a Volume and the set of parameters to pass to the Volume Plugin.EndpointsA deprecated API that represents the set of all endpoints for a\nService.[+]Since v1.21, Kubernetes uses\nEndpointSlices\nrather than Endpoints; the original Endpoints API was deprecated due to\nconcerns about scalability.To learn more about Endpoints, read Endpoints.EndpointSliceEndpointSlices track the IP addresses of backend endpoints.\nEndpointSlices are normally associated with a\nService and the backend endpoints typically represent\nPods.[+]One Service can be backed by multiple Pods. Kubernetes represents the backing endpoints of a Service\nwith a set of EndpointSlices that are associated with that Service.\nThe backing endpoints are usually, but not always, pods running in the cluster.The control plane usually manages EndpointSlices for you automatically. However,\nEndpointSlices can be defined manually for Services without\nselectors specified.Ephemeral ContainerA Container type that you can temporarily run inside a Pod.[+]If you want to investigate a Pod that's running with problems, you can add an ephemeral container to that Pod and carry out diagnostics.\nEphemeral containers have no resource or scheduling guarantees,\nand you should not use them to run any part of the workload itself.Ephemeral containers are not supported by static pods.etcdConsistent and highly-available key value store used as Kubernetes' backing store for all cluster data.[+]If your Kubernetes cluster uses etcd as its backing store, make sure you have a\nback up plan\nfor the data.You can find in-depth information about etcd in the official documentation.EventA Kubernetes object that describes state changes\nor notable occurrences in the cluster.[+]Events have a limited retention time and triggers and messages may evolve with time.\nEvent consumers should not rely on the timing of an event with a given reason reflecting a consistent underlying trigger,\nor the continued existence of events with that reason.Events should be treated as informative, best-effort, supplemental data.In Kubernetes, auditing generates a different kind of\nEvent record (API group audit.k8s.io).EvictionEviction is the process of terminating one or more Pods on Nodes.[+]There are two kinds of eviction:Node-pressure evictionAPI-initiated evictionExtensionsExtensions are software components that extend and deeply integrate with Kubernetes to support new types of hardware.[+]Many cluster administrators use a hosted or distribution instance of Kubernetes. These clusters\ncome with extensions pre-installed. As a result, most Kubernetes users will not need to install\nextensions and even fewer users will need to author new ones.Feature gateFeature gates are a set of keys (opaque string values) that you can use to control which\nKubernetes features are enabled in your cluster.[+]You can turn these features on or off using the --feature-gates command line flag on each Kubernetes component.\nEach Kubernetes component lets you enable or disable a set of feature gates that are relevant to that component.\nThe Kubernetes documentation lists all current\nfeature gates and what they control.FinalizerFinalizers are namespaced keys that tell Kubernetes to wait until specific\nconditions are met before it fully deletes resources\nthat are marked for deletion.\nFinalizers alert controllers\nto clean up resources the deleted object owned.[+]When you tell Kubernetes to delete an object that has finalizers specified for\nit, the Kubernetes API marks the object for deletion by populating .metadata.deletionTimestamp,\nand returns a 202 status code (HTTP \"Accepted\"). The target object remains in a terminating state while the\ncontrol plane, or other components, take the actions defined by the finalizers.\nAfter these actions are complete, the controller removes the relevant finalizers\nfrom the target object. When the metadata.finalizers field is empty,\nKubernetes considers the deletion complete and deletes the object.You can use finalizers to control garbage collection\nof resources. For example, you can define a finalizer to clean up related\nAPI resources or infrastructure before the controller\ndeletes the object being finalized.FlexVolumeFlexVolume is a deprecated interface for creating out-of-tree volume plugins. The Container Storage Interface is a newer interface that addresses several problems with FlexVolume.[+]FlexVolumes enable users to write their own drivers and add support for their volumes in Kubernetes. FlexVolume driver binaries and dependencies must be installed on host machines. This requires root access. The Storage SIG suggests implementing a CSI driver if possible since it addresses the limitations with FlexVolumes.FlexVolume in the Kubernetes documentationMore information on FlexVolumesVolume Plugin FAQ for Storage VendorsGarbage CollectionGarbage collection is a collective term for the various mechanisms Kubernetes uses to clean up\ncluster resources.[+]Kubernetes uses garbage collection to clean up resources like\nunused containers and images,\nfailed Pods,\nobjects owned by the targeted resource,\ncompleted Jobs, and resources\nthat have expired or failed.Gateway APIA family of API kinds for modeling service networking in Kubernetes.[+]Gateway API provides a family of extensible, role-oriented, protocol-aware\nAPI kinds for modeling service networking in Kubernetes.Group Version ResourceAlso known as: GVRMeans of representing specific Kubernetes APIs uniquely.[+]Group Version Resources (GVRs) specify the API group, API version, and resource (name for the object kind as it appears in the URI) associated with accessing a particular id of object in Kubernetes.\nGVRs let you define and distinguish different Kubernetes objects, and to specify a way of accessing\nobjects that is stable even as APIs change.In this usage, resource refers to an HTTP resource. Because some APIs are namespaced, a GVR may\nnot refer to a specific API resource.Helm ChartA package of pre-configured Kubernetes configurations that can be managed with the Helm tool.[+]Charts provide a reproducible way of creating and sharing Kubernetes applications.\nA single chart can be used to deploy something simple, like a memcached Pod, or something complex, like a full web app stack with HTTP servers, databases, caches, and so on.Horizontal Pod AutoscalerAlso known as: HPAAn object that automatically scales the number of Pod replicas,\nbased on targeted resource utilization or custom metric targets.[+]HorizontalPodAutoscaler (HPA) is typically used with Deployments, or ReplicaSets. It cannot be applied to objects that cannot be scaled, for example DaemonSets.HostAliasesA HostAliases is a mapping between the IP address and hostname to be injected into a Pod's hosts file.[+]HostAliases is an optional list of hostnames and IP addresses that will be injected into the Pod's hosts file if specified. This is only valid for non-hostNetwork Pods.ImageStored instance of a Container that holds a set of software needed to run an application.[+]A way of packaging software that allows it to be stored in a container registry, pulled to a local system, and run as an application. Meta data is included in the image that can indicate what executable to run, who built it, and other information.Immutable InfrastructureImmutable Infrastructure refers to computer infrastructure (virtual machines, containers, network appliances) that cannot be changed once deployed.[+]Immutability can be enforced by an automated process that overwrites unauthorized changes or through a system that won\u2019t allow changes in the first place.\nContainers are a good example of immutable infrastructure because persistent changes to containers\ncan only be made by creating a new version of the container or recreating the existing container from its image.By preventing or identifying unauthorized changes, immutable infrastructures make it easier to identify and mitigate security risks.\nOperating such a system becomes a lot more straightforward because administrators can make assumptions about it.\nAfter all, they know no one made mistakes or changes they forgot to communicate.\nImmutable infrastructure goes hand-in-hand with infrastructure as code where all automation needed\nto create infrastructure is stored in version control (such as Git).\nThis combination of immutability and version control means that there is a durable audit log of every authorized change to a system.IngressAn API object that manages external access to the services in a cluster, typically HTTP.[+]Ingress may provide load balancing, SSL termination and name-based virtual hosting.Init ContainerOne or more initialization containers that must run to completion before any app containers run.[+]Initialization (init) containers are like regular app containers, with one difference: init containers must run to completion before any app containers can start. Init containers run in series: each init container must run to completion before the next init container begins.Unlike sidecar containers, init containers do not remain running after Pod startup.For more information, read init containers.IstioAn open platform (not Kubernetes-specific) that provides a uniform way to integrate microservices, manage traffic flow, enforce policies, and aggregate telemetry data.[+]Adding Istio does not require changing application code. It is a layer of infrastructure between a service and the network, which when combined with service deployments, is commonly referred to as a service mesh. Istio's control plane abstracts away the underlying cluster management platform, which may be Kubernetes, Mesosphere, etc.JobA finite or batch task that runs to completion.[+]Creates one or more Pod objects and ensures that a specified number of them successfully terminate. As Pods successfully complete, the Job tracks the successful completions.JSON Web Token (JWT)A means of representing claims to be transferred between two parties.[+]JWTs can be digitally signed and encrypted. Kubernetes uses JWTs as\nauthentication tokens to verify the identity of entities that want to perform\nactions in a cluster.kOps (Kubernetes Operations)kOps will not only help you create, destroy, upgrade and maintain production-grade, highly available, Kubernetes cluster, but it will also provision the necessary cloud infrastructure.[+]Note:AWS (Amazon Web Services) is currently officially supported, with DigitalOcean, GCE and OpenStack in beta support, and Azure in alpha.kOps is an automated provisioning system:Fully automated installationUses DNS to identify clustersSelf-healing: everything runs in Auto-Scaling GroupsMultiple OS support (Amazon Linux, Debian, Flatcar, RHEL, Rocky and Ubuntu)High-Availability supportCan directly provision, or generate terraform manifestskube-controller-managerControl plane component that runs controller processes.[+]Logically, each controller is a separate process, but to reduce complexity, they are all compiled into a single binary and run in a single process.kube-proxykube-proxy is a network proxy that runs on each\nnode in your cluster,\nimplementing part of the Kubernetes\nService concept.[+]kube-proxy\nmaintains network rules on nodes. These network rules allow network\ncommunication to your Pods from network sessions inside or outside of\nyour cluster.kube-proxy uses the operating system packet filtering layer if there is one\nand it's available. Otherwise, kube-proxy forwards the traffic itself.kube-schedulerControl plane component that watches for newly created\nPods with no assigned\nnode, and selects a node for them\nto run on.[+]Factors taken into account for scheduling decisions include:\nindividual and collective resource\nrequirements, hardware/software/policy constraints, affinity and anti-affinity specifications,\ndata locality, inter-workload interference, and deadlines.KubeadmA tool for quickly installing Kubernetes and setting up a secure cluster.[+]You can use kubeadm to install both the control plane and the worker node components.KubectlAlso known as: kubectlCommand line tool for communicating with a Kubernetes cluster's\ncontrol plane,\nusing the Kubernetes API.[+]You can use kubectl to create, inspect, update, and delete Kubernetes objects.In English, kubectl is (officially) pronounced /kju\u02d0b/ /k\u0259n\u02c8t\u0279\u0259\u028al/ (like \"cube control\").KubeletAn agent that runs on each node in the cluster. It makes sure that containers are running in a Pod.[+]The kubelet takes a set of PodSpecs that\nare provided through various mechanisms and ensures that the containers described in those\nPodSpecs are running and healthy. The kubelet doesn't manage containers which were not created by\nKubernetes.Kubernetes APIThe application that serves Kubernetes functionality through a RESTful interface and stores the state of the cluster.[+]Kubernetes resources and \"records of intent\" are all stored as API objects, and modified via RESTful calls to the API. The API allows configuration to be managed in a declarative way. Users can interact with the Kubernetes API directly, or via tools like kubectl. The core Kubernetes API is flexible and can also be extended to support custom resources.LabelTags objects with identifying attributes that are meaningful and relevant to users.[+]Labels are key/value pairs that are attached to objects such as Pods. They are used to organize and to select subsets of objects.LimitRangeConstraints resource consumption per container or Pod,\nspecified for a particular namespace.[+]A LimitRange either limits the quantity of API resources\nthat can be created (for a particular resource type),\nor the amount of infrastructure resources\nthat may be requested/consumed by individual containers or Pods within a namespace.LoggingLogs are the list of events that are logged by cluster or application.[+]Application and systems logs can help you understand what is happening inside your cluster. The logs are particularly useful for debugging problems and monitoring cluster activity.Managed ServiceA software offering maintained by a third-party provider.[+]Some examples of Managed Services are AWS EC2, Azure SQL Database, and\nGCP Pub/Sub, but they can be any software offering that can be used by an application.ManifestSpecification of a Kubernetes API object in JSON\nor YAML format.[+]A manifest specifies the desired state of an object that Kubernetes will maintain when you apply the manifest.\nFor YAML format, each file can contain multiple manifests.MasterLegacy term, used as synonym for nodes hosting the control plane.[+]The term is still being used by some provisioning tools, such as kubeadm, and managed services, to label nodes with kubernetes.io/role and control placement of control plane pods.MemberA continuously active contributor in the K8s community.[+]Members can have issues and PRs assigned to them and participate in special interest groups (SIGs) through GitHub teams. Pre-submit tests are automatically run for members' PRs. A member is expected to remain an active contributor to the community.MinikubeA tool for running Kubernetes locally.[+]Minikube runs an all-in-one or a multi-node local Kubernetes cluster inside a VM on your computer.\nYou can use Minikube to\ntry Kubernetes in a learning environment.Mirror PodA pod object that a kubelet uses\nto represent a static pod[+]When the kubelet finds a static pod in its configuration, it automatically tries to\ncreate a Pod object on the Kubernetes API server for it. This means that the pod\nwill be visible on the API server, but cannot be controlled from there.(For example, removing a mirror pod will not stop the kubelet daemon from running it).Mixed Version Proxy (MVP)Also known as: MVPFeature to let a kube-apiserver proxy a resource request to a different peer API server.[+]When a cluster has multiple API servers running different versions of Kubernetes, this\nfeature enables resource\nrequests to be served by the correct API server.MVP is disabled by default and can be activated by enabling\nthe feature gate named UnknownVersionInteroperabilityProxy when\nthe API Server is started.NameA client-provided string that refers to an object in a resource\nURL, such as /api/v1/pods/some-name.[+]Only one object of a given kind can have a given name at a time. However, if you delete the object, you can make a new object with the same name.NamespaceAn abstraction used by Kubernetes to support isolation of groups of API resources\nwithin a single cluster.[+]Namespaces are used to organize objects in a cluster and provide a way to divide cluster resources. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced resources (for example: Pods, Deployments, Services) and not for cluster-wide resources (for example: StorageClasses, Nodes, PersistentVolumes).Network PolicyA specification of how groups of Pods are allowed to communicate with each other and with other network endpoints.[+]NetworkPolicies help you declaratively configure which Pods are allowed to connect to each other, which namespaces are allowed to communicate,\nand more specifically which port numbers to enforce each policy on. NetworkPolicy objects use labels\nto select Pods and define rules which specify what traffic is allowed to the selected Pods.NetworkPolicies are implemented by a supported network plugin provided by a network provider.\nBe aware that creating a NetworkPolicy object without a controller to implement it will have no effect.NodeA node is a worker machine in Kubernetes.[+]A worker node may be a VM or physical machine, depending on the cluster. It has local daemons or services necessary to run Pods and is managed by the control plane. The daemons on a node include kubelet, kube-proxy, and a container runtime implementing the CRI such as Docker.In early Kubernetes versions, Nodes were called \"Minions\".Node-pressure evictionAlso known as: kubelet evictionNode-pressure eviction is the process by which the kubelet proactively terminates\npods to reclaim resource\non nodes.[+]The kubelet monitors resources like CPU, memory, disk space, and filesystem\ninodes on your cluster's nodes. When one or more of these resources reach\nspecific consumption levels, the kubelet can proactively fail one or more pods\non the node to reclaim resources and prevent starvation.Node-pressure eviction is not the same as API-initiated eviction.ObjectAn entity in the Kubernetes system. An object is an\nAPI resource that the Kubernetes API\nuses to represent the state of your cluster.[+]A Kubernetes object is typically a \u201crecord of intent\u201d\u2014once you create the object, the Kubernetes\ncontrol plane works constantly to ensure\nthat the item it represents actually exists.\nBy creating an object, you're effectively telling the Kubernetes system what you want that part of\nyour cluster's workload to look like; this is your cluster's desired state.Operator patternThe operator pattern is a system\ndesign that links a Controller to one or more custom\nresources.[+]You can extend Kubernetes by adding controllers to your cluster, beyond the built-in\ncontrollers that come as part of Kubernetes itself.If a running application acts as a controller and has API access to carry out tasks\nagainst a custom resource that's defined in the control plane, that's an example of\nthe Operator pattern.Persistent VolumeAn API object that represents a piece of storage in the cluster. Representation of as a general, pluggable storage\nresource that can persist beyond the lifecycle of any\nindividual Pod.[+]PersistentVolumes (PVs) provide an API that abstracts details of how storage is provided from how it is consumed.\nPVs are used directly in scenarios where storage can be created ahead of time (static provisioning).\nFor scenarios that require on-demand storage (dynamic provisioning), PersistentVolumeClaims (PVCs) are used instead.Persistent Volume ClaimClaims storage resources defined in a\nPersistentVolume, so that the storage can be mounted as\na volume in a container.[+]Specifies the amount of storage, how the storage will be accessed (read-only, read-write and/or exclusive) and how it is reclaimed (retained, recycled or deleted). Details of the storage itself are described in the PersistentVolume object.Platform DeveloperA person who customizes the Kubernetes platform to fit the needs of their project.[+]A platform developer may, for example, use Custom Resources or\nExtend the Kubernetes API with the aggregation layer\nto add functionality to their instance of Kubernetes, specifically for their application.\nSome Platform Developers are also contributors and\ndevelop extensions which are contributed to the Kubernetes community.\nOthers develop closed-source commercial or site-specific extensions.PodThe smallest and simplest Kubernetes object. A Pod represents a set of running containers on your cluster.[+]A Pod is typically set up to run a single primary container. It can also run optional sidecar containers that add supplementary features like logging. Pods are commonly managed by a Deployment.Pod DisruptionPod disruption is the process by which\nPods on Nodes are terminated either voluntarily or involuntarily.[+]Voluntary disruptions are started intentionally by application owners or cluster\nadministrators. Involuntary disruptions are unintentional and can be triggered by\nunavoidable issues like Nodes running out of resources,\nor by accidental deletions.Pod Disruption BudgetAlso known as: PDBA Pod Disruption Budget allows an\napplication owner to create an object for a replicated application, that ensures\na certain number or percentage of Pods\nwith an assigned label will not be voluntarily evicted at any point in time.[+]Involuntary disruptions cannot be prevented by PDBs; however they\ndo count against the budget.Pod LifecycleThe sequence of states through which a Pod passes during its lifetime.[+]The Pod Lifecycle is defined by the states or phases of a Pod. There are five possible Pod phases: Pending, Running, Succeeded, Failed, and Unknown. A high-level description of the Pod state is summarized in the PodStatus phase field.Pod PriorityPod Priority indicates the importance of a Pod relative to other Pods.[+]Pod Priority gives the ability to set scheduling priority of a Pod to be higher and lower than other Pods \u2014 an important feature for production clusters workload.Pod Security PolicyA former Kubernetes API that enforced security restrictions during Pod creation and updates.[+]PodSecurityPolicy was deprecated as of Kubernetes v1.21, and removed in v1.25.\nAs an alternative, use Pod Security Admission or a 3rd party admission plugin.PodTemplateAlso known as: pod templateAn API object that defines a template for creating Pods.\nThe PodTemplate API is also embedded in API definitions for workload management, such as\nDeployment or\nStatefulSets.[+]Pod templates allow you to define common metadata (such as labels, or a template for the name of a\nnew Pod) as well as to specify a pod's desired state.\nWorkload management controllers use Pod templates\n(embedded into another object, such as a Deployment or StatefulSet)\nto define and manage one or more Pods.\nWhen there can be multiple Pods based on the same template, these are called\nreplicas.\nAlthough you can create a PodTemplate object directly, you rarely need to do so.PreemptionPreemption logic in Kubernetes helps a pending Pod to find a suitable Node by evicting low priority Pods existing on that Node.[+]If a Pod cannot be scheduled, the scheduler tries to preempt lower priority Pods to make scheduling of the pending Pod possible.PriorityClassA PriorityClass is a named class for the scheduling priority that should be assigned to a Pod\nin that class.[+]A PriorityClass\nis a non-namespaced object mapping a name to an integer priority, used for a Pod. The name is\nspecified in the metadata.name field, and the priority value in the value field. Priorities range from\n-2147483648 to 1000000000 inclusive. Higher values indicate higher priority.ProbeA check that the kubelet periodically performs against a container that is\nrunning in a pod, that will define container's state and health and informing container's lifecycle.[+]To learn more, read container probes.ProxyIn computing, a proxy is a server that acts as an intermediary for a remote\nservice.[+]A client interacts with the proxy; the proxy copies the client's data to the\nactual server; the actual server replies to the proxy; the proxy sends the\nactual server's reply to the client.kube-proxy is a\nnetwork proxy that runs on each node in your cluster, implementing part of\nthe Kubernetes Service concept.You can run kube-proxy as a plain userland proxy service. If your operating\nsystem supports it, you can instead run kube-proxy in a hybrid mode that\nachieves the same overall effect using less system resources.QoS ClassQoS Class (Quality of Service Class) provides a way for Kubernetes to classify Pods within the cluster into several classes and make decisions about scheduling and eviction.[+]QoS Class of a Pod is set at creation time based on its infrastructure resource\nrequests and limits settings. QoS classes are used to make decisions about Pods scheduling and eviction.\nKubernetes can assign one of the following QoS classes to a Pod: Guaranteed, Burstable or BestEffort.QuantityA whole-number representation of small or large numbers using SI suffixes.[+]Quantities are representations of small or large numbers using a compact,\nwhole-number notation with SI suffixes. Fractional numbers are represented\nusing milli units, while large numbers can be represented using kilo,\nmega, or giga units.For instance, the number 1.5 is represented as 1500m, while the number 1000\ncan be represented as 1k, and 1000000 as 1M. You can also specify\nbinary-notation suffixes; the number 2048 can be written as 2Ki.The accepted decimal (power-of-10) units are m (milli), k (kilo,\nintentionally lowercase), M (mega), G (giga), T (tera), P (peta),\nE (exa).The accepted binary (power-of-2) units are Ki (kibi), Mi (mebi), Gi (gibi),\nTi (tebi), Pi (pebi), Ei (exbi).RBAC (Role-Based Access Control)Manages authorization decisions, allowing admins to dynamically configure access policies through the Kubernetes API.[+]RBAC utilizes four kinds of Kubernetes objects:RoleDefines permission rules in a specific namespace.ClusterRoleDefines permission rules cluster-wide.RoleBindingGrants the permissions defined in a role to a set of users in a specific namespace.ClusterRoleBindingGrants the permissions defined in a role to a set of users cluster-wide.For more information, see RBAC.ReplicaA copy or duplicate of a Pod or\na set of pods. Replicas ensure high availability, scalability, and fault tolerance\nby maintaining multiple identical instances of a pod.[+]Replicas are commonly used in Kubernetes to achieve the desired application state and reliability.\nThey enable workload scaling and distribution across multiple nodes in a cluster.By defining the number of replicas in a Deployment or ReplicaSet, Kubernetes ensures that\nthe specified number of instances are running, automatically adjusting the count as needed.Replica management allows for efficient load balancing, rolling updates, and\nself-healing capabilities in a Kubernetes cluster.ReplicaSetA ReplicaSet (aims to) maintain a set of replica Pods running at any given time.[+]Workload objects such as Deployment make use of ReplicaSets\nto ensure that the configured number of Pods are\nrunning in your cluster, based on the spec of that ReplicaSet.ReplicationControllerA workload management object\nthat manages a replicated application, ensuring that\na specific number of instances of a Pod are running.[+]The control plane ensures that the defined number of Pods are running, even if some\nPods fail, if you delete Pods manually, or if too many are started by mistake.Note:ReplicationController is deprecated. See\nDeployment, which is similar.Resource (infrastructure)Capabilities provided to one or more nodes (CPU, memory, GPUs, etc), and made available for consumption by\nPods running on those nodes.Kubernetes also uses the term resource to describe an API resource.[+]Computers provide fundamental hardware facilities: processing power, storage memory, network, etc.\nThese resources have finite capacity, measured in a unit applicable to that resource (number of CPUs, bytes of memory, etc).\nKubernetes abstracts common resources\nfor allocation to workloads and utilizes operating system primitives (for example, Linux cgroups) to manage consumption by workloads).You can also use dynamic resource allocation to\nmanage complex resource allocations automatically.ResourceClaimDescribes the resources that a workload needs, such as\ndevices. ResourceClaims are\nused in\ndynamic resource allocation (DRA)\nto provide Pods with access to a specific resource.[+]ResourceClaims can be created by workload operators or generated by Kubernetes\nbased on a\nResourceClaimTemplate.ResourceClaimTemplateDefines a template that Kubernetes uses to create\nResourceClaims.\nResourceClaimTemplates are used in\ndynamic resource allocation (DRA)\nto provide per-Pod access to separate, similar resources.[+]When a ResourceClaimTemplate is referenced in a workload specification,\nKubernetes automatically creates ResourceClaim objects based on the template.\nEach ResourceClaim is bound to a specific Pod. When the Pod terminates,\nKubernetes deletes the corresponding ResourceClaim.ResourceQuotaObject that constrains aggregate resource\nconsumption, per Namespace.[+]A ResourceQuota can either limits the quantity of API resources\nthat can be created in a namespace by type, or it can set a limit on the total amount of\ninfrastructure resources\nthat may be consumed on behalf of the namespace (and the objects within it).ResourceSliceRepresents one or more infrastructure resources, such as\ndevices, that are attached to\nnodes. Drivers create and manage ResourceSlices in the cluster. ResourceSlices\nare used for\ndynamic resource allocation (DRA).[+]When a ResourceClaim is\ncreated, Kubernetes uses ResourceSlices to find nodes that have access to\nresources that can satisfy the claim. Kubernetes allocates resources to the\nResourceClaim and schedules the Pod onto a node that can access the resources.ReviewerA person who reviews code for quality and correctness on some part of the project.[+]Reviewers are knowledgeable about both the codebase and software engineering principles. Reviewer status is scoped to a part of the codebase.SecretStores sensitive information, such as passwords, OAuth tokens, and SSH keys.[+]Secrets give you more control over how sensitive information is used and reduces\nthe risk of accidental exposure. Secret values are encoded as base64 strings and\nare stored unencrypted by default, but can be configured to be\nencrypted at rest.A Pod can reference the Secret in\na variety of ways, such as in a volume mount or as an environment variable.\nSecrets are designed for confidential data and\nConfigMaps are\ndesigned for non-confidential data.Security ContextThe securityContext field defines privilege and access control settings for\na Pod or\ncontainer.[+]In a securityContext, you can define: the user that processes run as,\nthe group that processes run as, and privilege settings.\nYou can also configure security policies (for example: SELinux, AppArmor or seccomp).The PodSpec.securityContext setting applies to all containers in a Pod.SelectorAllows users to filter a list of API resources\nbased on labels.[+]Selectors are applied when querying lists of resources to filter them by labels.ServiceA method for exposing a network application that is running as one or more\nPods in your cluster.[+]The set of Pods targeted by a Service is (usually) determined by a\nselector. If more Pods are added or removed,\nthe set of Pods matching the selector will change. The Service makes sure that network traffic\ncan be directed to the current set of Pods for the workload.Kubernetes Services either use IP networking (IPv4, IPv6, or both), or reference an external name in\nthe Domain Name System (DNS).The Service abstraction enables other mechanisms, such as Ingress and Gateway.Service CatalogA former extension API that enabled applications running in Kubernetes clusters to easily use external managed software offerings, such as a datastore service offered by a cloud provider.[+]It provided a way to list, provision, and bind with external Managed Services without needing detailed knowledge about how those services would be created or managed.ServiceAccountProvides an identity for processes that run in a Pod.[+]When processes inside Pods access the cluster, they are authenticated by the API server as a particular service account, for example,\u00a0default. When you create a Pod, if you do not specify a service account, it is automatically assigned the default service account in the same Namespace.Shuffle-shardingA technique for assigning requests to queues that provides better isolation than hashing modulo the number of queues.[+]We are often concerned with insulating different flows of requests\nfrom each other, so that a high-intensity flow does not crowd out low-intensity flows.\nA simple way to put requests into queues is to hash some\ncharacteristics of the request, modulo the number of queues, to get\nthe index of the queue to use. The hash function uses as input\ncharacteristics of the request that align with flows. For example, in\nthe Internet this is often the 5-tuple of source and destination\naddress, protocol, and source and destination port.That simple hash-based scheme has the property that any high-intensity flow\nwill crowd out all the low-intensity flows that hash to the same queue.\nProviding good insulation for a large number of flows requires a large\nnumber of queues, which is problematic. Shuffle-sharding is a more\nnimble technique that can do a better job of insulating the low-intensity\nflows from the high-intensity flows. The terminology of shuffle-sharding uses\nthe metaphor of dealing a hand from a deck of cards; each queue is a\nmetaphorical card. The shuffle-sharding technique starts with hashing\nthe flow-identifying characteristics of the request, to produce a hash\nvalue with dozens or more of bits. Then the hash value is used as a\nsource of entropy to shuffle the deck and deal a hand of cards\n(queues). All the dealt queues are examined, and the request is put\ninto one of the examined queues with the shortest length. With a\nmodest hand size, it does not cost much to examine all the dealt cards\nand a given low-intensity flow has a good chance to dodge the effects of a\ngiven high-intensity flow. With a large hand size it is expensive to examine\nthe dealt queues and more difficult for the low-intensity flows to dodge the\ncollective effects of a set of high-intensity flows. Thus, the hand size\nshould be chosen judiciously.Sidecar ContainerOne or more containers that are typically started before any app containers run.[+]Sidecar containers are like regular app containers, but with a different purpose: the sidecar provides a Pod-local service to the main app container.\nUnlike init containers, sidecar containers\ncontinue running after Pod startup.Read Sidecar containers for more information.SIG (special interest group)Community members who collectively manage an ongoing piece or aspect of the larger Kubernetes open source project.[+]Members within a SIG have a shared interest in advancing a specific area, such as architecture, API machinery, or documentation.\nSIGs must follow the SIG governance guidelines, but can have their own contribution policy and channels of communication.For more information, see the kubernetes/community repo and the current list of SIGs and Working Groups.SpecDefines how each object, like Pods or Services, should be configured and its desired state.[+]Almost every Kubernetes object includes two nested object fields that govern the object's configuration: the object spec and the object status. For objects that have a spec, you have to set this when you create the object, providing a description of the characteristics you want the resource to have: its desired state.It varies for different objects like Pods, StatefulSets, and Services, detailing settings such as containers, volumes, replicas, ports,\nand other specifications unique to each object type. This field encapsulates what state Kubernetes should maintain for the defined\nobject.StatefulSetManages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods.[+]Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of its Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling.If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.Static PodA pod managed directly by the kubelet\ndaemon on a specific node,[+]without the API server observing it.Static Pods do not support ephemeral containers.Storage ClassA StorageClass provides a way for administrators to describe different available storage types.[+]StorageClasses can map to quality-of-service levels, backup policies, or to arbitrary policies determined by cluster administrators. Each StorageClass contains the fields provisioner, parameters, and reclaimPolicy, which are used when a Persistent Volume belonging to the class needs to be dynamically provisioned. Users can request a particular class using the name of a StorageClass object.sysctlsysctl is a semi-standardized interface for reading or changing the\nattributes of the running Unix kernel.[+]On Unix-like systems, sysctl is both the name of the tool that administrators\nuse to view and modify these settings, and also the system call that the tool\nuses.Container runtimes and\nnetwork plugins may rely on sysctl values being set a certain way.TaintA core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of Pods on nodes or node groups.[+]Taints and tolerations work together to ensure that pods are not scheduled onto inappropriate nodes. One or more taints are applied to a node. A node should only schedule a Pod with the matching tolerations for the configured taints.TolerationA core object consisting of three required properties: key, value, and effect. Tolerations enable the scheduling of pods on nodes or node groups that have matching taints.[+]Tolerations and taints work together to ensure that pods are not scheduled onto inappropriate nodes. One or more tolerations are applied to a pod. A toleration indicates that the pod is allowed (but not required) to be scheduled on nodes or node groups with matching taints.UIDA Kubernetes systems-generated string to uniquely identify objects.[+]Every object created over the whole lifetime of a Kubernetes cluster has a distinct UID. It is intended to distinguish between historical occurrences of similar entities.Upstream (disambiguation)May refer to: core Kubernetes or the source repo from which a repo was forked.[+]In the Kubernetes Community: Conversations often use upstream to mean the core Kubernetes codebase, which the general ecosystem, other code, or third-party tools rely upon. For example, community members may suggest that a feature is moved upstream so that it is in the core codebase instead of in a plugin or third-party tool.In GitHub or git: The convention is to refer to a source repo as upstream, whereas the forked repo is considered downstream.user namespaceA kernel feature to emulate root. Used for \"rootless containers\".[+]User namespaces are a Linux kernel feature that allows a non-root user to\nemulate superuser (\"root\") privileges,\nfor example in order to run containers without being a superuser outside the container.User namespace is effective for mitigating damage of potential container break-out attacks.In the context of user namespaces, the namespace is a Linux kernel feature, and not a\nnamespace in the Kubernetes sense\nof the term.VolumeA directory containing data, accessible to the containers in a Pod.[+]A Kubernetes volume lives as long as the Pod that encloses it. Consequently, a volume outlives any containers that run within the Pod, and data in the volume is preserved across container restarts.See storage for more information.Volume PluginA Volume Plugin enables integration of storage within a Pod.[+]A Volume Plugin lets you attach and mount storage volumes for use by a Pod. Volume plugins can be in tree or out of tree. In tree plugins are part of the Kubernetes code repository and follow its release cycle. Out of tree plugins are developed independently.WatchA verb that is used to track changes to an object in Kubernetes as a stream.\nIt is used for the efficient detection of changes.[+]A verb that is used to track changes to an object in Kubernetes as a stream. Watches allow\nefficient detection of changes; for example, a\ncontroller that needs to know whenever a\nConfigMap has changed can use a watch rather than polling.See Efficient Detection of Changes in API Concepts for more information.WG (working group)Facilitates the discussion and/or implementation of a short-lived, narrow, or decoupled project for a committee, SIG, or cross-SIG effort.[+]Working groups are a way of organizing people to accomplish a discrete task.For more information, see the kubernetes/community repo and the current list of SIGs and working groups.WorkloadA workload is an application running on Kubernetes.[+]Various core objects that represent different types or parts of a workload\ninclude the DaemonSet, Deployment, Job, ReplicaSet, and StatefulSet objects.For example, a workload that has a web server and a database might run the\ndatabase in one StatefulSet and the web server\nin a Deployment.FeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified April 20, 2024 at 7:09 PM PST: Ready glossary page for vanilla Docsy (2f3602cef0) Edit this page\nCreate child page\nCreate an issue\nPrint entire section\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "?fundamental=true"
  },
  {
    "url": "https://kubernetes.io/docs/reference/kubectl/",
    "content": "Command line tool (kubectl) | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\nBahasa Indonesia (Indonesian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationReferenceCommand line tool (kubectl)Command line tool (kubectl)Kubernetes provides a command line tool for communicating with a Kubernetes cluster's\ncontrol plane,\nusing the Kubernetes API.This tool is named kubectl.For configuration, kubectl looks for a file named config in the $HOME/.kube directory.\nYou can specify other kubeconfig\nfiles by setting the KUBECONFIG environment variable or by setting the\n--kubeconfig flag.This overview covers kubectl syntax, describes the command operations, and provides common examples.\nFor details about each command, including all the supported flags and subcommands, see the\nkubectl reference documentation.For installation instructions, see Installing kubectl;\nfor a quick guide, see the cheat sheet.\nIf you're used to using the docker command-line tool,\nkubectl for Docker Users explains some equivalent commands for Kubernetes.SyntaxUse the following syntax to run kubectl commands from your terminal window:kubectl [command] [TYPE] [NAME] [flags]\nwhere command, TYPE, NAME, and flags are:command: Specifies the operation that you want to perform on one or more resources,\nfor example create, get, describe, delete.TYPE: Specifies the resource type. Resource types are case-insensitive and\nyou can specify the singular, plural, or abbreviated forms.\nFor example, the following commands produce the same output:kubectl get pod pod1\nkubectl get pods pod1\nkubectl get po pod1\nNAME: Specifies the name of the resource. Names are case-sensitive. If the name is omitted,\ndetails for all resources are displayed, for example kubectl get pods.When performing an operation on multiple resources, you can specify each resource by\ntype and name or specify one or more files:To specify resources by type and name:To group resources if they are all the same type: TYPE1 name1 name2 name<#>.Example: kubectl get pod example-pod1 example-pod2To specify multiple resource types individually: TYPE1/name1 TYPE1/name2 TYPE2/name3 TYPE<#>/name<#>.Example: kubectl get pod/example-pod1 replicationcontroller/example-rc1To specify resources with one or more files: -f file1 -f file2 -f file<#>Use YAML rather than JSON\nsince YAML tends to be more user-friendly, especially for configuration files.Example: kubectl get -f ./pod.yamlflags: Specifies optional flags. For example, you can use the -s or --server flags\nto specify the address and port of the Kubernetes API server.Caution:Flags that you specify from the command line override default values and any corresponding environment variables.If you need help, run kubectl help from the terminal window.In-cluster authentication and namespace overridesBy default kubectl will first determine if it is running within a pod, and thus in a cluster.\nIt starts by checking for the KUBERNETES_SERVICE_HOST and KUBERNETES_SERVICE_PORT environment\nvariables and the existence of a service account token file at /var/run/secrets/kubernetes.io/serviceaccount/token.\nIf all three are found in-cluster authentication is assumed.To maintain backwards compatibility, if the POD_NAMESPACE environment variable is set\nduring in-cluster authentication it will override the default namespace from the\nservice account token. Any manifests or tools relying on namespace defaulting will be affected by this.POD_NAMESPACE environment variableIf the POD_NAMESPACE environment variable is set, cli operations on namespaced resources\nwill default to the variable value. For example, if the variable is set to seattle,\nkubectl get pods would return pods in the seattle namespace. This is because pods are\na namespaced resource, and no namespace was provided in the command. Review the output\nof kubectl api-resources to determine if a resource is namespaced.Explicit use of --namespace <value> overrides this behavior.How kubectl handles ServiceAccount tokensIf:there is Kubernetes service account token file mounted at\n/var/run/secrets/kubernetes.io/serviceaccount/token, andthe KUBERNETES_SERVICE_HOST environment variable is set, andthe KUBERNETES_SERVICE_PORT environment variable is set, andyou don't explicitly specify a namespace on the kubectl command linethen kubectl assumes it is running in your cluster. The kubectl tool looks up the\nnamespace of that ServiceAccount (this is the same as the namespace of the Pod)\nand acts against that namespace. This is different from what happens outside of a\ncluster; when kubectl runs outside a cluster and you don't specify a namespace,\nthe kubectl command acts against the namespace set for the current context in your\nclient configuration. To change the default namespace for your kubectl you can use the\nfollowing command:kubectl config set-context --current --namespace=<namespace-name>\nOperationsThe following table includes short descriptions and the general syntax for all of the kubectl operations:OperationSyntaxDescriptionalphakubectl alpha SUBCOMMAND [flags]List the available commands that correspond to alpha features, which are not enabled in Kubernetes clusters by default.annotatekubectl annotate (-f FILENAME | TYPE NAME | TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]Add or update the annotations of one or more resources.api-resourceskubectl api-resources [flags]List the API resources that are available.api-versionskubectl api-versions [flags]List the API versions that are available.applykubectl apply -f FILENAME [flags]Apply a configuration change to a resource from a file or stdin.attachkubectl attach POD -c CONTAINER [-i] [-t] [flags]Attach to a running container either to view the output stream or interact with the container (stdin).authkubectl auth [flags] [options]Inspect authorization.autoscalekubectl autoscale (-f FILENAME | TYPE NAME | TYPE/NAME) [--min=MINPODS] --max=MAXPODS [--cpu-percent=CPU] [flags]Automatically scale the set of pods that are managed by a replication controller.certificatekubectl certificate SUBCOMMAND [options]Modify certificate resources.cluster-infokubectl cluster-info [flags]Display endpoint information about the master and services in the cluster.completionkubectl completion SHELL [options]Output shell completion code for the specified shell (bash or zsh).configkubectl config SUBCOMMAND [flags]Modifies kubeconfig files. See the individual subcommands for details.convertkubectl convert -f FILENAME [options]Convert config files between different API versions. Both YAML and JSON formats are accepted. Note - requires kubectl-convert plugin to be installed.cordonkubectl cordon NODE [options]Mark node as unschedulable.cpkubectl cp <file-spec-src> <file-spec-dest> [options]Copy files and directories to and from containers.createkubectl create -f FILENAME [flags]Create one or more resources from a file or stdin.deletekubectl delete (-f FILENAME | TYPE [NAME | /NAME | -l label | --all]) [flags]Delete resources either from a file, stdin, or specifying label selectors, names, resource selectors, or resources.describekubectl describe (-f FILENAME | TYPE [NAME_PREFIX | /NAME | -l label]) [flags]Display the detailed state of one or more resources.diffkubectl diff -f FILENAME [flags]Diff file or stdin against live configuration.drainkubectl drain NODE [options]Drain node in preparation for maintenance.editkubectl edit (-f FILENAME | TYPE NAME | TYPE/NAME) [flags]Edit and update the definition of one or more resources on the server by using the default editor.eventskubectl eventsList eventsexeckubectl exec POD [-c CONTAINER] [-i] [-t] [flags] [-- COMMAND [args...]]Execute a command against a container in a pod.explainkubectl explain TYPE [--recursive=false] [flags]Get documentation of various resources. For instance pods, nodes, services, etc.exposekubectl expose (-f FILENAME | TYPE NAME | TYPE/NAME) [--port=port] [--protocol=TCP|UDP] [--target-port=number-or-name] [--name=name] [--external-ip=external-ip-of-service] [--type=type] [flags]Expose a replication controller, service, or pod as a new Kubernetes service.getkubectl get (-f FILENAME | TYPE [NAME | /NAME | -l label]) [--watch] [--sort-by=FIELD] [[-o | --output]=OUTPUT_FORMAT] [flags]List one or more resources.kustomizekubectl kustomize <dir> [flags] [options]List a set of API resources generated from instructions in a kustomization.yaml file. The argument must be the path to the directory containing the file, or a git repository URL with a path suffix specifying same with respect to the repository root.labelkubectl label (-f FILENAME | TYPE NAME | TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]Add or update the labels of one or more resources.logskubectl logs POD [-c CONTAINER] [--follow] [flags]Print the logs for a container in a pod.optionskubectl optionsList of global command-line options, which apply to all commands.patchkubectl patch (-f FILENAME | TYPE NAME | TYPE/NAME) --patch PATCH [flags]Update one or more fields of a resource by using the strategic merge patch process.pluginkubectl plugin [flags] [options]Provides utilities for interacting with plugins.port-forwardkubectl port-forward POD [LOCAL_PORT:]REMOTE_PORT [...[LOCAL_PORT_N:]REMOTE_PORT_N] [flags]Forward one or more local ports to a pod.proxykubectl proxy [--port=PORT] [--www=static-dir] [--www-prefix=prefix] [--api-prefix=prefix] [flags]Run a proxy to the Kubernetes API server.replacekubectl replace -f FILENAMEReplace a resource from a file or stdin.rolloutkubectl rollout SUBCOMMAND [options]Manage the rollout of a resource. Valid resource types include: deployments, daemonsets and statefulsets.runkubectl run NAME --image=image [--env=\"key=value\"] [--port=port] [--dry-run=server|client|none] [--overrides=inline-json] [flags]Run a specified image on the cluster.scalekubectl scale (-f FILENAME | TYPE NAME | TYPE/NAME) --replicas=COUNT [--resource-version=version] [--current-replicas=count] [flags]Update the size of the specified replication controller.setkubectl set SUBCOMMAND [options]Configure application resources.taintkubectl taint NODE NAME KEY_1=VAL_1:TAINT_EFFECT_1 ... KEY_N=VAL_N:TAINT_EFFECT_N [options]Update the taints on one or more nodes.topkubectl top (POD | NODE) [flags] [options]Display Resource (CPU/Memory/Storage) usage of pod or node.uncordonkubectl uncordon NODE [options]Mark node as schedulable.versionkubectl version [--client] [flags]Display the Kubernetes version running on the client and server.waitkubectl wait ([-f FILENAME] | resource.group/resource.name | resource.group [(-l label | --all)]) [--for=delete|--for condition=available] [options]Experimental: Wait for a specific condition on one or many resources.To learn more about command operations, see the kubectl reference documentation.Resource typesThe following table includes a list of all the supported resource types and their abbreviated aliases.(This output can be retrieved from kubectl api-resources, and was accurate as of Kubernetes 1.25.0)NAMESHORTNAMESAPIVERSIONNAMESPACEDKINDbindingsv1trueBindingcomponentstatusescsv1falseComponentStatusconfigmapscmv1trueConfigMapendpointsepv1trueEndpointseventsevv1trueEventlimitrangeslimitsv1trueLimitRangenamespacesnsv1falseNamespacenodesnov1falseNodepersistentvolumeclaimspvcv1truePersistentVolumeClaimpersistentvolumespvv1falsePersistentVolumepodspov1truePodpodtemplatesv1truePodTemplatereplicationcontrollersrcv1trueReplicationControllerresourcequotasquotav1trueResourceQuotasecretsv1trueSecretserviceaccountssav1trueServiceAccountservicessvcv1trueServicemutatingwebhookconfigurationsadmissionregistration.k8s.io/v1falseMutatingWebhookConfigurationvalidatingwebhookconfigurationsadmissionregistration.k8s.io/v1falseValidatingWebhookConfigurationcustomresourcedefinitionscrd,crdsapiextensions.k8s.io/v1falseCustomResourceDefinitionapiservicesapiregistration.k8s.io/v1falseAPIServicecontrollerrevisionsapps/v1trueControllerRevisiondaemonsetsdsapps/v1trueDaemonSetdeploymentsdeployapps/v1trueDeploymentreplicasetsrsapps/v1trueReplicaSetstatefulsetsstsapps/v1trueStatefulSettokenreviewsauthentication.k8s.io/v1falseTokenReviewlocalsubjectaccessreviewsauthorization.k8s.io/v1trueLocalSubjectAccessReviewselfsubjectaccessreviewsauthorization.k8s.io/v1falseSelfSubjectAccessReviewselfsubjectrulesreviewsauthorization.k8s.io/v1falseSelfSubjectRulesReviewsubjectaccessreviewsauthorization.k8s.io/v1falseSubjectAccessReviewhorizontalpodautoscalershpaautoscaling/v2trueHorizontalPodAutoscalercronjobscjbatch/v1trueCronJobjobsbatch/v1trueJobcertificatesigningrequestscsrcertificates.k8s.io/v1falseCertificateSigningRequestleasescoordination.k8s.io/v1trueLeaseendpointslicesdiscovery.k8s.io/v1trueEndpointSliceeventsevevents.k8s.io/v1trueEventflowschemasflowcontrol.apiserver.k8s.io/v1beta2falseFlowSchemaprioritylevelconfigurationsflowcontrol.apiserver.k8s.io/v1beta2falsePriorityLevelConfigurationingressclassesnetworking.k8s.io/v1falseIngressClassingressesingnetworking.k8s.io/v1trueIngressnetworkpoliciesnetpolnetworking.k8s.io/v1trueNetworkPolicyruntimeclassesnode.k8s.io/v1falseRuntimeClasspoddisruptionbudgetspdbpolicy/v1truePodDisruptionBudgetpodsecuritypoliciespsppolicy/v1beta1falsePodSecurityPolicyclusterrolebindingsrbac.authorization.k8s.io/v1falseClusterRoleBindingclusterrolesrbac.authorization.k8s.io/v1falseClusterRolerolebindingsrbac.authorization.k8s.io/v1trueRoleBindingrolesrbac.authorization.k8s.io/v1trueRolepriorityclassespcscheduling.k8s.io/v1falsePriorityClasscsidriversstorage.k8s.io/v1falseCSIDrivercsinodesstorage.k8s.io/v1falseCSINodecsistoragecapacitiesstorage.k8s.io/v1trueCSIStorageCapacitystorageclassesscstorage.k8s.io/v1falseStorageClassvolumeattachmentsstorage.k8s.io/v1falseVolumeAttachmentOutput optionsUse the following sections for information about how you can format or sort the output\nof certain commands. For details about which commands support the various output options,\nsee the kubectl reference documentation.Formatting outputThe default output format for all kubectl commands is the human readable plain-text format.\nTo output details to your terminal window in a specific format, you can add either the -o\nor --output flags to a supported kubectl command.Syntaxkubectl [command] [TYPE] [NAME] -o <output_format>\nDepending on the kubectl operation, the following output formats are supported:Output formatDescription-o custom-columns=<spec>Print a table using a comma separated list of custom columns.-o custom-columns-file=<filename>Print a table using the custom columns template in the <filename> file.-o jsonOutput a JSON formatted API object.-o jsonpath=<template>Print the fields defined in a jsonpath expression.-o jsonpath-file=<filename>Print the fields defined by the jsonpath expression in the <filename> file.-o kyamlOutput a KYAML formatted API object (alpha, requires environment variable KUBECTL_KYAML=\"true\").-o namePrint only the resource name and nothing else.-o wideOutput in the plain-text format with any additional information. For pods, the node name is included.-o yamlOutput a YAML formatted API object. KYAML is an experimental Kubernetes-specific dialect of YAML, and can be parsed as YAML.ExampleIn this example, the following command outputs the details for a single pod as a YAML formatted object:kubectl get pod web-pod-13je7 -o yaml\nRemember: See the kubectl reference documentation\nfor details about which output format is supported by each command.Custom columnsTo define custom columns and output only the details that you want into a table, you can use the custom-columns option.\nYou can choose to define the custom columns inline or use a template file: -o custom-columns=<spec> or -o custom-columns-file=<filename>.ExamplesInline:kubectl get pods <pod-name> -o custom-columns=NAME:.metadata.name,RSRC:.metadata.resourceVersion\nTemplate file:kubectl get pods <pod-name> -o custom-columns-file=template.txt\nwhere the template.txt file contains:NAME\nRSRC\nmetadata.name metadata.resourceVersion\nThe result of running either command is similar to:NAME\nRSRC\nsubmit-queue\n610995\nServer-side columnskubectl supports receiving specific column information from the server about objects.\nThis means that for any given resource, the server will return columns and rows relevant to that resource, for the client to print.\nThis allows for consistent human-readable output across clients used against the same cluster, by having the server encapsulate the details of printing.This feature is enabled by default. To disable it, add the\n--server-print=false flag to the kubectl get command.ExamplesTo print information about the status of a pod, use a command like the following:kubectl get pods <pod-name> --server-print=false\nThe output is similar to:NAME\nAGE\npod-name\n1m\nSorting list objectsTo output objects to a sorted list in your terminal window, you can add the --sort-by flag\nto a supported kubectl command. Sort your objects by specifying any numeric or string field\nwith the --sort-by flag. To specify a field, use a jsonpath expression.Syntaxkubectl [command] [TYPE] [NAME] --sort-by=<jsonpath_exp>\nExampleTo print a list of pods sorted by name, you run:kubectl get pods --sort-by=.metadata.name\nExamples: Common operationsUse the following set of examples to help you familiarize yourself with running the commonly used kubectl operations:kubectl apply - Apply or Update a resource from a file or stdin.# Create a service using the definition in example-service.yaml.\nkubectl apply -f example-service.yaml\n# Create a replication controller using the definition in example-controller.yaml.\nkubectl apply -f example-controller.yaml\n# Create the objects that are defined in any .yaml, .yml, or .json file within the <directory> directory.\nkubectl apply -f <directory>\nkubectl get - List one or more resources.# List all pods in plain-text output format.\nkubectl get pods\n# List all pods in plain-text output format and include additional information (such as node name).\nkubectl get pods -o wide\n# List the replication controller with the specified name in plain-text output format. Tip: You can shorten and replace the 'replicationcontroller' resource type with the alias 'rc'.\nkubectl get replicationcontroller <rc-name>\n# List all replication controllers and services together in plain-text output format.\nkubectl get rc,services\n# List all daemon sets in plain-text output format.\nkubectl get ds\n# List all pods running on node server01\nkubectl get pods --field-selector=spec.nodeName=server01\nkubectl describe - Display detailed state of one or more resources, including the uninitialized ones by default.# Display the details of the node with name <node-name>.\nkubectl describe nodes <node-name>\n# Display the details of the pod with name <pod-name>.\nkubectl describe pods/<pod-name>\n# Display the details of all the pods that are managed by the replication controller named <rc-name>.\n# Remember: Any pods that are created by the replication controller get prefixed with the name of the replication controller.\nkubectl describe pods <rc-name>\n# Describe all pods\nkubectl describe pods\nNote:The kubectl get command is usually used for retrieving one or more\nresources of the same resource type. It features a rich set of flags that allows\nyou to customize the output format using the -o or --output flag, for example.\nYou can specify the -w or --watch flag to start watching updates to a particular\nobject. The kubectl describe command is more focused on describing the many\nrelated aspects of a specified resource. It may invoke several API calls to the\nAPI server to build a view for the user. For example, the kubectl describe node\ncommand retrieves not only the information about the node, but also a summary of\nthe pods running on it, the events generated for the node etc.kubectl delete - Delete resources either from a file, stdin, or specifying label selectors, names, resource selectors, or resources.# Delete a pod using the type and name specified in the pod.yaml file.\nkubectl delete -f pod.yaml\n# Delete all the pods and services that have the label '<label-key>=<label-value>'.\nkubectl delete pods,services -l <label-key>=<label-value>\n# Delete all pods, including uninitialized ones.\nkubectl delete pods --all\nkubectl exec - Execute a command against a container in a pod.# Get output from running 'date' from pod <pod-name>. By default, output is from the first container.\nkubectl exec <pod-name> -- date\n# Get output from running 'date' in container <container-name> of pod <pod-name>.\nkubectl exec <pod-name> -c <container-name> -- date\n# Get an interactive TTY and run /bin/bash from pod <pod-name>. By default, output is from the first container.\nkubectl exec -ti <pod-name> -- /bin/bash\nkubectl logs - Print the logs for a container in a pod.# Return a snapshot of the logs from pod <pod-name>.\nkubectl logs <pod-name>\n# Start streaming the logs from pod <pod-name>. This is similar to the 'tail -f' Linux command.\nkubectl logs -f <pod-name>\nkubectl diff - View a diff of the proposed updates to a cluster.# Diff resources included in \"pod.json\".\nkubectl diff -f pod.json\n# Diff file read from stdin.\ncat service.yaml | kubectl diff -f -\nExamples: Creating and using pluginsUse the following set of examples to help you familiarize yourself with writing and using kubectl plugins:# create a simple plugin in any language and name the resulting executable file\n# so that it begins with the prefix \"kubectl-\"\ncat ./kubectl-hello\n#!/bin/sh\n# this plugin prints the words \"hello world\"\necho \"hello world\"\nWith a plugin written, let's make it executable:chmod a+x ./kubectl-hello\n# and move it to a location in our PATH\nsudo mv ./kubectl-hello /usr/local/bin\nsudo chown root:root /usr/local/bin\n# You have now created and \"installed\" a kubectl plugin.\n# You can begin using this plugin by invoking it from kubectl as if it were a regular command\nkubectl hello\nhello world\n# You can \"uninstall\" a plugin, by removing it from the folder in your\n# $PATH where you placed it\nsudo rm /usr/local/bin/kubectl-hello\nIn order to view all of the plugins that are available to kubectl, use\nthe kubectl plugin list subcommand:kubectl plugin list\nThe output is similar to:The following kubectl-compatible plugins are available:\n/usr/local/bin/kubectl-hello\n/usr/local/bin/kubectl-foo\n/usr/local/bin/kubectl-bar\nkubectl plugin list also warns you about plugins that are not\nexecutable, or that are shadowed by other plugins; for example:sudo chmod -x /usr/local/bin/kubectl-foo # remove execute permission\nkubectl plugin list\nThe following kubectl-compatible plugins are available:\n/usr/local/bin/kubectl-hello\n/usr/local/bin/kubectl-foo\n- warning: /usr/local/bin/kubectl-foo identified as a plugin, but it is not executable\n/usr/local/bin/kubectl-bar\nerror: one plugin warning was found\nYou can think of plugins as a means to build more complex functionality on top\nof the existing kubectl commands:cat ./kubectl-whoami\nThe next few examples assume that you already made kubectl-whoami have\nthe following contents:#!/bin/bash\n# this plugin makes use of the `kubectl config` command in order to output\n# information about the current user, based on the currently selected context\nkubectl config view --template='{{ range .contexts }}{{ if eq .name \"'$(kubectl config current-context)'\" }}Current user: {{ printf \"%s\\n\" .context.user }}{{ end }}{{ end }}'\nRunning the above command gives you an output containing the user for the\ncurrent context in your KUBECONFIG file:# make the file executable\nsudo chmod +x ./kubectl-whoami\n# and move it into your PATH\nsudo mv ./kubectl-whoami /usr/local/bin\nkubectl whoami\nCurrent user: plugins-user\nWhat's nextRead the kubectl reference documentation:the kubectl command referencethe command line arguments referenceLearn about kubectl usage conventionsRead about JSONPath support in kubectlRead about how to extend kubectl with pluginsTo find out more about plugins, take a look at the example CLI plugin.FeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified July 01, 2025 at 8:58 AM PST: Document KYAML (9f26f83533) Edit this page\nCreate child page\nCreate an issue\nPrint entire sectionSyntaxIn-cluster authentication and namespace overridesOperationsResource typesOutput optionsFormatting outputSorting list objectsExamples: Common operationsExamples: Creating and using pluginsWhat's next\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "kubernetes-docs"
  },
  {
    "url": "https://kubernetes.io/docs/reference/labels-annotations-taints/#labels-annotations-and-taints-used-on-api-objects",
    "content": "Well-Known Labels, Annotations and Taints | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u4e2d\u6587 (Chinese)\n\ud55c\uad6d\uc5b4 (Korean)\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationReferenceWell-Known Labels, Annotations and TaintsWell-Known Labels, Annotations and TaintsKubernetes reserves all labels, annotations and taints in the kubernetes.io and k8s.io namespaces.This document serves both as a reference to the values and as a coordination point for assigning values.Labels, annotations and taints used on API objectsapf.kubernetes.io/autoupdate-specType: AnnotationExample: apf.kubernetes.io/autoupdate-spec: \"true\"Used on: FlowSchema and PriorityLevelConfiguration ObjectsIf this annotation is set to true on a FlowSchema or PriorityLevelConfiguration, the spec for that object\nis managed by the kube-apiserver. If the API server does not recognize an APF object, and you annotate it\nfor automatic update, the API server deletes the entire object. Otherwise, the API server does not manage the\nobject spec.\nFor more details, read Maintenance of the Mandatory and Suggested Configuration Objects.app.kubernetes.io/componentType: LabelExample: app.kubernetes.io/component: \"database\"Used on: All Objects (typically used on workload resources).The component within the application architecture.One of the recommended labels.app.kubernetes.io/created-by (deprecated)Type: LabelExample: app.kubernetes.io/created-by: \"controller-manager\"Used on: All Objects (typically used on workload resources).The controller/user who created this resource.Note:Starting from v1.9, this label is deprecated.app.kubernetes.io/instanceType: LabelExample: app.kubernetes.io/instance: \"mysql-abcxyz\"Used on: All Objects (typically used on\nworkload resources).A unique name identifying the instance of an application.\nTo assign a non-unique name, use app.kubernetes.io/name.One of the recommended labels.app.kubernetes.io/managed-byType: LabelExample: app.kubernetes.io/managed-by: \"helm\"Used on: All Objects (typically used on\nworkload resources).The tool being used to manage the operation of an application.One of the recommended labels.app.kubernetes.io/nameType: LabelExample: app.kubernetes.io/name: \"mysql\"Used on: All Objects (typically used on\nworkload resources).The name of the application.One of the recommended labels.app.kubernetes.io/part-ofType: LabelExample: app.kubernetes.io/part-of: \"wordpress\"Used on: All Objects (typically used on\nworkload resources).The name of a higher-level application this object is part of.One of the recommended labels.app.kubernetes.io/versionType: LabelExample: app.kubernetes.io/version: \"5.7.21\"Used on: All Objects (typically used on\nworkload resources).The current version of the application.Common forms of values include:semantic versionthe Git revision hash\nfor the source code.One of the recommended labels.applyset.kubernetes.io/additional-namespaces (alpha)Type: AnnotationExample: applyset.kubernetes.io/additional-namespaces: \"namespace1,namespace2\"Used on: Objects being used as ApplySet parents.Use of this annotation is Alpha.\nFor Kubernetes version 1.34, you can use this annotation on Secrets,\nConfigMaps, or custom resources if the\nCustomResourceDefinition\ndefining them has the applyset.kubernetes.io/is-parent-type label.Part of the specification used to implement\nApplySet-based pruning in kubectl.\nThis annotation is applied to the parent object used to track an ApplySet to extend the scope of\nthe ApplySet beyond the parent object's own namespace (if any).\nThe value is a comma-separated list of the names of namespaces other than the parent's namespace\nin which objects are found.applyset.kubernetes.io/contains-group-kinds (alpha)Type: AnnotationExample: applyset.kubernetes.io/contains-group-kinds: \"certificates.cert-manager.io,configmaps,deployments.apps,secrets,services\"Used on: Objects being used as ApplySet parents.Use of this annotation is Alpha.\nFor Kubernetes version 1.34, you can use this annotation on Secrets, ConfigMaps,\nor custom resources if the CustomResourceDefinition\ndefining them has the applyset.kubernetes.io/is-parent-type label.Part of the specification used to implement\nApplySet-based pruning in kubectl.\nThis annotation is applied to the parent object used to track an ApplySet to optimize listing of\nApplySet member objects. It is optional in the ApplySet specification, as tools can perform discovery\nor use a different optimization. However, as of Kubernetes version 1.34,\nit is required by kubectl. When present, the value of this annotation must be a comma separated list\nof the group-kinds, in the fully-qualified name format, i.e. <resource>.<group>.applyset.kubernetes.io/contains-group-resources (deprecated)Type: AnnotationExample: applyset.kubernetes.io/contains-group-resources: \"certificates.cert-manager.io,configmaps,deployments.apps,secrets,services\"Used on: Objects being used as ApplySet parents.For Kubernetes version 1.34, you can use this annotation on Secrets, ConfigMaps,\nor custom resources if the CustomResourceDefinition\ndefining them has the applyset.kubernetes.io/is-parent-type label.Part of the specification used to implement\nApplySet-based pruning in kubectl.\nThis annotation is applied to the parent object used to track an ApplySet to optimize listing of\nApplySet member objects. It is optional in the ApplySet specification, as tools can perform discovery\nor use a different optimization. However, in Kubernetes version 1.34,\nit is required by kubectl. When present, the value of this annotation must be a comma separated list\nof the group-kinds, in the fully-qualified name format, i.e. <resource>.<group>.Note:This annotation is currently deprecated and replaced by applyset.kubernetes.io/contains-group-kinds,\nsupport for this will be removed in applyset beta or GA.applyset.kubernetes.io/id (alpha)Type: LabelExample: applyset.kubernetes.io/id: \"applyset-0eFHV8ySqp7XoShsGvyWFQD3s96yqwHmzc4e0HR1dsY-v1\"Used on: Objects being used as ApplySet parents.Use of this label is Alpha.\nFor Kubernetes version 1.34, you can use this label on Secrets, ConfigMaps,\nor custom resources if the CustomResourceDefinition\ndefining them has the applyset.kubernetes.io/is-parent-type label.Part of the specification used to implement\nApplySet-based pruning in kubectl.\nThis label is what makes an object an ApplySet parent object.\nIts value is the unique ID of the ApplySet, which is derived from the identity of the parent\nobject itself. This ID must be the base64 encoding (using the URL safe encoding of RFC4648) of\nthe hash of the group-kind-name-namespace of the object it is on, in the form:\n<base64(sha256(<name>.<namespace>.<kind>.<group>))>.\nThere is no relation between the value of this label and object UID.applyset.kubernetes.io/is-parent-type (alpha)Type: LabelExample: applyset.kubernetes.io/is-parent-type: \"true\"Used on: Custom Resource Definition (CRD)Use of this label is Alpha.\nPart of the specification used to implement\nApplySet-based pruning in kubectl.\nYou can set this label on a CustomResourceDefinition (CRD) to identify the custom resource type it\ndefines (not the CRD itself) as an allowed parent for an ApplySet.\nThe only permitted value for this label is \"true\"; if you want to mark a CRD as\nnot being a valid parent for ApplySets, omit this label.applyset.kubernetes.io/part-of (alpha)Type: LabelExample: applyset.kubernetes.io/part-of: \"applyset-0eFHV8ySqp7XoShsGvyWFQD3s96yqwHmzc4e0HR1dsY-v1\"Used on: All objects.Use of this label is Alpha.\nPart of the specification used to implement\nApplySet-based pruning in kubectl.\nThis label is what makes an object a member of an ApplySet.\nThe value of the label must match the value of the applyset.kubernetes.io/id\nlabel on the parent object.applyset.kubernetes.io/tooling (alpha)Type: AnnotationExample: applyset.kubernetes.io/tooling: \"kubectl/v1.34\"Used on: Objects being used as ApplySet parents.Use of this annotation is Alpha.\nFor Kubernetes version 1.34, you can use this annotation on Secrets,\nConfigMaps, or custom resources if the CustomResourceDefinitiondefining them has the\napplyset.kubernetes.io/is-parent-type label.Part of the specification used to implement\nApplySet-based pruning in kubectl.\nThis annotation is applied to the parent object used to track an ApplySet to indicate which\ntooling manages that ApplySet. Tooling should refuse to mutate ApplySets belonging to other tools.\nThe value must be in the format <toolname>/<semver>.apps.kubernetes.io/pod-index (beta)Type: LabelExample: apps.kubernetes.io/pod-index: \"0\"Used on: PodWhen a StatefulSet controller creates a Pod for the StatefulSet, it sets this label on that Pod.\nThe value of the label is the ordinal index of the pod being created.See Pod Index Label\nin the StatefulSet topic for more details.\nNote the PodIndexLabel\nfeature gate must be enabled for this label to be added to pods.resource.kubernetes.io/pod-claim-nameType: AnnotationExample: resource.kubernetes.io/pod-claim-name: \"my-pod-claim\"Used on: ResourceClaimThis annotation is assigned to generated ResourceClaims.\nIts value corresponds to the name of the resource claim in the .spec of any Pod(s) for which the ResourceClaim was created.\nThis annotation is an internal implementation detail of dynamic resource allocation.\nYou should not need to read or modify the value of this annotation.cluster-autoscaler.kubernetes.io/safe-to-evictType: AnnotationExample: cluster-autoscaler.kubernetes.io/safe-to-evict: \"true\"Used on: PodWhen this annotation is set to \"true\", the cluster autoscaler is allowed to evict a Pod\neven if other rules would normally prevent that.\nThe cluster autoscaler never evicts Pods that have this annotation explicitly set to\n\"false\"; you could set that on an important Pod that you want to keep running.\nIf this annotation is not set then the cluster autoscaler follows its Pod-level behavior.config.kubernetes.io/local-configType: AnnotationExample: config.kubernetes.io/local-config: \"true\"Used on: All objectsThis annotation is used in manifests to mark an object as local configuration that\nshould not be submitted to the Kubernetes API.A value of \"true\" for this annotation declares that the object is only consumed by\nclient-side tooling and should not be submitted to the API server.A value of \"false\" can be used to declare that the object should be submitted to\nthe API server even when it would otherwise be assumed to be local.This annotation is part of the Kubernetes Resource Model (KRM) Functions Specification,\nwhich is used by Kustomize and similar third-party tools.\nFor example, Kustomize removes objects with this annotation from its final build output.container.apparmor.security.beta.kubernetes.io/* (deprecated)Type: AnnotationExample: container.apparmor.security.beta.kubernetes.io/my-container: my-custom-profileUsed on: PodsThis annotation allows you to specify the AppArmor security profile for a container within a\nKubernetes pod. As of Kubernetes v1.30, this should be set with the appArmorProfile field instead.\nTo learn more, see the AppArmor tutorial.\nThe tutorial illustrates using AppArmor to restrict a container's abilities and access.The profile specified dictates the set of rules and restrictions that the containerized process must\nadhere to. This helps enforce security policies and isolation for your containers.internal.config.kubernetes.io/* (reserved prefix)Type: AnnotationUsed on: All objectsThis prefix is reserved for internal use by tools that act as orchestrators in accordance\nwith the Kubernetes Resource Model (KRM) Functions Specification.\nAnnotations with this prefix are internal to the orchestration process and are not persisted to\nthe manifests on the filesystem. In other words, the orchestrator tool should set these\nannotations when reading files from the local filesystem and remove them when writing the output\nof functions back to the filesystem.A KRM function must not modify annotations with this prefix, unless otherwise specified for a\ngiven annotation. This enables orchestrator tools to add additional internal annotations, without\nrequiring changes to existing functions.internal.config.kubernetes.io/pathType: AnnotationExample: internal.config.kubernetes.io/path: \"relative/file/path.yaml\"Used on: All objectsThis annotation records the slash-delimited, OS-agnostic, relative path to the manifest file the\nobject was loaded from. The path is relative to a fixed location on the filesystem, determined by\nthe orchestrator tool.This annotation is part of the Kubernetes Resource Model (KRM) Functions Specification, which is\nused by Kustomize and similar third-party tools.A KRM Function should not modify this annotation on input objects unless it is modifying the\nreferenced files. A KRM Function may include this annotation on objects it generates.internal.config.kubernetes.io/indexType: AnnotationExample: internal.config.kubernetes.io/index: \"2\"Used on: All objectsThis annotation records the zero-indexed position of the YAML document that contains the object\nwithin the manifest file the object was loaded from. Note that YAML documents are separated by\nthree dashes (---) and can each contain one object. When this annotation is not specified, a\nvalue of 0 is implied.This annotation is part of the Kubernetes Resource Model (KRM) Functions Specification,\nwhich is used by Kustomize and similar third-party tools.A KRM Function should not modify this annotation on input objects unless it is modifying the\nreferenced files. A KRM Function may include this annotation on objects it generates.kube-scheduler-simulator.sigs.k8s.io/bind-resultType: AnnotationExample: kube-scheduler-simulator.sigs.k8s.io/bind-result: '{\"DefaultBinder\":\"success\"}'Used on: PodThis annotation records the result of bind scheduler plugins, used by https://sigs.k8s.io/kube-scheduler-simulator.kube-scheduler-simulator.sigs.k8s.io/filter-resultType: AnnotationExample:kube-scheduler-simulator.sigs.k8s.io/filter-result: >-\n{\"node-282x7\":{\"AzureDiskLimits\":\"passed\",\"EBSLimits\":\"passed\",\"GCEPDLimits\":\"passed\",\"InterPodAffinity\":\"passed\",\"NodeAffinity\":\"passed\",\"NodeName\":\"passed\",\"NodePorts\":\"passed\",\"NodeResourcesFit\":\"passed\",\"NodeUnschedulable\":\"passed\",\"NodeVolumeLimits\":\"passed\",\"PodTopologySpread\":\"passed\",\"TaintToleration\":\"passed\",\"VolumeBinding\":\"passed\",\"VolumeRestrictions\":\"passed\",\"VolumeZone\":\"passed\"},\"node-gp9t4\":{\"AzureDiskLimits\":\"passed\",\"EBSLimits\":\"passed\",\"GCEPDLimits\":\"passed\",\"InterPodAffinity\":\"passed\",\"NodeAffinity\":\"passed\",\"NodeName\":\"passed\",\"NodePorts\":\"passed\",\"NodeResourcesFit\":\"passed\",\"NodeUnschedulable\":\"passed\",\"NodeVolumeLimits\":\"passed\",\"PodTopologySpread\":\"passed\",\"TaintToleration\":\"passed\",\"VolumeBinding\":\"passed\",\"VolumeRestrictions\":\"passed\",\"VolumeZone\":\"passed\"}}\nUsed on: PodThis annotation records the result of filter scheduler plugins, used by https://sigs.k8s.io/kube-scheduler-simulator.kube-scheduler-simulator.sigs.k8s.io/finalscore-resultType: AnnotationExample:kube-scheduler-simulator.sigs.k8s.io/finalscore-result: >-\n{\"node-282x7\":{\"ImageLocality\":\"0\",\"InterPodAffinity\":\"0\",\"NodeAffinity\":\"0\",\"NodeNumber\":\"0\",\"NodeResourcesBalancedAllocation\":\"76\",\"NodeResourcesFit\":\"73\",\"PodTopologySpread\":\"200\",\"TaintToleration\":\"300\",\"VolumeBinding\":\"0\"},\"node-gp9t4\":{\"ImageLocality\":\"0\",\"InterPodAffinity\":\"0\",\"NodeAffinity\":\"0\",\"NodeNumber\":\"0\",\"NodeResourcesBalancedAllocation\":\"76\",\"NodeResourcesFit\":\"73\",\"PodTopologySpread\":\"200\",\"TaintToleration\":\"300\",\"VolumeBinding\":\"0\"}}\nUsed on: PodThis annotation records the final scores that the scheduler calculates from the scores from score scheduler plugins,\nused by https://sigs.k8s.io/kube-scheduler-simulator.kube-scheduler-simulator.sigs.k8s.io/permit-resultType: AnnotationExample: kube-scheduler-simulator.sigs.k8s.io/permit-result: '{\"CustomPermitPlugin\":\"success\"}'Used on: PodThis annotation records the result of permit scheduler plugins, used by https://sigs.k8s.io/kube-scheduler-simulator.kube-scheduler-simulator.sigs.k8s.io/permit-result-timeoutType: AnnotationExample: kube-scheduler-simulator.sigs.k8s.io/permit-result-timeout: '{\"CustomPermitPlugin\":\"10s\"}'Used on: PodThis annotation records the timeouts returned from permit scheduler plugins, used by https://sigs.k8s.io/kube-scheduler-simulator.kube-scheduler-simulator.sigs.k8s.io/postfilter-resultType: AnnotationExample: kube-scheduler-simulator.sigs.k8s.io/postfilter-result: '{\"DefaultPreemption\":\"success\"}'Used on: PodThis annotation records the result of postfilter scheduler plugins, used by https://sigs.k8s.io/kube-scheduler-simulator.kube-scheduler-simulator.sigs.k8s.io/prebind-resultType: AnnotationExample: kube-scheduler-simulator.sigs.k8s.io/prebind-result: '{\"VolumeBinding\":\"success\"}'Used on: PodThis annotation records the result of prebind scheduler plugins, used by https://sigs.k8s.io/kube-scheduler-simulator.kube-scheduler-simulator.sigs.k8s.io/prefilter-resultType: AnnotationExample: kube-scheduler-simulator.sigs.k8s.io/prebind-result: '{\"NodeAffinity\":\"[\\\"node-\\a\"]\"}'Used on: PodThis annotation records the PreFilter result of prefilter scheduler plugins, used by https://sigs.k8s.io/kube-scheduler-simulator.kube-scheduler-simulator.sigs.k8s.io/prefilter-result-statusType: AnnotationExample:kube-scheduler-simulator.sigs.k8s.io/prefilter-result-status: >-\n{\"InterPodAffinity\":\"success\",\"NodeAffinity\":\"success\",\"NodePorts\":\"success\",\"NodeResourcesFit\":\"success\",\"PodTopologySpread\":\"success\",\"VolumeBinding\":\"success\",\"VolumeRestrictions\":\"success\"}\nUsed on: PodThis annotation records the result of prefilter scheduler plugins, used by https://sigs.k8s.io/kube-scheduler-simulator.kube-scheduler-simulator.sigs.k8s.io/prescore-resultType: AnnotationExample:\nkube-scheduler-simulator.sigs.k8s.io/prescore-result: >-\n{\"InterPodAffinity\":\"success\",\"NodeAffinity\":\"success\",\"NodeNumber\":\"success\",\"PodTopologySpread\":\"success\",\"TaintToleration\":\"success\"}\nUsed on: PodThis annotation records the result of prefilter scheduler plugins, used by https://sigs.k8s.io/kube-scheduler-simulator.kube-scheduler-simulator.sigs.k8s.io/reserve-resultType: AnnotationExample: kube-scheduler-simulator.sigs.k8s.io/reserve-result: '{\"VolumeBinding\":\"success\"}'Used on: PodThis annotation records the result of reserve scheduler plugins, used by https://sigs.k8s.io/kube-scheduler-simulator.kube-scheduler-simulator.sigs.k8s.io/result-historyType: AnnotationExample: kube-scheduler-simulator.sigs.k8s.io/result-history: '[]'Used on: PodThis annotation records all the past scheduling results from scheduler plugins, used by https://sigs.k8s.io/kube-scheduler-simulator.kube-scheduler-simulator.sigs.k8s.io/score-resultType: Annotation\nkube-scheduler-simulator.sigs.k8s.io/score-result: >-\n{\"node-282x7\":{\"ImageLocality\":\"0\",\"InterPodAffinity\":\"0\",\"NodeAffinity\":\"0\",\"NodeNumber\":\"0\",\"NodeResourcesBalancedAllocation\":\"76\",\"NodeResourcesFit\":\"73\",\"PodTopologySpread\":\"0\",\"TaintToleration\":\"0\",\"VolumeBinding\":\"0\"},\"node-gp9t4\":{\"ImageLocality\":\"0\",\"InterPodAffinity\":\"0\",\"NodeAffinity\":\"0\",\"NodeNumber\":\"0\",\"NodeResourcesBalancedAllocation\":\"76\",\"NodeResourcesFit\":\"73\",\"PodTopologySpread\":\"0\",\"TaintToleration\":\"0\",\"VolumeBinding\":\"0\"}}\nUsed on: PodThis annotation records the result of score scheduler plugins, used by https://sigs.k8s.io/kube-scheduler-simulator.kube-scheduler-simulator.sigs.k8s.io/selected-nodeType: AnnotationExample: kube-scheduler-simulator.sigs.k8s.io/selected-node: node-282x7Used on: PodThis annotation records the node that is selected by the scheduling cycle, used by https://sigs.k8s.io/kube-scheduler-simulator.kubernetes.io/archType: LabelExample: kubernetes.io/arch: \"amd64\"Used on: NodeThe Kubelet populates this with runtime.GOARCH as defined by Go.\nThis can be handy if you are mixing ARM and x86 nodes.kubernetes.io/osType: LabelExample: kubernetes.io/os: \"linux\"Used on: Node, PodFor nodes, the kubelet populates this with runtime.GOOS as defined by Go. This can be handy if you are\nmixing operating systems in your cluster (for example: mixing Linux and Windows nodes).You can also set this label on a Pod. Kubernetes allows you to set any value for this label;\nif you use this label, you should nevertheless set it to the Go runtime.GOOS string for the operating\nsystem that this Pod actually works with.When the kubernetes.io/os label value for a Pod does not match the label value on a Node,\nthe kubelet on the node will not admit the Pod. However, this is not taken into account by\nthe kube-scheduler. Alternatively, the kubelet refuses to run a Pod where you have specified a Pod OS, if\nthis isn't the same as the operating system for the node where that kubelet is running. Just\nlook for Pods OS for more details.kubernetes.io/metadata.nameType: LabelExample: kubernetes.io/metadata.name: \"mynamespace\"Used on: NamespacesThe Kubernetes API server (part of the control plane)\nsets this label on all namespaces. The label value is set\nto the name of the namespace. You can't change this label's value.This is useful if you want to target a specific namespace with a label\nselector.kubernetes.io/limit-rangerType: AnnotationExample: kubernetes.io/limit-ranger: \"LimitRanger plugin set: cpu, memory request for container nginx; cpu, memory limit for container nginx\"Used on: PodKubernetes by default doesn't provide any resource limit, that means unless you explicitly define\nlimits, your container can consume unlimited CPU and memory.\nYou can define a default request or default limit for pods. You do this by creating a LimitRange\nin the relevant namespace. Pods deployed after you define a LimitRange will have these limits\napplied to them.\nThe annotation kubernetes.io/limit-ranger records that resource defaults were specified for the Pod,\nand they were applied successfully.\nFor more details, read about LimitRanges.kubernetes.io/config.hashType: AnnotationExample: kubernetes.io/config.hash: \"df7cc47f8477b6b1226d7d23a904867b\"Used on: PodWhen the kubelet creates a static Pod based on a given manifest, it attaches this annotation\nto the static Pod. The value of the annotation is the UID of the Pod.\nNote that the kubelet also sets the .spec.nodeName to the current node name as if the Pod\nwas scheduled to the node.kubernetes.io/config.mirrorType: AnnotationExample: kubernetes.io/config.mirror: \"df7cc47f8477b6b1226d7d23a904867b\"Used on: PodFor a static Pod created by the kubelet on a node, a mirror Pod\nis created on the API server. The kubelet adds an annotation to indicate that this Pod is\nactually a mirror Pod. The annotation value is copied from the kubernetes.io/config.hash\nannotation, which is the UID of the Pod.When updating a Pod with this annotation set, the annotation cannot be changed or removed.\nIf a Pod doesn't have this annotation, it cannot be added during a Pod update.kubernetes.io/config.sourceType: AnnotationExample: kubernetes.io/config.source: \"file\"Used on: PodThis annotation is added by the kubelet to indicate where the Pod comes from.\nFor static Pods, the annotation value could be one of file or http depending\non where the Pod manifest is located. For a Pod created on the API server and then\nscheduled to the current node, the annotation value is api.kubernetes.io/config.seenType: AnnotationExample: kubernetes.io/config.seen: \"2023-10-27T04:04:56.011314488Z\"Used on: PodWhen the kubelet sees a Pod for the first time, it may add this annotation to\nthe Pod with a value of current timestamp in the RFC3339 format.addonmanager.kubernetes.io/modeType: LabelExample: addonmanager.kubernetes.io/mode: \"Reconcile\"Used on: All objectsTo specify how an add-on should be managed, you can use the addonmanager.kubernetes.io/mode label.\nThis label can have one of three values: Reconcile, EnsureExists, or Ignore.Reconcile: Addon resources will be periodically reconciled with the expected state.\nIf there are any differences, the add-on manager will recreate, reconfigure or delete\nthe resources as needed. This is the default mode if no label is specified.EnsureExists: Addon resources will be checked for existence only but will not be modified\nafter creation. The add-on manager will create or re-create the resources when there is\nno instance of the resource with that name.Ignore: Addon resources will be ignored. This mode is useful for add-ons that are not\ncompatible with the add-on manager or that are managed by another controller.For more details, see Addon-manager.beta.kubernetes.io/arch (deprecated)Type: LabelThis label has been deprecated. Please use kubernetes.io/arch instead.beta.kubernetes.io/os (deprecated)Type: LabelThis label has been deprecated. Please use kubernetes.io/os instead.kube-aggregator.kubernetes.io/automanagedType: LabelExample: kube-aggregator.kubernetes.io/automanaged: \"onstart\"Used on: APIServiceThe kube-apiserver sets this label on any APIService object that the API server\nhas created automatically. The label marks how the control plane should manage that\nAPIService. You should not add, modify, or remove this label by yourself.Note:Automanaged APIService objects are deleted by kube-apiserver when it has no built-in\nor custom resource API corresponding to the API group/version of the APIService.There are two possible values:onstart: The APIService should be reconciled when an API server starts up, but not otherwise.true: The API server should reconcile this APIService continuously.service.alpha.kubernetes.io/tolerate-unready-endpoints (deprecated)Type: AnnotationUsed on: StatefulSetThis annotation on a Service denotes if the Endpoints controller should go ahead and create\nEndpoints for unready Pods. Endpoints of these Services retain their DNS records and continue\nreceiving traffic for the Service from the moment the kubelet starts all containers in the pod\nand marks it Running, til the kubelet stops all containers and deletes the pod from\nthe API server.autoscaling.alpha.kubernetes.io/behavior (deprecated)Type: AnnotationUsed on: HorizontalPodAutoscalerThis annotation was used to configure the scaling behavior for a HorizontalPodAutoscaler (HPA) in earlier Kubernetes versions.\nIt allowed you to specify how the HPA should scale pods up or down, including setting stabilization windows and scaling policies.\nSetting this annotation has no effect in any supported release of Kubernetes.kubernetes.io/hostnameType: LabelExample: kubernetes.io/hostname: \"ip-172-20-114-199.ec2.internal\"Used on: NodeThe Kubelet populates this label with the hostname of the node. Note that the hostname\ncan be changed from the \"actual\" hostname by passing the --hostname-override flag to\nthe kubelet.This label is also used as part of the topology hierarchy.\nSee topology.kubernetes.io/zone for more information.kubernetes.io/change-causeType: AnnotationExample: kubernetes.io/change-cause: \"kubectl edit --record deployment foo\"Used on: All ObjectsThis annotation is a best guess at why something was changed.It is populated when adding --record to a kubectl command that may change an object.kubernetes.io/descriptionType: AnnotationExample: kubernetes.io/description: \"Description of K8s object.\"Used on: All ObjectsThis annotation is used for describing specific behaviour of given object.kubernetes.io/enforce-mountable-secrets (deprecated)Type: AnnotationExample: kubernetes.io/enforce-mountable-secrets: \"true\"Used on: ServiceAccountNote:kubernetes.io/enforce-mountable-secrets is deprecated since Kubernetes v1.32. Use separate namespaces to isolate access to mounted secrets.The value for this annotation must be true to take effect.\nWhen you set this annotation to \"true\", Kubernetes enforces the following rules for\nPods running as this ServiceAccount:Secrets mounted as volumes must be listed in the ServiceAccount's secrets field.Secrets referenced in envFrom for containers (including sidecar containers and init containers)\nmust also be listed in the ServiceAccount's secrets field.\nIf any container in a Pod references a Secret not listed in the ServiceAccount's secrets field\n(and even if the reference is marked as optional), then the Pod will fail to start,\nand an error indicating the non-compliant secret reference will be generated.Secrets referenced in a Pod's imagePullSecrets must be present in the\nServiceAccount's imagePullSecrets field, the Pod will fail to start,\nand an error indicating the non-compliant image pull secret reference will be generated.When you create or update a Pod, these rules are checked. If a Pod doesn't follow them, it won't start and you'll see an error message.\nIf a Pod is already running and you change the kubernetes.io/enforce-mountable-secrets annotation\nto true, or you edit the associated ServiceAccount to remove the reference to a Secret\nthat the Pod is already using, the Pod continues to run.node.kubernetes.io/exclude-from-external-load-balancersType: LabelExample: node.kubernetes.io/exclude-from-external-load-balancersUsed on: NodeYou can add labels to particular worker nodes to exclude them from the list of backend servers used by external load balancers.\nThe following command can be used to exclude a worker node from the list of backend servers in a\nbackend set:kubectl label nodes <node-name> node.kubernetes.io/exclude-from-external-load-balancers=true\ncontroller.kubernetes.io/pod-deletion-costType: AnnotationExample: controller.kubernetes.io/pod-deletion-cost: \"10\"Used on: PodThis annotation is used to set Pod Deletion Cost\nwhich allows users to influence ReplicaSet downscaling order.\nThe annotation value parses into an int32 type.cluster-autoscaler.kubernetes.io/enable-ds-evictionType: AnnotationExample: cluster-autoscaler.kubernetes.io/enable-ds-eviction: \"true\"Used on: PodThis annotation controls whether a DaemonSet pod should be evicted by a ClusterAutoscaler.\nThis annotation needs to be specified on DaemonSet pods in a DaemonSet manifest.\nWhen this annotation is set to \"true\", the ClusterAutoscaler is allowed to evict\na DaemonSet Pod, even if other rules would normally prevent that.\nTo disallow the ClusterAutoscaler from evicting DaemonSet pods,\nyou can set this annotation to \"false\" for important DaemonSet pods.\nIf this annotation is not set, then the ClusterAutoscaler follows its overall behavior\n(i.e evict the DaemonSets based on its configuration).Note:This annotation only impacts DaemonSet Pods.kubernetes.io/ingress-bandwidthType: AnnotationExample: kubernetes.io/ingress-bandwidth: 10MUsed on: PodYou can apply quality-of-service traffic shaping to a pod and effectively limit its available\nbandwidth. Ingress traffic to a Pod is handled by shaping queued packets to effectively\nhandle data. To limit the bandwidth on a Pod, write an object definition JSON file and specify\nthe data traffic speed using kubernetes.io/ingress-bandwidth annotation. The unit used for\nspecifying ingress rate is bits per second, as a\nQuantity.\nFor example, 10M means 10 megabits per second.Note:Ingress traffic shaping annotation is an experimental feature.\nIf you want to enable traffic shaping support, you must add the bandwidth plugin to your CNI\nconfiguration file (default /etc/cni/net.d) and ensure that the binary is included in your CNI\nbin dir (default /opt/cni/bin).kubernetes.io/egress-bandwidthType: AnnotationExample: kubernetes.io/egress-bandwidth: 10MUsed on: PodEgress traffic from a Pod is handled by policing, which simply drops packets in excess of the\nconfigured rate. The limits you place on a Pod do not affect the bandwidth of other Pods.\nTo limit the bandwidth on a Pod, write an object definition JSON file and specify the data traffic\nspeed using kubernetes.io/egress-bandwidth annotation. The unit used for specifying egress rate\nis bits per second, as a Quantity.\nFor example, 10M means 10 megabits per second.Note:Egress traffic shaping annotation is an experimental feature.\nIf you want to enable traffic shaping support, you must add the bandwidth plugin to your CNI\nconfiguration file (default /etc/cni/net.d) and ensure that the binary is included in your CNI\nbin dir (default /opt/cni/bin).beta.kubernetes.io/instance-type (deprecated)Type: LabelNote:Starting in v1.17, this label is deprecated in favor of\nnode.kubernetes.io/instance-type.node.kubernetes.io/instance-typeType: LabelExample: node.kubernetes.io/instance-type: \"m3.medium\"Used on: NodeThe Kubelet populates this with the instance type as defined by the cloud provider.\nThis will be set only if you are using a cloud provider. This setting is handy\nif you want to target certain workloads to certain instance types, but typically you want\nto rely on the Kubernetes scheduler to perform resource-based scheduling.\nYou should aim to schedule based on properties rather than on instance types\n(for example: require a GPU, instead of requiring a g2.2xlarge).failure-domain.beta.kubernetes.io/region (deprecated)Type: LabelNote:Starting in v1.17, this label is deprecated in favor of\ntopology.kubernetes.io/region.failure-domain.beta.kubernetes.io/zone (deprecated)Type: LabelNote:Starting in v1.17, this label is deprecated in favor of\ntopology.kubernetes.io/zone.pv.kubernetes.io/bind-completedType: AnnotationExample: pv.kubernetes.io/bind-completed: \"yes\"Used on: PersistentVolumeClaimWhen this annotation is set on a PersistentVolumeClaim (PVC), that indicates that the lifecycle\nof the PVC has passed through initial binding setup. When present, that information changes\nhow the control plane interprets the state of PVC objects.\nThe value of this annotation does not matter to Kubernetes.pv.kubernetes.io/bound-by-controllerType: AnnotationExample: pv.kubernetes.io/bound-by-controller: \"yes\"Used on: PersistentVolume, PersistentVolumeClaimIf this annotation is set on a PersistentVolume or PersistentVolumeClaim, it indicates that a\nstorage binding (PersistentVolume \u2192 PersistentVolumeClaim, or PersistentVolumeClaim \u2192 PersistentVolume)\nwas installed by the controller.\nIf the annotation isn't set, and there is a storage binding in place, the absence of that\nannotation means that the binding was done manually.\nThe value of this annotation does not matter.pv.kubernetes.io/provisioned-byType: AnnotationExample: pv.kubernetes.io/provisioned-by: \"kubernetes.io/rbd\"Used on: PersistentVolumeThis annotation is added to a PersistentVolume(PV) that has been dynamically provisioned by Kubernetes.\nIts value is the name of volume plugin that created the volume. It serves both users (to show where a PV\ncomes from) and Kubernetes (to recognize dynamically provisioned PVs in its decisions).pv.kubernetes.io/migrated-toType: AnnotationExample: pv.kubernetes.io/migrated-to: pd.csi.storage.gke.ioUsed on: PersistentVolume, PersistentVolumeClaimIt is added to a PersistentVolume(PV) and PersistentVolumeClaim(PVC) that is supposed to be\ndynamically provisioned/deleted by its corresponding CSI driver through the CSIMigration feature gate.\nWhen this annotation is set, the Kubernetes components will \"stand-down\" and the\nexternal-provisioner will act on the objects.statefulset.kubernetes.io/pod-nameType: LabelExample: statefulset.kubernetes.io/pod-name: \"mystatefulset-7\"Used on: PodWhen a StatefulSet controller creates a Pod for the StatefulSet, the control plane\nsets this label on that Pod. The value of the label is the name of the Pod being created.See Pod Name Label\nin the StatefulSet topic for more details.scheduler.alpha.kubernetes.io/node-selectorType: AnnotationExample: scheduler.alpha.kubernetes.io/node-selector: \"name-of-node-selector\"Used on: NamespaceThe PodNodeSelector\nuses this annotation key to assign node selectors to pods in namespaces.topology.kubernetes.io/regionType: LabelExample: topology.kubernetes.io/region: \"us-east-1\"Used on: Node, PersistentVolumeSee topology.kubernetes.io/zone.topology.kubernetes.io/zoneType: LabelExample: topology.kubernetes.io/zone: \"us-east-1c\"Used on: Node, PersistentVolumeOn Node: The kubelet or the external cloud-controller-manager populates this\nwith the information from the cloud provider. This will be set only if you are using\na cloud provider. However, you can consider setting this on nodes if it makes sense\nin your topology.On PersistentVolume: topology-aware volume provisioners will automatically set\nnode affinity constraints on a PersistentVolume.A zone represents a logical failure domain. It is common for Kubernetes clusters to\nspan multiple zones for increased availability. While the exact definition of a zone\nis left to infrastructure implementations, common properties of a zone include\nvery low network latency within a zone, no-cost network traffic within a zone, and\nfailure independence from other zones.\nFor example, nodes within a zone might share a network switch, but nodes in different\nzones should not.A region represents a larger domain, made up of one or more zones.\nIt is uncommon for Kubernetes clusters to span multiple regions,\nWhile the exact definition of a zone or region is left to infrastructure implementations,\ncommon properties of a region include higher network latency between them than within them,\nnon-zero cost for network traffic between them, and failure independence from other zones or regions.\nFor example, nodes within a region might share power infrastructure (e.g. a UPS or generator),\nbut nodes in different regions typically would not.Kubernetes makes a few assumptions about the structure of zones and regions:regions and zones are hierarchical: zones are strict subsets of regions and\nno zone can be in 2 regionszone names are unique across regions; for example region \"africa-east-1\" might be comprised\nof zones \"africa-east-1a\" and \"africa-east-1b\"It should be safe to assume that topology labels do not change.\nEven though labels are strictly mutable, consumers of them can assume that a given node\nis not going to be moved between zones without being destroyed and recreated.Kubernetes can use this information in various ways.\nFor example, the scheduler automatically tries to spread the Pods in a ReplicaSet across nodes\nin a single-zone cluster (to reduce the impact of node failures, see\nkubernetes.io/hostname).\nWith multiple-zone clusters, this spreading behavior also applies to zones (to reduce the impact of zone failures).\nThis is achieved via SelectorSpreadPriority.SelectorSpreadPriority is a best effort placement. If the zones in your cluster are\nheterogeneous (for example: different numbers of nodes, different types of nodes, or different pod\nresource requirements), this placement might prevent equal spreading of your Pods across zones.\nIf desired, you can use homogeneous zones (same number and types of nodes) to reduce the probability\nof unequal spreading.The scheduler (through the VolumeZonePredicate predicate) also will ensure that Pods,\nthat claim a given volume, are only placed into the same zone as that volume.\nVolumes cannot be attached across zones.If PersistentVolumeLabel does not support automatic labeling of your PersistentVolumes,\nyou should consider adding the labels manually (or adding support for PersistentVolumeLabel).\nWith PersistentVolumeLabel, the scheduler prevents Pods from mounting volumes in a different zone.\nIf your infrastructure doesn't have this constraint, you don't need to add the zone labels to the volumes at all.volume.beta.kubernetes.io/storage-provisioner (deprecated)Type: AnnotationExample: volume.beta.kubernetes.io/storage-provisioner: \"k8s.io/minikube-hostpath\"Used on: PersistentVolumeClaimThis annotation has been deprecated since v1.23.\nSee volume.kubernetes.io/storage-provisioner.volume.beta.kubernetes.io/storage-class (deprecated)Type: AnnotationExample: volume.beta.kubernetes.io/storage-class: \"example-class\"Used on: PersistentVolume, PersistentVolumeClaimThis annotation can be used for PersistentVolume(PV) or PersistentVolumeClaim(PVC)\nto specify the name of StorageClass.\nWhen both the storageClassName attribute and the volume.beta.kubernetes.io/storage-class\nannotation are specified, the annotation volume.beta.kubernetes.io/storage-class\ntakes precedence over the storageClassName attribute.This annotation has been deprecated. Instead, set the\nstorageClassName field\nfor the PersistentVolumeClaim or PersistentVolume.volume.beta.kubernetes.io/mount-options (deprecated)Type: AnnotationExample : volume.beta.kubernetes.io/mount-options: \"ro,soft\"Used on: PersistentVolumeA Kubernetes administrator can specify additional\nmount options\nfor when a PersistentVolume is mounted on a node.volume.kubernetes.io/storage-provisionerType: AnnotationUsed on: PersistentVolumeClaimThis annotation is added to a PVC that is supposed to be dynamically provisioned.\nIts value is the name of a volume plugin that is supposed to provision a volume\nfor this PVC.volume.kubernetes.io/selected-nodeType: AnnotationUsed on: PersistentVolumeClaimThis annotation is added to a PVC that is triggered by a scheduler to be\ndynamically provisioned. Its value is the name of the selected node.volumes.kubernetes.io/controller-managed-attach-detachType: AnnotationUsed on: NodeIf a node has the annotation volumes.kubernetes.io/controller-managed-attach-detach,\nits storage attach and detach operations are being managed by the volume attach/detach\ncontroller.The value of the annotation isn't important.node.kubernetes.io/windows-buildType: LabelExample: node.kubernetes.io/windows-build: \"10.0.17763\"Used on: NodeWhen the kubelet is running on Microsoft Windows, it automatically labels its Node\nto record the version of Windows Server in use.The label's value is in the format \"MajorVersion.MinorVersion.BuildNumber\".storage.alpha.kubernetes.io/migrated-pluginsType: AnnotationExample:storage.alpha.kubernetes.io/migrated-plugins: \"kubernetes.io/cinder\"Used on: CSINode (an extension API)This annotation is automatically added for the CSINode object that maps to a node that\ninstalls CSIDriver. This annotation shows the in-tree plugin name of the migrated plugin. Its\nvalue depends on your cluster's in-tree cloud provider storage type.For example, if the in-tree cloud provider storage type is CSIMigrationvSphere, the CSINodes instance for the node should be updated with:\nstorage.alpha.kubernetes.io/migrated-plugins: \"kubernetes.io/vsphere-volume\"service.kubernetes.io/headlessType: LabelExample: service.kubernetes.io/headless: \"\"Used on: EndpointsThe control plane adds this label to an Endpoints object when the owning Service is headless.\nTo learn more, read Headless Services.service.kubernetes.io/topology-aware-hints (deprecated)Example: service.kubernetes.io/topology-aware-hints: \"Auto\"Used on: ServiceThis annotation was used for enabling topology aware hints on Services. Topology aware\nhints have since been renamed: the concept is now called\ntopology aware routing.\nSetting the annotation to Auto, on a Service, configured the Kubernetes control plane to\nadd topology hints on EndpointSlices associated with that Service. You can also explicitly\nset the annotation to Disabled.If you are running a version of Kubernetes older than 1.34,\ncheck the documentation for that Kubernetes version to see how topology aware routing\nworks in that release.There are no other valid values for this annotation. If you don't want topology aware hints\nfor a Service, don't add this annotation.service.kubernetes.io/topology-modeType: AnnotationExample: service.kubernetes.io/topology-mode: AutoUsed on: ServiceThis annotation provides a way to define how Services handle network topology;\nfor example, you can configure a Service so that Kubernetes prefers keeping traffic between\na client and server within a single topology zone.\nIn some cases this can help reduce costs or improve network performance.See Topology Aware Routing\nfor more details.kubernetes.io/service-nameType: LabelExample: kubernetes.io/service-name: \"my-website\"Used on: EndpointSliceKubernetes associates EndpointSlices with\nServices using this label.This label records the name of the\nService that the EndpointSlice is backing. All EndpointSlices should have this label set to\nthe name of their associated Service.kubernetes.io/service-account.nameType: AnnotationExample: kubernetes.io/service-account.name: \"sa-name\"Used on: SecretThis annotation records the name of the\nServiceAccount that the token (stored in the Secret of type kubernetes.io/service-account-token)\nrepresents.kubernetes.io/service-account.uidType: AnnotationExample: kubernetes.io/service-account.uid: da68f9c6-9d26-11e7-b84e-002dc52800daUsed on: SecretThis annotation records the unique ID of the\nServiceAccount that the token (stored in the Secret of type kubernetes.io/service-account-token)\nrepresents.kubernetes.io/legacy-token-last-usedType: LabelExample: kubernetes.io/legacy-token-last-used: 2022-10-24Used on: SecretThe control plane only adds this label to Secrets that have the type\nkubernetes.io/service-account-token.\nThe value of this label records the date (ISO 8601 format, UTC time zone) when the control plane\nlast saw a request where the client authenticated using the service account token.If a legacy token was last used before the cluster gained the feature (added in Kubernetes v1.26),\nthen the label isn't set.kubernetes.io/legacy-token-invalid-sinceType: LabelExample: kubernetes.io/legacy-token-invalid-since: 2023-10-27Used on: SecretThe control plane automatically adds this label to auto-generated Secrets that\nhave the type kubernetes.io/service-account-token. This label marks the\nSecret-based token as invalid for authentication. The value of this label\nrecords the date (ISO 8601 format, UTC time zone) when the control plane detects\nthat the auto-generated Secret has not been used for a specified duration\n(defaults to one year).endpoints.kubernetes.io/managed-by (deprecated)Type: LabelExample: endpoints.kubernetes.io/managed-by: endpoint-controllerUsed on: EndpointsThis label is used internally to mark Endpoints objects that were created by\nKubernetes (as opposed to Endpoints created by users or external controllers).Note:The Endpoints\nAPI is deprecated in favor of\nEndpointSlice.endpointslice.kubernetes.io/managed-byType: LabelExample: endpointslice.kubernetes.io/managed-by: endpointslice-controller.k8s.ioUsed on: EndpointSlicesThe label is used to indicate the controller or entity that manages the EndpointSlice. This label\naims to enable different EndpointSlice objects to be managed by different controllers or entities\nwithin the same cluster. The value endpointslice-controller.k8s.io indicates an\nEndpointSlice object that was created automatically by Kubernetes for a Service with a\nselectors.endpointslice.kubernetes.io/skip-mirrorType: LabelExample: endpointslice.kubernetes.io/skip-mirror: \"true\"Used on: EndpointsThe label can be set to \"true\" on an Endpoints resource to indicate that the\nEndpointSliceMirroring controller should not mirror this resource with EndpointSlices.service.kubernetes.io/service-proxy-nameType: LabelExample: service.kubernetes.io/service-proxy-name: \"foo-bar\"Used on: ServiceSetting a value for this label tells kube-proxy to ignore this service for proxying purposes.\nThis allows for use of alternative proxy implementations for this service (e.g. running\na DaemonSet that manages nftables its own way). Multiple alternative proxy implementations\ncould be active simultaneously using this field, e.g. by having a value unique to each\nalternative proxy implementation to be responsible for their respective services.experimental.windows.kubernetes.io/isolation-type (deprecated)Type: AnnotationExample: experimental.windows.kubernetes.io/isolation-type: \"hyperv\"Used on: PodThe annotation is used to run Windows containers with Hyper-V isolation.Note:Starting from v1.20, this annotation is deprecated.\nExperimental Hyper-V support was removed in 1.21.ingressclass.kubernetes.io/is-default-classType: AnnotationExample: ingressclass.kubernetes.io/is-default-class: \"true\"Used on: IngressClassWhen a IngressClass resource has this annotation set to \"true\", new Ingress resource\nwithout a class specified will be assigned this default class.nginx.ingress.kubernetes.io/configuration-snippetType: AnnotationExample: nginx.ingress.kubernetes.io/configuration-snippet: \" more_set_headers \\\"Request-Id: $req_id\\\";\\nmore_set_headers \\\"Example: 42\\\";\\n\"Used on: IngressYou can use this annotation to set extra configuration on an Ingress that\nuses the NGINX Ingress Controller.\nThe configuration-snippet annotation is ignored\nby default since version 1.9.0 of the ingress controller.\nThe NGINX ingress controller setting allow-snippet-annotations.\nhas to be explicitly enabled to use this annotation.\nEnabling the annotation can be dangerous in a multi-tenant cluster, as it can lead people with otherwise\nlimited permissions being able to retrieve all Secrets in the cluster.kubernetes.io/ingress.class (deprecated)Type: AnnotationUsed on: IngressNote:Starting in v1.18, this annotation is deprecated in favor of spec.ingressClassName.kubernetes.io/cluster-service (deprecated)Type: LabelExample: kubernetes.io/cluster-service: \"true\"Used on: ServiceThis label indicates that the Service provides a service to the cluster, if the value is set to true.\nWhen you run kubectl cluster-info, the tool queries for Services with this label set to true.However, setting this label on any Service is deprecated.storageclass.kubernetes.io/is-default-classType: AnnotationExample: storageclass.kubernetes.io/is-default-class: \"true\"Used on: StorageClassWhen a single StorageClass resource has this annotation set to \"true\", new PersistentVolumeClaim\nresource without a class specified will be assigned this default class.alpha.kubernetes.io/provided-node-ip (alpha)Type: AnnotationExample: alpha.kubernetes.io/provided-node-ip: \"10.0.0.1\"Used on: NodeThe kubelet can set this annotation on a Node to denote its configured IPv4 and/or IPv6 address.When kubelet is started with the --cloud-provider flag set to any value (includes both external\nand legacy in-tree cloud providers), it sets this annotation on the Node to denote an IP address\nset from the command line flag (--node-ip). This IP is verified with the cloud provider as valid\nby the cloud-controller-manager.batch.kubernetes.io/job-completion-indexType: Annotation, LabelExample: batch.kubernetes.io/job-completion-index: \"3\"Used on: PodThe Job controller in the kube-controller-manager sets this as a label and annotation for Pods\ncreated with Indexed completion mode.Note the PodIndexLabel\nfeature gate must be enabled for this to be added as a pod label,\notherwise it will just be an annotation.batch.kubernetes.io/cronjob-scheduled-timestampType: AnnotationExample: batch.kubernetes.io/cronjob-scheduled-timestamp: \"2016-05-19T03:00:00-07:00\"Used on: Jobs and Pods controlled by CronJobsThis annotation is used to record the original (expected) creation timestamp for a Job,\nwhen that Job is part of a CronJob.\nThe control plane sets the value to that timestamp in RFC3339 format. If the Job belongs to a CronJob\nwith a timezone specified, then the timestamp is in that timezone. Otherwise, the timestamp is in controller-manager's local time.kubectl.kubernetes.io/default-containerType: AnnotationExample: kubectl.kubernetes.io/default-container: \"front-end-app\"The value of the annotation is the container name that is default for this Pod.\nFor example, kubectl logs or kubectl exec without -c or --container flag\nwill use this default container.kubectl.kubernetes.io/default-logs-container (deprecated)Type: AnnotationExample: kubectl.kubernetes.io/default-logs-container: \"front-end-app\"The value of the annotation is the container name that is the default logging container for this\nPod. For example, kubectl logs without -c or --container flag will use this default\ncontainer.Note:This annotation is deprecated. You should use the\nkubectl.kubernetes.io/default-container\nannotation instead. Kubernetes versions 1.25 and newer ignore this annotation.kubectl.kubernetes.io/last-applied-configurationType: AnnotationExample: see following snippet\nkubectl.kubernetes.io/last-applied-configuration: >\n{\"apiVersion\":\"apps/v1\",\"kind\":\"Deployment\",\"metadata\":{\"annotations\":{},\"name\":\"example\",\"namespace\":\"default\"},\"spec\":{\"selector\":{\"matchLabels\":{\"app.kubernetes.io/name\":foo}},\"template\":{\"metadata\":{\"labels\":{\"app.kubernetes.io/name\":\"foo\"}},\"spec\":{\"containers\":[{\"image\":\"container-registry.example/foo-bar:1.42\",\"name\":\"foo-bar\",\"ports\":[{\"containerPort\":42}]}]}}}}\nUsed on: all objectsThe kubectl command line tool uses this annotation as a legacy mechanism\nto track changes. That mechanism has been superseded by\nServer-side apply.kubectl.kubernetes.io/restartedAtType: AnnotationExample: kubectl.kubernetes.io/restartedAt: \"2024-06-21T17:27:41Z\"Used on: Deployment, ReplicaSet, StatefulSet, DaemonSet, PodThis annotation contains the latest restart time of a resource (Deployment, ReplicaSet, StatefulSet or DaemonSet),\nwhere kubectl triggered a rollout in order to force creation of new Pods.\nThe command kubectl rollout restart <RESOURCE> triggers a restart by patching the template\nmetadata of all the pods of resource with this annotation. In above example the latest restart time is shown as 21st June 2024 at 17:27:41 UTC.You should not assume that this annotation represents the date / time of the most recent update;\na separate change could have been made since the last manually triggered rollout.If you manually set this annotation on a Pod, nothing happens. The restarting side effect comes from\nhow workload management and Pod templating works.endpoints.kubernetes.io/over-capacityType: AnnotationExample: endpoints.kubernetes.io/over-capacity:truncatedUsed on: EndpointsThe control plane adds this annotation to\nan Endpoints object if the associated\nService has more than 1000 backing endpoints.\nThe annotation indicates that the Endpoints object is over capacity and the number of endpoints\nhas been truncated to 1000.If the number of backend endpoints falls below 1000, the control plane removes this annotation.endpoints.kubernetes.io/last-change-trigger-timeType: AnnotationExample: endpoints.kubernetes.io/last-change-trigger-time: \"2023-07-20T04:45:21Z\"Used on: EndpointsThis annotation set to an Endpoints object that\nrepresents the timestamp (The timestamp is stored in RFC 3339 date-time string format. For example, '2018-10-22T19:32:52.1Z'). This is timestamp\nof the last change in some Pod or Service object, that triggered the change to the Endpoints object.control-plane.alpha.kubernetes.io/leader (deprecated)Type: AnnotationExample: control-plane.alpha.kubernetes.io/leader={\"holderIdentity\":\"controller-0\",\"leaseDurationSeconds\":15,\"acquireTime\":\"2023-01-19T13:12:57Z\",\"renewTime\":\"2023-01-19T13:13:54Z\",\"leaderTransitions\":1}Used on: EndpointsThe control plane previously set annotation on\nan Endpoints object. This annotation provided\nthe following detail:Who is the current leader.The time when the current leadership was acquired.The duration of the lease (of the leadership) in seconds.The time the current lease (the current leadership) should be renewed.The number of leadership transitions that happened in the past.Kubernetes now uses Leases to\nmanage leader assignment for the Kubernetes control plane.batch.kubernetes.io/job-tracking (deprecated)Type: AnnotationExample: batch.kubernetes.io/job-tracking: \"\"Used on: JobsThe presence of this annotation on a Job used to indicate that the control plane is\ntracking the Job status using finalizers.\nAdding or removing this annotation no longer has an effect (Kubernetes v1.27 and later)\nAll Jobs are tracked with finalizers.job-name (deprecated)Type: LabelExample: job-name: \"pi\"Used on: Jobs and Pods controlled by JobsNote:Starting from Kubernetes 1.27, this label is deprecated.\nKubernetes 1.27 and newer ignore this label and use the prefixed job-name label.controller-uid (deprecated)Type: LabelExample: controller-uid: \"$UID\"Used on: Jobs and Pods controlled by JobsNote:Starting from Kubernetes 1.27, this label is deprecated.\nKubernetes 1.27 and newer ignore this label and use the prefixed controller-uid label.batch.kubernetes.io/job-nameType: LabelExample: batch.kubernetes.io/job-name: \"pi\"Used on: Jobs and Pods controlled by JobsThis label is used as a user-friendly way to get Pods corresponding to a Job.\nThe job-name comes from the name of the Job and allows for an easy way to\nget Pods corresponding to the Job.batch.kubernetes.io/controller-uidType: LabelExample: batch.kubernetes.io/controller-uid: \"$UID\"Used on: Jobs and Pods controlled by JobsThis label is used as a programmatic way to get all Pods corresponding to a Job.The controller-uid is a unique identifier that gets set in the selector field so the Job\ncontroller can get all the corresponding Pods.scheduler.alpha.kubernetes.io/defaultTolerationsType: AnnotationExample: scheduler.alpha.kubernetes.io/defaultTolerations: '[{\"operator\": \"Equal\", \"value\": \"value1\", \"effect\": \"NoSchedule\", \"key\": \"dedicated-node\"}]'Used on: NamespaceThis annotation requires the PodTolerationRestriction\nadmission controller to be enabled. This annotation key allows assigning tolerations to a\nnamespace and any new pods created in this namespace would get these tolerations added.scheduler.alpha.kubernetes.io/tolerationsWhitelistType: AnnotationExample: scheduler.alpha.kubernetes.io/tolerationsWhitelist: '[{\"operator\": \"Exists\", \"effect\": \"NoSchedule\", \"key\": \"dedicated-node\"}]'Used on: NamespaceThis annotation is only useful when the (Alpha)\nPodTolerationRestriction\nadmission controller is enabled. The annotation value is a JSON document that defines a list of\nallowed tolerations for the namespace it annotates. When you create a Pod or modify its\ntolerations, the API server checks the tolerations to see if they are mentioned in the allow list.\nThe pod is admitted only if the check succeeds.scheduler.alpha.kubernetes.io/preferAvoidPods (deprecated)Type: AnnotationUsed on: NodeThis annotation requires the NodePreferAvoidPods scheduling plugin\nto be enabled. The plugin is deprecated since Kubernetes 1.22.\nUse Taints and Tolerations instead.node.kubernetes.io/not-readyType: TaintExample: node.kubernetes.io/not-ready: \"NoExecute\"Used on: NodeThe Node controller detects whether a Node is ready by monitoring its health\nand adds or removes this taint accordingly.node.kubernetes.io/unreachableType: TaintExample: node.kubernetes.io/unreachable: \"NoExecute\"Used on: NodeThe Node controller adds the taint to a Node corresponding to the\nNodeCondition Ready being Unknown.node.kubernetes.io/unschedulableType: TaintExample: node.kubernetes.io/unschedulable: \"NoSchedule\"Used on: NodeThe taint will be added to a node when initializing the node to avoid race condition.node.kubernetes.io/memory-pressureType: TaintExample: node.kubernetes.io/memory-pressure: \"NoSchedule\"Used on: NodeThe kubelet detects memory pressure based on memory.available and allocatableMemory.available\nobserved on a Node. The observed values are then compared to the corresponding thresholds that can\nbe set on the kubelet to determine if the Node condition and taint should be added/removed.node.kubernetes.io/disk-pressureType: TaintExample: node.kubernetes.io/disk-pressure :\"NoSchedule\"Used on: NodeThe kubelet detects disk pressure based on imagefs.available, imagefs.inodesFree,\nnodefs.available and nodefs.inodesFree(Linux only) observed on a Node.\nThe observed values are then compared to the corresponding thresholds that can be set on the\nkubelet to determine if the Node condition and taint should be added/removed.node.kubernetes.io/network-unavailableType: TaintExample: node.kubernetes.io/network-unavailable: \"NoSchedule\"Used on: NodeThis is initially set by the kubelet when the cloud provider used indicates a requirement for\nadditional network configuration. Only when the route on the cloud is configured properly will the\ntaint be removed by the cloud provider.node.kubernetes.io/pid-pressureType: TaintExample: node.kubernetes.io/pid-pressure: \"NoSchedule\"Used on: NodeThe kubelet checks D-value of the size of /proc/sys/kernel/pid_max and the PIDs consumed by\nKubernetes on a node to get the number of available PIDs that referred to as the pid.available\nmetric. The metric is then compared to the corresponding threshold that can be set on the kubelet\nto determine if the node condition and taint should be added/removed.node.kubernetes.io/out-of-serviceType: TaintExample: node.kubernetes.io/out-of-service:NoExecuteUsed on: NodeA user can manually add the taint to a Node marking it out-of-service.\nIf a Node is marked out-of-service with this taint, the Pods on the node\nwill be forcefully deleted if there are no matching tolerations on it and\nvolume detach operations for the Pods terminating on the node will happen immediately.\nThis allows the Pods on the out-of-service node to recover quickly on a different node.Caution:Refer to Non-graceful node shutdown\nfor further details about when and how to use this taint.node.cloudprovider.kubernetes.io/uninitializedType: TaintExample: node.cloudprovider.kubernetes.io/uninitialized: \"NoSchedule\"Used on: NodeSets this taint on a Node to mark it as unusable, when kubelet is started with the \"external\"\ncloud provider, until a controller from the cloud-controller-manager initializes this Node, and\nthen removes the taint.node.cloudprovider.kubernetes.io/shutdownType: TaintExample: node.cloudprovider.kubernetes.io/shutdown: \"NoSchedule\"Used on: NodeIf a Node is in a cloud provider specified shutdown state, the Node gets tainted accordingly\nwith node.cloudprovider.kubernetes.io/shutdown and the taint effect of NoSchedule.feature.node.kubernetes.io/*Type: LabelExample: feature.node.kubernetes.io/network-sriov.capable: \"true\"Used on: NodeThese labels are used by the Node Feature Discovery (NFD) component to advertise\nfeatures on a node. All built-in labels use the feature.node.kubernetes.io label\nnamespace and have the format feature.node.kubernetes.io/<feature-name>: \"true\".\nNFD has many extension points for creating vendor and application-specific labels.\nFor details, see the customization guide.nfd.node.kubernetes.io/master.versionType: AnnotationExample: nfd.node.kubernetes.io/master.version: \"v0.6.0\"Used on: NodeFor node(s) where the Node Feature Discovery (NFD)\nmaster\nis scheduled, this annotation records the version of the NFD master.\nIt is used for informative use only.nfd.node.kubernetes.io/worker.versionType: AnnotationExample: nfd.node.kubernetes.io/worker.version: \"v0.4.0\"Used on: NodesThis annotation records the version for a Node Feature Discovery's\nworker\nif there is one running on a node. It's used for informative use only.nfd.node.kubernetes.io/feature-labelsType: AnnotationExample: nfd.node.kubernetes.io/feature-labels: \"cpu-cpuid.ADX,cpu-cpuid.AESNI,cpu-hardware_multithreading,kernel-version.full\"Used on: NodesThis annotation records a comma-separated list of node feature labels managed by\nNode Feature Discovery (NFD).\nNFD uses this for an internal mechanism. You should not edit this annotation yourself.nfd.node.kubernetes.io/extended-resourcesType: AnnotationExample: nfd.node.kubernetes.io/extended-resources: \"accelerator.acme.example/q500,example.com/coprocessor-fx5\"Used on: NodesThis annotation records a comma-separated list of\nextended resources\nmanaged by Node Feature Discovery (NFD).\nNFD uses this for an internal mechanism. You should not edit this annotation yourself.nfd.node.kubernetes.io/node-nameType: LabelExample: nfd.node.kubernetes.io/node-name: node-1Used on: NodesIt specifies which node the NodeFeature object is targeting.\nCreators of NodeFeature objects must set this label and\nconsumers of the objects are supposed to use the label for\nfiltering features designated for a certain node.Note:These Node Feature Discovery (NFD) labels or annotations only apply to\nthe nodes where NFD is running. To learn more about NFD and\nits components go to its official documentation.service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval (beta)Example: service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval: \"5\"Used on: ServiceThe cloud controller manager integration with AWS elastic load balancing configures\nthe load balancer for a Service based on this annotation. The value determines\nhow often the load balancer writes log entries. For example, if you set the value\nto 5, the log writes occur 5 seconds apart.service.beta.kubernetes.io/aws-load-balancer-access-log-enabled (beta)Example: service.beta.kubernetes.io/aws-load-balancer-access-log-enabled: \"false\"Used on: ServiceThe cloud controller manager integration with AWS elastic load balancing configures\nthe load balancer for a Service based on this annotation. Access logging is enabled\nif you set the annotation to \"true\".service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name (beta)Example: service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name: exampleUsed on: ServiceThe cloud controller manager integration with AWS elastic load balancing configures\nthe load balancer for a Service based on this annotation. The load balancer\nwrites logs to an S3 bucket with the name you specify.service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix (beta)Example: service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix: \"/example\"Used on: ServiceThe cloud controller manager integration with AWS elastic load balancing configures\nthe load balancer for a Service based on this annotation. The load balancer\nwrites log objects with the prefix that you specify.service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags (beta)Example: service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags: \"Environment=demo,Project=example\"Used on: ServiceThe cloud controller manager integration with AWS elastic load balancing configures\ntags (an AWS concept) for a load balancer based on the comma-separated key/value\npairs in the value of this annotation.service.beta.kubernetes.io/aws-load-balancer-alpn-policy (beta)Example: service.beta.kubernetes.io/aws-load-balancer-alpn-policy: HTTP2OptionalUsed on: ServiceThe AWS load balancer controller\nuses this annotation.\nSee annotations\nin the AWS load balancer controller documentation.service.beta.kubernetes.io/aws-load-balancer-attributes (beta)Example: service.beta.kubernetes.io/aws-load-balancer-attributes: \"deletion_protection.enabled=true\"Used on: ServiceThe AWS load balancer controller\nuses this annotation.\nSee annotations\nin the AWS load balancer controller documentation.service.beta.kubernetes.io/aws-load-balancer-backend-protocol (beta)Example: service.beta.kubernetes.io/aws-load-balancer-backend-protocol: tcpUsed on: ServiceThe cloud controller manager integration with AWS elastic load balancing configures\nthe load balancer listener based on the value of this annotation.service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled (beta)Example: service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled: \"false\"Used on: ServiceThe cloud controller manager integration with AWS elastic load balancing configures\nthe load balancer based on this annotation. The load balancer's connection draining\nsetting depends on the value you set.service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout (beta)Example: service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout: \"60\"Used on: ServiceIf you configure connection draining\nfor a Service of type: LoadBalancer, and you use the AWS cloud, the integration configures\nthe draining period based on this annotation. The value you set determines the draining\ntimeout in seconds.service.beta.kubernetes.io/aws-load-balancer-ip-address-type (beta)Example: service.beta.kubernetes.io/aws-load-balancer-ip-address-type: ipv4Used on: ServiceThe AWS load balancer controller\nuses this annotation.\nSee annotations\nin the AWS load balancer controller documentation.service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout (beta)Example: service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout: \"60\"Used on: ServiceThe cloud controller manager integration with AWS elastic load balancing configures\na load balancer based on this annotation. The load balancer has a configured idle\ntimeout period (in seconds) that applies to its connections. If no data has been\nsent or received by the time that the idle timeout period elapses, the load balancer\ncloses the connection.service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled (beta)Example: service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: \"true\"Used on: ServiceThe cloud controller manager integration with AWS elastic load balancing configures\na load balancer based on this annotation. If you set this annotation to \"true\",\neach load balancer node distributes requests evenly across the registered targets\nin all enabled availability zones.\nIf you disable cross-zone load balancing, each load balancer node distributes requests\nevenly across the registered targets in its availability zone only.service.beta.kubernetes.io/aws-load-balancer-eip-allocations (beta)Example: service.beta.kubernetes.io/aws-load-balancer-eip-allocations: \"eipalloc-01bcdef23bcdef456,eipalloc-def1234abc4567890\"Used on: ServiceThe cloud controller manager integration with AWS elastic load balancing configures\na load balancer based on this annotation. The value is a comma-separated list\nof elastic IP address allocation IDs.This annotation is only relevant for Services of type: LoadBalancer, where\nthe load balancer is an AWS Network Load Balancer.service.beta.kubernetes.io/aws-load-balancer-extra-security-groups (beta)Example: service.beta.kubernetes.io/aws-load-balancer-extra-security-groups: \"sg-12abcd3456,sg-34dcba6543\"Used on: ServiceThe cloud controller manager integration with AWS elastic load balancing configures\na load balancer based on this annotation. The annotation value is a comma-separated\nlist of extra AWS VPC security groups to configure for the load balancer.service.beta.kubernetes.io/aws-load-balancer-healthcheck-healthy-threshold (beta)Example: service.beta.kubernetes.io/aws-load-balancer-healthcheck-healthy-threshold: \"3\"Used on: ServiceThe cloud controller manager integration with AWS elastic load balancing configures\na load balancer based on this annotation. The annotation value specifies the number of\nsuccessive successful health checks required for a backend to be considered healthy\nfor traffic.service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval (beta)Example: service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval: \"30\"Used on: ServiceThe cloud controller manager integration with AWS elastic load balancing configures\na load balancer based on this annotation. The annotation value specifies the interval,\nin seconds, between health check probes made by the load balancer.service.beta.kubernetes.io/aws-load-balancer-healthcheck-path (beta)Example: service.beta.kubernetes.io/aws-load-balancer-healthcheck-path: /healthcheckUsed on: ServiceThe cloud controller manager integration with AWS elastic load balancing configures\na load balancer based on this annotation. The annotation value determines the\npath part of the URL that is used for HTTP health checks.service.beta.kubernetes.io/aws-load-balancer-healthcheck-port (beta)Example: service.beta.kubernetes.io/aws-load-balancer-healthcheck-port: \"24\"Used on: ServiceThe cloud controller manager integration with AWS elastic load balancing configures\na load balancer based on this annotation. The annotation value determines which\nport the load balancer connects to when performing health checks.service.beta.kubernetes.io/aws-load-balancer-healthcheck-protocol (beta)Example: service.beta.kubernetes.io/aws-load-balancer-healthcheck-protocol: TCPUsed on: ServiceThe cloud controller manager integration with AWS elastic load balancing configures\na load balancer based on this annotation. The annotation value determines how the\nload balancer checks the health of backend targets.service.beta.kubernetes.io/aws-load-balancer-healthcheck-timeout (beta)Example: service.beta.kubernetes.io/aws-load-balancer-healthcheck-timeout: \"3\"Used on: ServiceThe cloud controller manager integration with AWS elastic load balancing configures\na load balancer based on this annotation. The annotation value specifies the number\nof seconds before a probe that hasn't yet succeeded is automatically treated as\nhaving failed.service.beta.kubernetes.io/aws-load-balancer-healthcheck-unhealthy-threshold (beta)Example: service.beta.kubernetes.io/aws-load-balancer-healthcheck-unhealthy-threshold: \"3\"Used on: ServiceThe cloud controller manager integration with AWS elastic load balancing configures\na load balancer based on this annotation. The annotation value specifies the number of\nsuccessive unsuccessful health checks required for a backend to be considered unhealthy\nfor traffic.service.beta.kubernetes.io/aws-load-balancer-internal (beta)Example: service.beta.kubernetes.io/aws-load-balancer-internal: \"true\"Used on: ServiceThe cloud controller manager integration with AWS elastic load balancing configures\na load balancer based on this annotation. When you set this annotation to \"true\",\nthe integration configures an internal load balancer.If you use the AWS load balancer controller,\nsee service.beta.kubernetes.io/aws-load-balancer-scheme.service.beta.kubernetes.io/aws-load-balancer-manage-backend-security-group-rules (beta)Example: service.beta.kubernetes.io/aws-load-balancer-manage-backend-security-group-rules: \"true\"Used on: ServiceThe AWS load balancer controller\nuses this annotation.\nSee annotations\nin the AWS load balancer controller documentation.service.beta.kubernetes.io/aws-load-balancer-name (beta)Example: service.beta.kubernetes.io/aws-load-balancer-name: my-elbUsed on: ServiceIf you set this annotation on a Service, and you also annotate that Service with\nservice.beta.kubernetes.io/aws-load-balancer-type: \"external\", and you use the\nAWS load balancer controller\nin your cluster, then the AWS load balancer controller sets the name of that load\nbalancer to the value you set for this annotation.See annotations\nin the AWS load balancer controller documentation.service.beta.kubernetes.io/aws-load-balancer-nlb-target-type (beta)Example: service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: \"true\"Used on: ServiceThe AWS load balancer controller\nuses this annotation.\nSee annotations\nin the AWS load balancer controller documentation.service.beta.kubernetes.io/aws-load-balancer-private-ipv4-addresses (beta)Example: service.beta.kubernetes.io/aws-load-balancer-private-ipv4-addresses: \"198.51.100.0,198.51.100.64\"Used on: ServiceThe AWS load balancer controller\nuses this annotation.\nSee annotations\nin the AWS load balancer controller documentation.service.beta.kubernetes.io/aws-load-balancer-proxy-protocol (beta)Example: service.beta.kubernetes.io/aws-load-balancer-proxy-protocol: \"*\"Used on: ServiceThe official Kubernetes integration with AWS elastic load balancing configures\na load balancer based on this annotation. The only permitted value is \"*\",\nwhich indicates that the load balancer should wrap TCP connections to the backend\nPod with the PROXY protocol.service.beta.kubernetes.io/aws-load-balancer-scheme (beta)Example: service.beta.kubernetes.io/aws-load-balancer-scheme: internalUsed on: ServiceThe AWS load balancer controller\nuses this annotation.\nSee annotations\nin the AWS load balancer controller documentation.service.beta.kubernetes.io/aws-load-balancer-security-groups (deprecated)Example: service.beta.kubernetes.io/aws-load-balancer-security-groups: \"sg-53fae93f,sg-8725gr62r\"Used on: ServiceThe AWS load balancer controller uses this annotation to specify a comma separated list\nof security groups you want to attach to an AWS load balancer. Both name and ID of security\nare supported where name matches a Name tag, not the groupName attribute.When this annotation is added to a Service, the load-balancer controller attaches the security groups\nreferenced by the annotation to the load balancer. If you omit this annotation, the AWS load balancer\ncontroller automatically creates a new security group and attaches it to the load balancer.Note:Kubernetes v1.27 and later do not directly set or read this annotation. However, the AWS\nload balancer controller (part of the Kubernetes project) does still use the\nservice.beta.kubernetes.io/aws-load-balancer-security-groups annotation.service.beta.kubernetes.io/load-balancer-source-ranges (deprecated)Example: service.beta.kubernetes.io/load-balancer-source-ranges: \"192.0.2.0/25\"Used on: ServiceThe AWS load balancer controller\nuses this annotation. You should set .spec.loadBalancerSourceRanges for the Service instead.service.beta.kubernetes.io/aws-load-balancer-ssl-cert (beta)Example: service.beta.kubernetes.io/aws-load-balancer-ssl-cert: \"arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012\"Used on: ServiceThe official integration with AWS elastic load balancing configures TLS for a Service of\ntype: LoadBalancer based on this annotation. The value of the annotation is the\nAWS Resource Name (ARN) of the X.509 certificate that the load balancer listener should\nuse.(The TLS protocol is based on an older technology that abbreviates to SSL.)service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy (beta)Example: service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy: ELBSecurityPolicy-TLS-1-2-2017-01The official integration with AWS elastic load balancing configures TLS for a Service of\ntype: LoadBalancer based on this annotation. The value of the annotation is the name\nof an AWS policy for negotiating TLS with a client peer.service.beta.kubernetes.io/aws-load-balancer-ssl-ports (beta)Example: service.beta.kubernetes.io/aws-load-balancer-ssl-ports: \"*\"The official integration with AWS elastic load balancing configures TLS for a Service of\ntype: LoadBalancer based on this annotation. The value of the annotation is either \"*\",\nwhich means that all the load balancer's ports should use TLS, or it is a comma separated\nlist of port numbers.service.beta.kubernetes.io/aws-load-balancer-subnets (beta)Example: service.beta.kubernetes.io/aws-load-balancer-subnets: \"private-a,private-b\"Kubernetes' official integration with AWS uses this annotation to configure a\nload balancer and determine in which AWS availability zones to deploy the managed\nload balancing service. The value is either a comma separated list of subnet names, or a\ncomma separated list of subnet IDs.service.beta.kubernetes.io/aws-load-balancer-target-group-attributes (beta)Example: service.beta.kubernetes.io/aws-load-balancer-target-group-attributes: \"stickiness.enabled=true,stickiness.type=source_ip\"Used on: ServiceThe AWS load balancer controller\nuses this annotation.\nSee annotations\nin the AWS load balancer controller documentation.service.beta.kubernetes.io/aws-load-balancer-target-node-labels (beta)Example: service.beta.kubernetes.io/aws-load-balancer-target-node-labels: \"kubernetes.io/os=Linux,topology.kubernetes.io/region=us-east-2\"Kubernetes' official integration with AWS uses this annotation to determine which\nnodes in your cluster should be considered as valid targets for the load balancer.service.beta.kubernetes.io/aws-load-balancer-type (beta)Example: service.beta.kubernetes.io/aws-load-balancer-type: externalKubernetes' official integrations with AWS use this annotation to determine\nwhether the AWS cloud provider integration should manage a Service of\ntype: LoadBalancer.There are two permitted values:nlbthe cloud controller manager configures a Network Load Balancerexternalthe cloud controller manager does not configure any load balancerIf you deploy a Service of type: LoadBalancer on AWS, and you don't set any\nservice.beta.kubernetes.io/aws-load-balancer-type annotation,\nthe AWS integration deploys a classic Elastic Load Balancer. This behavior,\nwith no annotation present, is the default unless you specify otherwise.When you set this annotation to external on a Service of type: LoadBalancer,\nand your cluster has a working deployment of the AWS Load Balancer controller,\nthen the AWS Load Balancer controller attempts to deploy a load balancer based\non the Service specification.Caution:Do not modify or add the service.beta.kubernetes.io/aws-load-balancer-type annotation\non an existing Service object. See the AWS documentation on this topic for more\ndetails.service.beta.kubernetes.io/azure-load-balancer-disable-tcp-reset (deprecated)Example: service.beta.kubernetes.io/azure-load-balancer-disable-tcp-reset: \"false\"Used on: ServiceThis annotation only works for Azure standard load balancer backed service.\nThis annotation is used on the Service to specify whether the load balancer\nshould disable or enable TCP reset on idle timeout. If enabled, it helps\napplications to behave more predictably, to detect the termination of a connection,\nremove expired connections and initiate new connections.\nYou can set the value to be either true or false.See Load Balancer TCP Reset for more information.Note:This annotation is deprecated.pod-security.kubernetes.io/enforceType: LabelExample: pod-security.kubernetes.io/enforce: \"baseline\"Used on: NamespaceValue must be one of privileged, baseline, or restricted which correspond to\nPod Security Standard levels.\nSpecifically, the enforce label prohibits the creation of any Pod in the labeled\nNamespace which does not meet the requirements outlined in the indicated level.See Enforcing Pod Security at the Namespace Level\nfor more information.pod-security.kubernetes.io/enforce-versionType: LabelExample: pod-security.kubernetes.io/enforce-version: \"1.34\"Used on: NamespaceValue must be latest or a valid Kubernetes version in the format v<major>.<minor>.\nThis determines the version of the\nPod Security Standard\npolicies to apply when validating a Pod.See Enforcing Pod Security at the Namespace Level\nfor more information.pod-security.kubernetes.io/auditType: LabelExample: pod-security.kubernetes.io/audit: \"baseline\"Used on: NamespaceValue must be one of privileged, baseline, or restricted which correspond to\nPod Security Standard levels.\nSpecifically, the audit label does not prevent the creation of a Pod in the labeled\nNamespace which does not meet the requirements outlined in the indicated level,\nbut adds an this annotation to the Pod.See Enforcing Pod Security at the Namespace Level\nfor more information.pod-security.kubernetes.io/audit-versionType: LabelExample: pod-security.kubernetes.io/audit-version: \"1.34\"Used on: NamespaceValue must be latest or a valid Kubernetes version in the format v<major>.<minor>.\nThis determines the version of the\nPod Security Standard\npolicies to apply when validating a Pod.See Enforcing Pod Security at the Namespace Level\nfor more information.pod-security.kubernetes.io/warnType: LabelExample: pod-security.kubernetes.io/warn: \"baseline\"Used on: NamespaceValue must be one of privileged, baseline, or restricted which correspond to\nPod Security Standard levels.\nSpecifically, the warn label does not prevent the creation of a Pod in the labeled\nNamespace which does not meet the requirements outlined in the indicated level,\nbut returns a warning to the user after doing so.\nNote that warnings are also displayed when creating or updating objects that contain\nPod templates, such as Deployments, Jobs, StatefulSets, etc.See Enforcing Pod Security at the Namespace Level\nfor more information.pod-security.kubernetes.io/warn-versionType: LabelExample: pod-security.kubernetes.io/warn-version: \"1.34\"Used on: NamespaceValue must be latest or a valid Kubernetes version in the format v<major>.<minor>.\nThis determines the version of the Pod Security Standard\npolicies to apply when validating a submitted Pod.\nNote that warnings are also displayed when creating or updating objects that contain\nPod templates, such as Deployments, Jobs, StatefulSets, etc.See Enforcing Pod Security at the Namespace Level\nfor more information.rbac.authorization.kubernetes.io/autoupdateType: AnnotationExample: rbac.authorization.kubernetes.io/autoupdate: \"false\"Used on: ClusterRole, ClusterRoleBinding, Role, RoleBindingWhen this annotation is set to \"true\" on default RBAC objects created by the API server,\nthey are automatically updated at server start to add missing permissions and subjects\n(extra permissions and subjects are left in place).\nTo prevent autoupdating a particular role or rolebinding, set this annotation to \"false\".\nIf you create your own RBAC objects and set this annotation to \"false\", kubectl auth reconcile\n(which allows reconciling arbitrary RBAC objects in a manifest)\nrespects this annotation and does not automatically add missing permissions and subjects.kubernetes.io/psp (deprecated)Type: AnnotationExample: kubernetes.io/psp: restrictedUsed on: PodThis annotation was only relevant if you were using\nPodSecurityPolicy objects.\nKubernetes v1.34 does not support the PodSecurityPolicy API.When the PodSecurityPolicy admission controller admitted a Pod, the admission controller\nmodified the Pod to have this annotation.\nThe value of the annotation was the name of the PodSecurityPolicy that was used for validation.seccomp.security.alpha.kubernetes.io/pod (non-functional)Type: AnnotationUsed on: PodKubernetes before v1.25 allowed you to configure seccomp behavior using this annotation.\nSee Restrict a Container's Syscalls with seccomp to\nlearn the supported way to specify seccomp restrictions for a Pod.container.seccomp.security.alpha.kubernetes.io/[NAME] (non-functional)Type: AnnotationUsed on: PodKubernetes before v1.25 allowed you to configure seccomp behavior using this annotation.\nSee Restrict a Container's Syscalls with seccomp to\nlearn the supported way to specify seccomp restrictions for a Pod.snapshot.storage.kubernetes.io/allow-volume-mode-changeType: AnnotationExample: snapshot.storage.kubernetes.io/allow-volume-mode-change: \"true\"Used on: VolumeSnapshotContentValue can either be true or false. This determines whether a user can modify\nthe mode of the source volume when a PersistentVolumeClaim is being created from\na VolumeSnapshot.Refer to Converting the volume mode of a Snapshot\nand the Kubernetes CSI Developer Documentation\nfor more information.scheduler.alpha.kubernetes.io/critical-pod (deprecated)Type: AnnotationExample: scheduler.alpha.kubernetes.io/critical-pod: \"\"Used on: PodThis annotation lets Kubernetes control plane know about a Pod being a critical Pod\nso that the descheduler will not remove this Pod.Note:Starting in v1.16, this annotation was removed in favor of\nPod Priority.jobset.sigs.k8s.io/jobset-nameType: Label, AnnotationExample: jobset.sigs.k8s.io/jobset-name: \"my-jobset\"Used on: Jobs, PodsThis label/annotation is used to store the name of the JobSet that a Job or Pod belongs to.\nJobSet is an extension API that you can deploy into your Kubernetes cluster.jobset.sigs.k8s.io/replicatedjob-replicasType: Label, AnnotationExample: jobset.sigs.k8s.io/replicatedjob-replicas: \"5\"Used on: Jobs, PodsThis label/annotation specifies the number of replicas for a ReplicatedJob.jobset.sigs.k8s.io/replicatedjob-nameType: Label, AnnotationExample: jobset.sigs.k8s.io/replicatedjob-name: \"my-replicatedjob\"Used on: Jobs, PodsThis label or annotation stores the name of the replicated job that this Job or Pod is part of.jobset.sigs.k8s.io/job-indexType: Label, AnnotationExample: jobset.sigs.k8s.io/job-index: \"0\"Used on: Jobs, PodsThis label/annotation is set by the JobSet controller on child Jobs and Pods. It contains the index of the Job replica within its parent ReplicatedJob.jobset.sigs.k8s.io/job-keyType: Label, AnnotationExample: jobset.sigs.k8s.io/job-key: \"0f1e93893c4cb372080804ddb9153093cb0d20cefdd37f653e739c232d363feb\"Used on: Jobs, PodsThe JobSet controller sets this label (and also an annotation with the same key) on child Jobs and\nPods of a JobSet. The value is the SHA256 hash of the namespaced Job name.alpha.jobset.sigs.k8s.io/exclusive-topologyType: AnnotationExample: alpha.jobset.sigs.k8s.io/exclusive-topology: \"zone\"Used on: JobSets, JobsYou can set this label/annotation on a JobSet to ensure exclusive Job\nplacement per topology group. You can also define this label or annotation on a replicated job\ntemplate. Read the documentation for JobSet to learn more.alpha.jobset.sigs.k8s.io/node-selectorType: AnnotationExample: alpha.jobset.sigs.k8s.io/node-selector: \"true\"Used on: Jobs, PodsThis label/annotation can be applied to a JobSet. When it's set, the JobSet controller modifies the Jobs and their corresponding Pods by adding node selectors and tolerations. This ensures exclusive job placement per topology domain, restricting the scheduling of these Pods to specific nodes based on the strategy.alpha.jobset.sigs.k8s.io/namespaced-jobType: LabelExample: alpha.jobset.sigs.k8s.io/namespaced-job: \"default_myjobset-replicatedjob-0\"Used on: NodesThis label is either set manually or automatically (for example, a cluster autoscaler) on the nodes. When alpha.jobset.sigs.k8s.io/node-selector is set to \"true\", the JobSet controller adds a nodeSelector to this node label (along with the toleration to the taint alpha.jobset.sigs.k8s.io/no-schedule discussed next).alpha.jobset.sigs.k8s.io/no-scheduleType: TaintExample: alpha.jobset.sigs.k8s.io/no-schedule: \"NoSchedule\"Used on: NodesThis taint is either set manually or automatically (for example, a cluster autoscaler) on the nodes. When alpha.jobset.sigs.k8s.io/node-selector is set to \"true\", the JobSet controller adds a toleration to this node taint (along with the node selector to the label alpha.jobset.sigs.k8s.io/namespaced-job discussed previously).jobset.sigs.k8s.io/coordinatorType: Annotation, LabelExample: jobset.sigs.k8s.io/coordinator: \"myjobset-workers-0-0.headless-svc\"Used on: Jobs, PodsThis annotation/label is used on Jobs and Pods to store a stable network endpoint where the coordinator\npod can be reached if the JobSet spec defines the .spec.coordinator field.Annotations used for auditauthorization.k8s.io/decisionauthorization.k8s.io/reasoninsecure-sha1.invalid-cert.kubernetes.io/$hostnamemissing-san.invalid-cert.kubernetes.io/$hostnamepod-security.kubernetes.io/audit-violationspod-security.kubernetes.io/enforce-policypod-security.kubernetes.io/exemptvalidation.policy.admission.k8s.io/validation_failureSee more details on Audit Annotations.kubeadmkubeadm.alpha.kubernetes.io/cri-socket (deprecated)Type: AnnotationExample: kubeadm.alpha.kubernetes.io/cri-socket: unix:///run/containerd/container.sockUsed on: NodeNote:Starting from v1.34, this annotation is deprecated, kubeadm will no longer actively set and use it.kubeadm.kubernetes.io/etcd.advertise-client-urlsType: AnnotationExample: kubeadm.kubernetes.io/etcd.advertise-client-urls: https://172.17.0.18:2379Used on: PodAnnotation that kubeadm places on locally managed etcd Pods to keep track of\na list of URLs where etcd clients should connect to.\nThis is used mainly for etcd cluster health check purposes.kubeadm.kubernetes.io/kube-apiserver.advertise-address.endpointType: AnnotationExample: kubeadm.kubernetes.io/kube-apiserver.advertise-address.endpoint: https://172.17.0.18:6443Used on: PodAnnotation that kubeadm places on locally managed kube-apiserver Pods to keep track\nof the exposed advertise address/port endpoint for that API server instance.kubeadm.kubernetes.io/component-config.hashType: AnnotationExample: kubeadm.kubernetes.io/component-config.hash: 2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7aeUsed on: ConfigMapAnnotation that kubeadm places on ConfigMaps that it manages for configuring components.\nIt contains a hash (SHA-256) used to determine if the user has applied settings different\nfrom the kubeadm defaults for a particular component.node-role.kubernetes.io/control-planeType: LabelUsed on: NodeA marker label to indicate that the node is used to run control plane components.\nThe kubeadm tool applies this label to the control plane nodes that it manages.\nOther cluster management tools typically also set this taint.You can label control plane nodes with this label to make it easier to schedule Pods\nonly onto these nodes, or to avoid running Pods on the control plane.\nIf this label is set, the EndpointSlice controller\nignores that node while calculating Topology Aware Hints.node-role.kubernetes.io/*Type: LabelExample: node-role.kubernetes.io/gpu: gpuUsed on: NodeThis optional label is applied to a node when you want to mark a node role.\nThe node role (text following / in the label key) can be set, as long as the overall key follows the\nsyntax rules for\nobject labels.Kubernetes defines one specific node role, control-plane. A label you can use to mark that node\nrole is node-role.kubernetes.io/control-plane.node-role.kubernetes.io/control-planeType: TaintExample: node-role.kubernetes.io/control-plane:NoScheduleUsed on: NodeTaint that kubeadm applies on control plane nodes to restrict placing Pods and\nallow only specific pods to schedule on them.If this Taint is applied, control plane nodes allow only critical workloads to\nbe scheduled onto them. You can manually remove this taint with the following\ncommand on a specific node.kubectl taint nodes <node-name> node-role.kubernetes.io/control-plane:NoSchedule-\nnode-role.kubernetes.io/master (deprecated)Type: TaintUsed on: NodeExample: node-role.kubernetes.io/master:NoScheduleTaint that kubeadm previously applied on control plane nodes to allow only critical\nworkloads to schedule on them. Replaced by the\nnode-role.kubernetes.io/control-plane\ntaint. kubeadm no longer sets or uses this deprecated taint.resource.kubernetes.io/admin-access {resource-kubernetes-io-admin-access}Type: LabelExample: resource.kubernetes.io/admin-access: \"true\"Used on: NamespaceUsed to grant administrative access to certain resource.k8s.io API types within\na namespace. When this label is set on a namespace with the value \"true\"\n(case-sensitive), it allows the use of adminAccess: true in any namespaced\nresource.k8s.io API types. Currently, this permission applies to\nResourceClaim and ResourceClaimTemplate objects.See Dynamic Resource Allocation Admin access\nfor more information.FeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified October 14, 2025 at 9:58 AM PST: Fix typos in a few annotation examples (6b0880717e) Edit this page\nCreate child page\nCreate an issue\nPrint entire sectionLabels, annotations and taints used on API objectsapf.kubernetes.io/autoupdate-specapp.kubernetes.io/componentapp.kubernetes.io/created-by (deprecated)app.kubernetes.io/instanceapp.kubernetes.io/managed-byapp.kubernetes.io/nameapp.kubernetes.io/part-ofapp.kubernetes.io/versionapplyset.kubernetes.io/additional-namespaces (alpha)applyset.kubernetes.io/contains-group-kinds (alpha)applyset.kubernetes.io/contains-group-resources (deprecated)applyset.kubernetes.io/id (alpha)applyset.kubernetes.io/is-parent-type (alpha)applyset.kubernetes.io/part-of (alpha)applyset.kubernetes.io/tooling (alpha)apps.kubernetes.io/pod-index (beta)resource.kubernetes.io/pod-claim-namecluster-autoscaler.kubernetes.io/safe-to-evictconfig.kubernetes.io/local-configcontainer.apparmor.security.beta.kubernetes.io/* (deprecated)internal.config.kubernetes.io/* (reserved prefix)internal.config.kubernetes.io/pathinternal.config.kubernetes.io/indexkube-scheduler-simulator.sigs.k8s.io/bind-resultkube-scheduler-simulator.sigs.k8s.io/filter-resultkube-scheduler-simulator.sigs.k8s.io/finalscore-resultkube-scheduler-simulator.sigs.k8s.io/permit-resultkube-scheduler-simulator.sigs.k8s.io/permit-result-timeoutkube-scheduler-simulator.sigs.k8s.io/postfilter-resultkube-scheduler-simulator.sigs.k8s.io/prebind-resultkube-scheduler-simulator.sigs.k8s.io/prefilter-resultkube-scheduler-simulator.sigs.k8s.io/prefilter-result-statuskube-scheduler-simulator.sigs.k8s.io/prescore-resultkube-scheduler-simulator.sigs.k8s.io/reserve-resultkube-scheduler-simulator.sigs.k8s.io/result-historykube-scheduler-simulator.sigs.k8s.io/score-resultkube-scheduler-simulator.sigs.k8s.io/selected-nodekubernetes.io/archkubernetes.io/oskubernetes.io/metadata.namekubernetes.io/limit-rangerkubernetes.io/config.hashkubernetes.io/config.mirrorkubernetes.io/config.sourcekubernetes.io/config.seenaddonmanager.kubernetes.io/modebeta.kubernetes.io/arch (deprecated)beta.kubernetes.io/os (deprecated)kube-aggregator.kubernetes.io/automanagedservice.alpha.kubernetes.io/tolerate-unready-endpoints (deprecated)autoscaling.alpha.kubernetes.io/behavior (deprecated)kubernetes.io/hostnamekubernetes.io/change-causekubernetes.io/descriptionkubernetes.io/enforce-mountable-secrets (deprecated)node.kubernetes.io/exclude-from-external-load-balancerscontroller.kubernetes.io/pod-deletion-costcluster-autoscaler.kubernetes.io/enable-ds-evictionkubernetes.io/ingress-bandwidthkubernetes.io/egress-bandwidthbeta.kubernetes.io/instance-type (deprecated)node.kubernetes.io/instance-typefailure-domain.beta.kubernetes.io/region (deprecated)failure-domain.beta.kubernetes.io/zone (deprecated)pv.kubernetes.io/bind-completedpv.kubernetes.io/bound-by-controllerpv.kubernetes.io/provisioned-bypv.kubernetes.io/migrated-tostatefulset.kubernetes.io/pod-namescheduler.alpha.kubernetes.io/node-selectortopology.kubernetes.io/regiontopology.kubernetes.io/zonevolume.beta.kubernetes.io/storage-provisioner (deprecated)volume.beta.kubernetes.io/storage-class (deprecated)volume.beta.kubernetes.io/mount-options (deprecated)volume.kubernetes.io/storage-provisionervolume.kubernetes.io/selected-nodevolumes.kubernetes.io/controller-managed-attach-detachnode.kubernetes.io/windows-buildstorage.alpha.kubernetes.io/migrated-pluginsservice.kubernetes.io/headlessservice.kubernetes.io/topology-aware-hints (deprecated)service.kubernetes.io/topology-modekubernetes.io/service-namekubernetes.io/service-account.namekubernetes.io/service-account.uidkubernetes.io/legacy-token-last-usedkubernetes.io/legacy-token-invalid-sinceendpoints.kubernetes.io/managed-by (deprecated)endpointslice.kubernetes.io/managed-byendpointslice.kubernetes.io/skip-mirrorservice.kubernetes.io/service-proxy-nameexperimental.windows.kubernetes.io/isolation-type (deprecated)ingressclass.kubernetes.io/is-default-classnginx.ingress.kubernetes.io/configuration-snippetkubernetes.io/ingress.class (deprecated)kubernetes.io/cluster-service (deprecated)storageclass.kubernetes.io/is-default-classalpha.kubernetes.io/provided-node-ip (alpha)batch.kubernetes.io/job-completion-indexbatch.kubernetes.io/cronjob-scheduled-timestampkubectl.kubernetes.io/default-containerkubectl.kubernetes.io/default-logs-container (deprecated)kubectl.kubernetes.io/last-applied-configurationkubectl.kubernetes.io/restartedAtendpoints.kubernetes.io/over-capacityendpoints.kubernetes.io/last-change-trigger-timecontrol-plane.alpha.kubernetes.io/leader (deprecated)batch.kubernetes.io/job-tracking (deprecated)job-name (deprecated)controller-uid (deprecated)batch.kubernetes.io/job-namebatch.kubernetes.io/controller-uidscheduler.alpha.kubernetes.io/defaultTolerationsscheduler.alpha.kubernetes.io/tolerationsWhitelistscheduler.alpha.kubernetes.io/preferAvoidPods (deprecated)node.kubernetes.io/not-readynode.kubernetes.io/unreachablenode.kubernetes.io/unschedulablenode.kubernetes.io/memory-pressurenode.kubernetes.io/disk-pressurenode.kubernetes.io/network-unavailablenode.kubernetes.io/pid-pressurenode.kubernetes.io/out-of-servicenode.cloudprovider.kubernetes.io/uninitializednode.cloudprovider.kubernetes.io/shutdownfeature.node.kubernetes.io/*nfd.node.kubernetes.io/master.versionnfd.node.kubernetes.io/worker.versionnfd.node.kubernetes.io/feature-labelsnfd.node.kubernetes.io/extended-resourcesnfd.node.kubernetes.io/node-nameservice.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval (beta)service.beta.kubernetes.io/aws-load-balancer-access-log-enabled (beta)service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name (beta)service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix (beta)service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags (beta)service.beta.kubernetes.io/aws-load-balancer-alpn-policy (beta)service.beta.kubernetes.io/aws-load-balancer-attributes (beta)service.beta.kubernetes.io/aws-load-balancer-backend-protocol (beta)service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled (beta)service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout (beta)service.beta.kubernetes.io/aws-load-balancer-ip-address-type (beta)service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout (beta)service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled (beta)service.beta.kubernetes.io/aws-load-balancer-eip-allocations (beta)service.beta.kubernetes.io/aws-load-balancer-extra-security-groups (beta)service.beta.kubernetes.io/aws-load-balancer-healthcheck-healthy-threshold (beta)service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval (beta)service.beta.kubernetes.io/aws-load-balancer-healthcheck-path (beta)service.beta.kubernetes.io/aws-load-balancer-healthcheck-port (beta)service.beta.kubernetes.io/aws-load-balancer-healthcheck-protocol (beta)service.beta.kubernetes.io/aws-load-balancer-healthcheck-timeout (beta)service.beta.kubernetes.io/aws-load-balancer-healthcheck-unhealthy-threshold (beta)service.beta.kubernetes.io/aws-load-balancer-internal (beta)service.beta.kubernetes.io/aws-load-balancer-manage-backend-security-group-rules (beta)service.beta.kubernetes.io/aws-load-balancer-name (beta)service.beta.kubernetes.io/aws-load-balancer-nlb-target-type (beta)service.beta.kubernetes.io/aws-load-balancer-private-ipv4-addresses (beta)service.beta.kubernetes.io/aws-load-balancer-proxy-protocol (beta)service.beta.kubernetes.io/aws-load-balancer-scheme (beta)service.beta.kubernetes.io/aws-load-balancer-security-groups (deprecated)service.beta.kubernetes.io/load-balancer-source-ranges (deprecated)service.beta.kubernetes.io/aws-load-balancer-ssl-cert (beta)service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy (beta)service.beta.kubernetes.io/aws-load-balancer-ssl-ports (beta)service.beta.kubernetes.io/aws-load-balancer-subnets (beta)service.beta.kubernetes.io/aws-load-balancer-target-group-attributes (beta)service.beta.kubernetes.io/aws-load-balancer-target-node-labels (beta)service.beta.kubernetes.io/aws-load-balancer-type (beta)service.beta.kubernetes.io/azure-load-balancer-disable-tcp-reset (deprecated)pod-security.kubernetes.io/enforcepod-security.kubernetes.io/enforce-versionpod-security.kubernetes.io/auditpod-security.kubernetes.io/audit-versionpod-security.kubernetes.io/warnpod-security.kubernetes.io/warn-versionrbac.authorization.kubernetes.io/autoupdatekubernetes.io/psp (deprecated)seccomp.security.alpha.kubernetes.io/pod (non-functional)container.seccomp.security.alpha.kubernetes.io/[NAME] (non-functional)snapshot.storage.kubernetes.io/allow-volume-mode-changescheduler.alpha.kubernetes.io/critical-pod (deprecated)jobset.sigs.k8s.io/jobset-namejobset.sigs.k8s.io/replicatedjob-replicasjobset.sigs.k8s.io/replicatedjob-namejobset.sigs.k8s.io/job-indexjobset.sigs.k8s.io/job-keyalpha.jobset.sigs.k8s.io/exclusive-topologyalpha.jobset.sigs.k8s.io/node-selectoralpha.jobset.sigs.k8s.io/namespaced-jobalpha.jobset.sigs.k8s.io/no-schedulejobset.sigs.k8s.io/coordinatorAnnotations used for auditkubeadmkubeadm.alpha.kubernetes.io/cri-socket (deprecated)kubeadm.kubernetes.io/etcd.advertise-client-urlskubeadm.kubernetes.io/kube-apiserver.advertise-address.endpointkubeadm.kubernetes.io/component-config.hashnode-role.kubernetes.io/control-planenode-role.kubernetes.io/*node-role.kubernetes.io/control-planenode-role.kubernetes.io/master (deprecated)resource.kubernetes.io/admin-access {resource-kubernetes-io-admin-access}\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "#labels-annotations-and-taints-used-on-api-objects"
  },
  {
    "url": "https://kubernetes.io/docs/reference/kubernetes-api/",
    "content": "Kubernetes API | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\nEspa\u00f1ol (Spanish)\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationReferenceKubernetes APIKubernetes APIKubernetes' API is the application that serves Kubernetes functionality through a RESTful interface and stores the state of the cluster.Kubernetes resources and \"records of intent\" are all stored as API objects, and modified via RESTful calls to the API. The API allows configuration to be managed in a declarative way. Users can interact with the Kubernetes API directly, or via tools like kubectl. The core Kubernetes API is flexible and can also be extended to support custom resources.Workload ResourcesService ResourcesConfig and Storage ResourcesAuthentication ResourcesAuthorization ResourcesPolicy ResourcesExtend ResourcesCluster ResourcesCommon DefinitionsOther ResourcesCommon ParametersFeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified July 12, 2023 at 1:25 AM PST: Revise docs home page (9520b96a61) Edit this page\nCreate child page\nCreate an issue\nPrint entire section\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "kubernetes-docs"
  },
  {
    "url": "https://kubernetes.io/docs/reference/using-api/",
    "content": "API Overview | Kubernetes\nKubernetesDocumentationKubernetes BlogTrainingCareersPartnersCommunityVersionsRelease Information\nv1.34\nv1.33\nv1.32\nv1.31\nv1.30English\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nEspa\u00f1ol (Spanish)\nEnglish\u09ac\u09be\u0982\u09b2\u09be (Bengali)\n\u4e2d\u6587 (Chinese)\nFran\u00e7ais (French)\nDeutsch (German)\n\u0939\u093f\u0928\u094d\u0926\u0940 (Hindi)\nBahasa Indonesia (Indonesian)\nItaliano (Italian)\n\u65e5\u672c\u8a9e (Japanese)\n\ud55c\uad6d\uc5b4 (Korean)\nPolski (Polish)\nPortugu\u00eas (Portuguese)\n\u0420\u0443\u0441\u0441\u043a\u0438\u0439 (Russian)\nEspa\u00f1ol (Spanish)\n\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430 (Ukrainian)\nTi\u1ebfng Vi\u1ec7t (Vietnamese)Kubernetes Documentation\nDocumentation\nAvailable Documentation Versions\nGetting started\nLearning environment\nProduction environment\nContainer Runtimes\nInstalling Kubernetes with deployment tools\nBootstrapping clusters with kubeadm\nInstalling kubeadm\nTroubleshooting kubeadm\nCreating a cluster with kubeadm\nCustomizing components with the kubeadm API\nOptions for Highly Available Topology\nCreating Highly Available Clusters with kubeadm\nSet up a High Availability etcd Cluster with kubeadm\nConfiguring each kubelet in your cluster using kubeadm\nDual-stack support with kubeadm\nTurnkey Cloud Solutions\nBest practices\nConsiderations for large clusters\nRunning in multiple zones\nValidate node setup\nEnforcing Pod Security Standards\nPKI certificates and requirements\nConcepts\nOverview\nKubernetes Components\nObjects In Kubernetes\nKubernetes Object Management\nObject Names and IDs\nLabels and Selectors\nNamespaces\nAnnotations\nField Selectors\nFinalizers\nOwners and Dependents\nRecommended Labels\nThe Kubernetes API\nCluster Architecture\nNodes\nCommunication between Nodes and the Control Plane\nControllers\nLeases\nCloud Controller Manager\nAbout cgroup v2\nKubernetes Self-Healing\nGarbage Collection\nMixed Version Proxy\nContainers\nImages\nContainer Environment\nRuntime Class\nContainer Lifecycle Hooks\nContainer Runtime Interface (CRI)\nWorkloads\nPods\nPod Lifecycle\nInit Containers\nSidecar Containers\nEphemeral Containers\nDisruptions\nPod Hostname\nPod Quality of Service Classes\nUser Namespaces\nDownward API\nWorkload Management\nDeployments\nReplicaSet\nStatefulSets\nDaemonSet\nJobs\nAutomatic Cleanup for Finished Jobs\nCronJob\nReplicationController\nAutoscaling Workloads\nManaging Workloads\nServices, Load Balancing, and Networking\nService\nIngress\nIngress Controllers\nGateway API\nEndpointSlices\nNetwork Policies\nDNS for Services and Pods\nIPv4/IPv6 dual-stack\nTopology Aware Routing\nNetworking on Windows\nService ClusterIP allocation\nService Internal Traffic Policy\nStorage\nVolumes\nPersistent Volumes\nProjected Volumes\nEphemeral Volumes\nStorage Classes\nVolume Attributes Classes\nDynamic Volume Provisioning\nVolume Snapshots\nVolume Snapshot Classes\nCSI Volume Cloning\nStorage Capacity\nNode-specific Volume Limits\nVolume Health Monitoring\nWindows Storage\nConfiguration\nConfiguration Best Practices\nConfigMaps\nSecrets\nLiveness, Readiness, and Startup Probes\nResource Management for Pods and Containers\nOrganizing Cluster Access Using kubeconfig Files\nResource Management for Windows nodes\nSecurity\nCloud Native Security\nPod Security Standards\nPod Security Admission\nService Accounts\nPod Security Policies\nSecurity For Linux Nodes\nSecurity For Windows Nodes\nControlling Access to the Kubernetes API\nRole Based Access Control Good Practices\nGood practices for Kubernetes Secrets\nMulti-tenancy\nHardening Guide - Authentication Mechanisms\nHardening Guide - Scheduler Configuration\nKubernetes API Server Bypass Risks\nLinux kernel security constraints for Pods and containers\nSecurity Checklist\nApplication Security Checklist\nPolicies\nLimit Ranges\nResource Quotas\nProcess ID Limits And Reservations\nNode Resource Managers\nScheduling, Preemption and Eviction\nKubernetes Scheduler\nAssigning Pods to Nodes\nPod Overhead\nPod Scheduling Readiness\nPod Topology Spread Constraints\nTaints and Tolerations\nScheduling Framework\nDynamic Resource Allocation\nScheduler Performance Tuning\nResource Bin Packing\nPod Priority and Preemption\nNode-pressure Eviction\nAPI-initiated Eviction\nCluster Administration\nNode Shutdowns\nSwap memory management\nNode Autoscaling\nCertificates\nCluster Networking\nObservability\nAdmission Webhook Good Practices\nGood practices for Dynamic Resource Allocation as a Cluster Admin\nLogging Architecture\nCompatibility Version For Kubernetes Control Plane Components\nMetrics For Kubernetes System Components\nMetrics for Kubernetes Object States\nSystem Logs\nTraces For Kubernetes System Components\nProxies in Kubernetes\nAPI Priority and Fairness\nInstalling Addons\nCoordinated Leader Election\nWindows in Kubernetes\nWindows containers in Kubernetes\nGuide for Running Windows Containers in Kubernetes\nExtending Kubernetes\nCompute, Storage, and Networking Extensions\nNetwork Plugins\nDevice Plugins\nExtending the Kubernetes API\nCustom Resources\nKubernetes API Aggregation Layer\nOperator pattern\nTasks\nInstall Tools\nInstall and Set Up kubectl on Linux\nInstall and Set Up kubectl on macOS\nInstall and Set Up kubectl on Windows\nAdminister a Cluster\nAdministration with kubeadm\nAdding Linux worker nodes\nAdding Windows worker nodes\nUpgrading kubeadm clusters\nUpgrading Linux nodes\nUpgrading Windows nodes\nConfiguring a cgroup driver\nCertificate Management with kubeadm\nReconfiguring a kubeadm cluster\nChanging The Kubernetes Package Repository\nOverprovision Node Capacity For A Cluster\nMigrating from dockershim\nChanging the Container Runtime on a Node from Docker Engine to containerd\nFind Out What Container Runtime is Used on a Node\nTroubleshooting CNI plugin-related errors\nCheck whether dockershim removal affects you\nMigrating telemetry and security agents from dockershim\nGenerate Certificates Manually\nManage Memory, CPU, and API Resources\nConfigure Default Memory Requests and Limits for a Namespace\nConfigure Default CPU Requests and Limits for a Namespace\nConfigure Minimum and Maximum Memory Constraints for a Namespace\nConfigure Minimum and Maximum CPU Constraints for a Namespace\nConfigure Memory and CPU Quotas for a Namespace\nConfigure a Pod Quota for a Namespace\nInstall a Network Policy Provider\nUse Antrea for NetworkPolicy\nUse Calico for NetworkPolicy\nUse Cilium for NetworkPolicy\nUse Kube-router for NetworkPolicy\nRomana for NetworkPolicy\nWeave Net for NetworkPolicy\nAccess Clusters Using the Kubernetes API\nAdvertise Extended Resources for a Node\nAutoscale the DNS Service in a Cluster\nChange the Access Mode of a PersistentVolume to ReadWriteOncePod\nChange the default StorageClass\nSwitching from Polling to CRI Event-based Updates to Container Status\nChange the Reclaim Policy of a PersistentVolume\nCloud Controller Manager Administration\nConfigure a kubelet image credential provider\nConfigure Quotas for API Objects\nControl CPU Management Policies on the Node\nControl Topology Management Policies on a node\nCustomizing DNS Service\nDebugging DNS Resolution\nDeclare Network Policy\nDeveloping Cloud Controller Manager\nEnable Or Disable A Kubernetes API\nEncrypting Confidential Data at Rest\nDecrypt Confidential Data that is Already Encrypted at Rest\nGuaranteed Scheduling For Critical Add-On Pods\nIP Masquerade Agent User Guide\nLimit Storage Consumption\nMigrate Replicated Control Plane To Use Cloud Controller Manager\nOperating etcd clusters for Kubernetes\nReserve Compute Resources for System Daemons\nRunning Kubernetes Node Components as a Non-root User\nSafely Drain a Node\nSecuring a Cluster\nSet Kubelet Parameters Via A Configuration File\nShare a Cluster with Namespaces\nUpgrade A Cluster\nUse Cascading Deletion in a Cluster\nUsing a KMS provider for data encryption\nUsing CoreDNS for Service Discovery\nUsing NodeLocal DNSCache in Kubernetes Clusters\nUsing sysctls in a Kubernetes Cluster\nUtilizing the NUMA-aware Memory Manager\nVerify Signed Kubernetes Artifacts\nConfigure Pods and Containers\nAssign Memory Resources to Containers and Pods\nAssign CPU Resources to Containers and Pods\nAssign Devices to Pods and Containers\nSet Up DRA in a Cluster\nAllocate Devices to Workloads with DRA\nAssign Pod-level CPU and memory resources\nConfigure GMSA for Windows Pods and containers\nResize CPU and Memory Resources assigned to Containers\nConfigure RunAsUserName for Windows pods and containers\nCreate a Windows HostProcess Pod\nConfigure Quality of Service for Pods\nAssign Extended Resources to a Container\nConfigure a Pod to Use a Volume for Storage\nConfigure a Pod to Use a PersistentVolume for Storage\nConfigure a Pod to Use a Projected Volume for Storage\nConfigure a Security Context for a Pod or Container\nConfigure Service Accounts for Pods\nPull an Image from a Private Registry\nConfigure Liveness, Readiness and Startup Probes\nAssign Pods to Nodes\nAssign Pods to Nodes using Node Affinity\nConfigure Pod Initialization\nAttach Handlers to Container Lifecycle Events\nConfigure a Pod to Use a ConfigMap\nShare Process Namespace between Containers in a Pod\nUse a User Namespace With a Pod\nUse an Image Volume With a Pod\nCreate static Pods\nTranslate a Docker Compose File to Kubernetes Resources\nEnforce Pod Security Standards by Configuring the Built-in Admission Controller\nEnforce Pod Security Standards with Namespace Labels\nMigrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller\nMonitoring, Logging, and Debugging\nLogging in Kubernetes\nMonitoring in Kubernetes\nTroubleshooting Applications\nDebug Pods\nDebug Services\nDebug a StatefulSet\nDetermine the Reason for Pod Failure\nDebug Init Containers\nDebug Running Pods\nGet a Shell to a Running Container\nTroubleshooting Clusters\nTroubleshooting kubectl\nResource metrics pipeline\nTools for Monitoring Resources\nMonitor Node Health\nDebugging Kubernetes nodes with crictl\nAuditing\nDebugging Kubernetes Nodes With Kubectl\nDeveloping and debugging services locally using telepresence\nWindows debugging tips\nManage Kubernetes Objects\nDeclarative Management of Kubernetes Objects Using Configuration Files\nDeclarative Management of Kubernetes Objects Using Kustomize\nManaging Kubernetes Objects Using Imperative Commands\nImperative Management of Kubernetes Objects Using Configuration Files\nUpdate API Objects in Place Using kubectl patch\nMigrate Kubernetes Objects Using Storage Version Migration\nManaging Secrets\nManaging Secrets using kubectl\nManaging Secrets using Configuration File\nManaging Secrets using Kustomize\nInject Data Into Applications\nDefine a Command and Arguments for a Container\nDefine Dependent Environment Variables\nDefine Environment Variables for a Container\nDefine Environment Variable Values Using An Init Container\nExpose Pod Information to Containers Through Environment Variables\nExpose Pod Information to Containers Through Files\nDistribute Credentials Securely Using Secrets\nRun Applications\nRun a Stateless Application Using a Deployment\nRun a Single-Instance Stateful Application\nRun a Replicated Stateful Application\nScale a StatefulSet\nDelete a StatefulSet\nForce Delete StatefulSet Pods\nHorizontal Pod Autoscaling\nHorizontalPodAutoscaler Walkthrough\nSpecifying a Disruption Budget for your Application\nAccessing the Kubernetes API from a Pod\nRun Jobs\nRunning Automated Tasks with a CronJob\nCoarse Parallel Processing Using a Work Queue\nFine Parallel Processing Using a Work Queue\nIndexed Job for Parallel Processing with Static Work Assignment\nJob with Pod-to-Pod Communication\nParallel Processing using Expansions\nHandling retriable and non-retriable pod failures with Pod failure policy\nAccess Applications in a Cluster\nDeploy and Access the Kubernetes Dashboard\nAccessing Clusters\nConfigure Access to Multiple Clusters\nUse Port Forwarding to Access Applications in a Cluster\nUse a Service to Access an Application in a Cluster\nConnect a Frontend to a Backend Using Services\nCreate an External Load Balancer\nList All Container Images Running in a Cluster\nCommunicate Between Containers in the Same Pod Using a Shared Volume\nConfigure DNS for a Cluster\nAccess Services Running on Clusters\nExtend Kubernetes\nConfigure the Aggregation Layer\nUse Custom Resources\nExtend the Kubernetes API with CustomResourceDefinitions\nVersions in CustomResourceDefinitions\nSet up an Extension API Server\nConfigure Multiple Schedulers\nUse an HTTP Proxy to Access the Kubernetes API\nUse a SOCKS5 Proxy to Access the Kubernetes API\nSet up Konnectivity service\nTLS\nIssue a Certificate for a Kubernetes API Client Using A CertificateSigningRequest\nConfigure Certificate Rotation for the Kubelet\nManage TLS Certificates in a Cluster\nManual Rotation of CA Certificates\nManage Cluster Daemons\nBuilding a Basic DaemonSet\nPerform a Rolling Update on a DaemonSet\nPerform a Rollback on a DaemonSet\nRunning Pods on Only Some Nodes\nNetworking\nAdding entries to Pod /etc/hosts with HostAliases\nExtend Service IP Ranges\nKubernetes Default ServiceCIDR Reconfiguration\nValidate IPv4/IPv6 dual-stack\nExtend kubectl with plugins\nManage HugePages\nSchedule GPUs\nTutorials\nHello Minikube\nLearn Kubernetes Basics\nCreate a Cluster\nUsing Minikube to Create a Cluster\nDeploy an App\nUsing kubectl to Create a Deployment\nExplore Your App\nViewing Pods and Nodes\nExpose Your App Publicly\nUsing a Service to Expose Your App\nScale Your App\nRunning Multiple Instances of Your App\nUpdate Your App\nPerforming a Rolling Update\nConfiguration\nUpdating Configuration via a ConfigMap\nConfiguring Redis using a ConfigMap\nAdopting Sidecar Containers\nSecurity\nApply Pod Security Standards at the Cluster Level\nApply Pod Security Standards at the Namespace Level\nRestrict a Container's Access to Resources with AppArmor\nRestrict a Container's Syscalls with seccomp\nStateless Applications\nExposing an External IP Address to Access an Application in a Cluster\nExample: Deploying PHP Guestbook application with Redis\nStateful Applications\nStatefulSet Basics\nExample: Deploying WordPress and MySQL with Persistent Volumes\nExample: Deploying Cassandra with a StatefulSet\nRunning ZooKeeper, A Distributed System Coordinator\nCluster Management\nRunning Kubelet in Standalone Mode\nConfiguring swap memory on Kubernetes nodes\nInstall Drivers and Allocate Devices with DRA\nNamespaces Walkthrough\nServices\nConnecting Applications with Services\nUsing Source IP\nExplore Termination Behavior for Pods And Their Endpoints\nReference\nGlossary\nAPI Overview\nDeclarative API Validation\nKubernetes API Concepts\nServer-Side Apply\nClient Libraries\nCommon Expression Language in Kubernetes\nKubernetes Deprecation Policy\nDeprecated API Migration Guide\nKubernetes API health endpoints\nAPI Access Control\nAuthenticating\nAuthenticating with Bootstrap Tokens\nAuthorization\nUsing RBAC Authorization\nUsing Node Authorization\nWebhook Mode\nUsing ABAC Authorization\nAdmission Control\nDynamic Admission Control\nManaging Service Accounts\nCertificates and Certificate Signing Requests\nMapping PodSecurityPolicies to Pod Security Standards\nKubelet authentication/authorization\nTLS bootstrapping\nMutating Admission Policy\nValidating Admission Policy\nWell-Known Labels, Annotations and Taints\nAudit Annotations\nKubernetes API\nWorkload Resources\nPod\nBinding\nPodTemplate\nReplicationController\nReplicaSet\nDeployment\nStatefulSet\nControllerRevision\nDaemonSet\nJob\nCronJob\nHorizontalPodAutoscaler\nHorizontalPodAutoscaler\nPriorityClass\nDeviceTaintRule v1alpha3\nResourceClaim\nResourceClaimTemplate\nResourceSlice\nService Resources\nService\nEndpoints\nEndpointSlice\nIngress\nIngressClass\nConfig and Storage Resources\nConfigMap\nSecret\nCSIDriver\nCSINode\nCSIStorageCapacity\nPersistentVolumeClaim\nPersistentVolume\nStorageClass\nStorageVersionMigration v1alpha1\nVolume\nVolumeAttachment\nVolumeAttributesClass\nAuthentication Resources\nServiceAccount\nTokenRequest\nTokenReview\nCertificateSigningRequest\nClusterTrustBundle v1beta1\nSelfSubjectReview\nPodCertificateRequest v1alpha1\nAuthorization Resources\nLocalSubjectAccessReview\nSelfSubjectAccessReview\nSelfSubjectRulesReview\nSubjectAccessReview\nClusterRole\nClusterRoleBinding\nRole\nRoleBinding\nPolicy Resources\nFlowSchema\nLimitRange\nResourceQuota\nNetworkPolicy\nPodDisruptionBudget\nPriorityLevelConfiguration\nValidatingAdmissionPolicy\nValidatingAdmissionPolicyBinding\nMutatingAdmissionPolicy v1beta1\nMutatingAdmissionPolicyBinding v1alpha1\nExtend Resources\nCustomResourceDefinition\nDeviceClass\nMutatingWebhookConfiguration\nValidatingWebhookConfiguration\nCluster Resources\nAPIService\nComponentStatus\nEvent\nIPAddress\nLease\nLeaseCandidate v1beta1\nNamespace\nNode\nRuntimeClass\nServiceCIDR\nCommon Definitions\nDeleteOptions\nLabelSelector\nListMeta\nLocalObjectReference\nNodeSelectorRequirement\nObjectFieldSelector\nObjectMeta\nObjectReference\nPatch\nQuantity\nResourceFieldSelector\nStatus\nTypedLocalObjectReference\nOther Resources\nMutatingAdmissionPolicyBindingList v1beta1\nCommon Parameters\nInstrumentation\nService Level Indicator Metrics\nCRI Pod & Container Metrics\nNode metrics data\nUnderstand Pressure Stall Information (PSI) Metrics\nKubernetes z-pages\nKubernetes Metrics Reference\nKubernetes Issues and Security\nKubernetes Issue Tracker\nKubernetes Security and Disclosure Information\nCVE feed\nNode Reference Information\nKubelet Checkpoint API\nLinux Kernel Version Requirements\nArticles on dockershim Removal and on Using CRI-compatible Runtimes\nNode Labels Populated By The Kubelet\nLocal Files And Paths Used By The Kubelet\nKubelet Configuration Directory Merging\nKubelet Device Manager API Versions\nKubelet Systemd Watchdog\nNode Status\nSeccomp and Kubernetes\nLinux Node Swap Behaviors\nNetworking Reference\nProtocols for Services\nPorts and Protocols\nVirtual IPs and Service Proxies\nSetup tools\nKubeadm\nkubeadm init\nkubeadm join\nkubeadm upgrade\nkubeadm upgrade phases\nkubeadm config\nkubeadm reset\nkubeadm token\nkubeadm version\nkubeadm alpha\nkubeadm certs\nkubeadm init phase\nkubeadm join phase\nkubeadm kubeconfig\nkubeadm reset phase\nImplementation details\nCommand line tool (kubectl)\nIntroduction to kubectl\nkubectl Quick Reference\nkubectl reference\nkubectl\nkubectl annotate\nkubectl api-resources\nkubectl api-versions\nkubectl apply\nkubectl apply edit-last-applied\nkubectl apply set-last-applied\nkubectl apply view-last-applied\nkubectl attach\nkubectl auth\nkubectl auth can-i\nkubectl auth reconcile\nkubectl auth whoami\nkubectl autoscale\nkubectl certificate\nkubectl certificate approve\nkubectl certificate deny\nkubectl cluster-info\nkubectl cluster-info dump\nkubectl completion\nkubectl config\nkubectl config current-context\nkubectl config delete-cluster\nkubectl config delete-context\nkubectl config delete-user\nkubectl config get-clusters\nkubectl config get-contexts\nkubectl config get-users\nkubectl config rename-context\nkubectl config set\nkubectl config set-cluster\nkubectl config set-context\nkubectl config set-credentials\nkubectl config unset\nkubectl config use-context\nkubectl config view\nkubectl cordon\nkubectl cp\nkubectl create\nkubectl create clusterrole\nkubectl create clusterrolebinding\nkubectl create configmap\nkubectl create cronjob\nkubectl create deployment\nkubectl create ingress\nkubectl create job\nkubectl create namespace\nkubectl create poddisruptionbudget\nkubectl create priorityclass\nkubectl create quota\nkubectl create role\nkubectl create rolebinding\nkubectl create secret\nkubectl create secret docker-registry\nkubectl create secret generic\nkubectl create secret tls\nkubectl create service\nkubectl create service clusterip\nkubectl create service externalname\nkubectl create service loadbalancer\nkubectl create service nodeport\nkubectl create serviceaccount\nkubectl create token\nkubectl debug\nkubectl delete\nkubectl describe\nkubectl diff\nkubectl drain\nkubectl edit\nkubectl events\nkubectl exec\nkubectl explain\nkubectl expose\nkubectl get\nkubectl kustomize\nkubectl label\nkubectl logs\nkubectl options\nkubectl patch\nkubectl plugin\nkubectl plugin list\nkubectl port-forward\nkubectl proxy\nkubectl replace\nkubectl rollout\nkubectl rollout history\nkubectl rollout pause\nkubectl rollout restart\nkubectl rollout resume\nkubectl rollout status\nkubectl rollout undo\nkubectl run\nkubectl scale\nkubectl set\nkubectl set env\nkubectl set image\nkubectl set resources\nkubectl set selector\nkubectl set serviceaccount\nkubectl set subject\nkubectl taint\nkubectl top\nkubectl top node\nkubectl top pod\nkubectl uncordon\nkubectl version\nkubectl wait\nkubectl Commands\nkubectl\nJSONPath Support\nkubectl for Docker Users\nkubectl Usage Conventions\nKubectl user preferences (kuberc)\nComponent tools\nFeature Gates\nFeature Gates (removed)\nkube-apiserver\nkube-controller-manager\nkube-proxy\nkube-scheduler\nkubelet\nDebug cluster\nFlow control\nConfiguration APIs\nClient Authentication (v1)\nClient Authentication (v1beta1)\nEvent Rate Limit Configuration (v1alpha1)\nImage Policy API (v1alpha1)\nkube-apiserver Admission (v1)\nkube-apiserver Audit Configuration (v1)\nkube-apiserver Configuration (v1)\nkube-apiserver Configuration (v1alpha1)\nkube-apiserver Configuration (v1beta1)\nkube-controller-manager Configuration (v1alpha1)\nkube-proxy Configuration (v1alpha1)\nkube-scheduler Configuration (v1)\nkubeadm Configuration (v1beta3)\nkubeadm Configuration (v1beta4)\nkubeconfig (v1)\nKubelet Configuration (v1)\nKubelet Configuration (v1alpha1)\nKubelet Configuration (v1beta1)\nKubelet CredentialProvider (v1)\nkuberc (v1alpha1)\nkuberc (v1beta1)\nWebhookAdmission Configuration (v1)\nExternal APIs\nKubernetes Custom Metrics (v1beta2)\nKubernetes External Metrics (v1beta1)\nKubernetes Metrics (v1beta1)\nScheduling\nScheduler Configuration\nScheduling Policies\nOther Tools\nContribute\nContribute to Kubernetes Documentation\nContributing to Kubernetes blogs\nSubmitting articles to Kubernetes blogs\nBlog guidelines\nBlog article mirroring\nPost-release communications\nHelping as a blog writing buddy\nSuggesting content improvements\nContributing new content\nOpening a pull request\nDocumenting for a release\nCase studies\nReviewing changes\nReviewing pull requests\nFor approvers and reviewers\nLocalizing Kubernetes documentation\nParticipating in SIG Docs\nRoles and responsibilities\nIssue Wranglers\nPR wranglers\nDocumentation style overview\nContent guide\nStyle guide\nDiagram guide\nWriting a new topic\nPage content types\nContent organization\nCustom Hugo Shortcodes\nUpdating Reference Documentation\nQuickstart\nContributing to the Upstream Kubernetes Code\nGenerating Reference Documentation for the Kubernetes API\nGenerating Reference Documentation for kubectl Commands\nGenerating Reference Documentation for Metrics\nGenerating Reference Pages for Kubernetes Components and Tools\nAdvanced contributing\nViewing Site Analytics\nDocs smoke test pageKubernetes DocumentationReferenceAPI OverviewAPI OverviewThis section provides reference information for the Kubernetes API.The REST API is the fundamental fabric of Kubernetes. All operations and\ncommunications between components, and external user commands are REST API\ncalls that the API Server handles. Consequently, everything in the Kubernetes\nplatform is treated as an API object and has a corresponding entry in the\nAPI.The Kubernetes API reference\nlists the API for Kubernetes version v1.34.For general background information, read\nThe Kubernetes API.\nControlling Access to the Kubernetes API\ndescribes how clients can authenticate to the Kubernetes API server, and how their\nrequests are authorized.API versioningThe JSON and Protobuf serialization schemas follow the same guidelines for\nschema changes. The following descriptions cover both formats.The API versioning and software versioning are indirectly related.\nThe API and release versioning proposal\ndescribes the relationship between API versioning and software versioning.Different API versions indicate different levels of stability and support. You\ncan find more information about the criteria for each level in the\nAPI Changes documentation.Here's a summary of each level:Alpha:The version names contain alpha (for example, v1alpha1).Built-in alpha API versions are disabled by default and must be explicitly enabled in the kube-apiserver configuration to be used.The software may contain bugs. Enabling a feature may expose bugs.Support for an alpha API may be dropped at any time without notice.The API may change in incompatible ways in a later software release without notice.The software is recommended for use only in short-lived testing clusters,\ndue to increased risk of bugs and lack of long-term support.Beta:The version names contain beta (for example, v2beta3).Built-in beta API versions are disabled by default and must be explicitly enabled in the kube-apiserver configuration to be used\n(except for beta versions of APIs introduced prior to Kubernetes 1.22, which were enabled by default).Built-in beta API versions have a maximum lifetime of 9 months or 3 minor releases (whichever is longer) from introduction\nto deprecation, and 9 months or 3 minor releases (whichever is longer) from deprecation to removal.The software is well tested. Enabling a feature is considered safe.The support for a feature will not be dropped, though the details may change.The schema and/or semantics of objects may change in incompatible ways in\na subsequent beta or stable API version. When this happens, migration\ninstructions are provided. Adapting to a subsequent beta or stable API version\nmay require editing or re-creating API objects, and may not be straightforward.\nThe migration may require downtime for applications that rely on the feature.The software is not recommended for production uses. Subsequent releases\nmay introduce incompatible changes. Use of beta API versions is\nrequired to transition to subsequent beta or stable API versions\nonce the beta API version is deprecated and no longer served.Note:Please try beta features and provide feedback. After the features exit beta, it\nmay not be practical to make more changes.Stable:The version name is vX where X is an integer.Stable API versions remain available for all future releases within a Kubernetes major version,\nand there are no current plans for a major version revision of Kubernetes that removes stable APIs.API groupsAPI groups\nmake it easier to extend the Kubernetes API.\nThe API group is specified in a REST path and in the apiVersion field of a\nserialized object.There are several API groups in Kubernetes:The core (also called legacy) group is found at REST path /api/v1.\nThe core group is not specified as part of the apiVersion field, for\nexample, apiVersion: v1.The named groups are at REST path /apis/$GROUP_NAME/$VERSION and use\napiVersion: $GROUP_NAME/$VERSION (for example, apiVersion: batch/v1).\nYou can find the full list of supported API groups in\nKubernetes API reference.Enabling or disabling API groupsCertain resources and API groups are enabled by default. You can enable or\ndisable them by setting --runtime-config on the API server. The\n--runtime-config flag accepts comma separated <key>[=<value>] pairs\ndescribing the runtime configuration of the API server. If the =<value>\npart is omitted, it is treated as if =true is specified. For example:to disable batch/v1, set --runtime-config=batch/v1=falseto enable batch/v2alpha1, set --runtime-config=batch/v2alpha1to enable a specific version of an API, such as storage.k8s.io/v1beta1/csistoragecapacities, set --runtime-config=storage.k8s.io/v1beta1/csistoragecapacitiesNote:When you enable or disable groups or resources, you need to restart the API\nserver and controller manager to pick up the --runtime-config changes.PersistenceKubernetes stores its serialized state in terms of the API resources by writing them into\netcd.What's nextLearn more about API conventionsRead the design documentation for\naggregatorLearn about Declarative API Validation.FeedbackWas this page helpful?Yes\nNoThanks for the feedback. If you have a specific, answerable question about how to use Kubernetes, ask it on\nStack Overflow.\nOpen an issue in the GitHub Repository if you want to\nreport a problem\nor\nsuggest an improvement.Last modified August 19, 2025 at 8:01 AM PST: docs: add declarative validation tag reference documentation and link doc in appropriate places (0429fde14b) Edit this page\nCreate child page\nCreate an issue\nPrint entire sectionAPI versioningAPI groupsEnabling or disabling API groupsPersistenceWhat's next\u00a9 2025 The Kubernetes Authors | Documentation Distributed under CC BY 4.0\u00a9 2025 The Linux Foundation \u00ae. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage pageICP license: \u4eacICP\u590717074266\u53f7-3",
    "title": "kubernetes-docs"
  }
]